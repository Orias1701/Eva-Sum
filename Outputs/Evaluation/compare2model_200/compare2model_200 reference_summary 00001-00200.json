[
    {
        "Index": "00001",
        "Article": "2.6 Chuyển danh sách Lvào ngăn xếp S; End; Ví dụ : Với ví dụ đồ thị không gian trạng thái như hình 2.2 thì cây tìm kiếm leo đồi tương ứng như hình 2.4 : A 20 C 15 E 7 6 D F I 10 8 B G 0 5 Cây tìm kiếm leo đồi Hạn chế của - Giải thuật có khuynh hướng bị sa lầy ở những cực đại cục bộ: + Lời giải tìm được không tối ưu + Không tìm được lời giải mặc dù có tồn tại lời giải - Giải thuật có thể gặp vòng lặp vô hạn do không lưu giữ thông tin về các trạng thái đã duyệt. * Tìm kiếm Beam Để hạn chế không gian tìm kiếm, người ta đưa ra phương pháp tìm kiếm Beam. Đây là phương pháp tìm kiếm theo chiều rộng nhưng có hạn chế số đỉnh phát triển ở mỗi mức. Trong tìm kiếm theo chiều rộng, tại mỗi mức ta phát triển tất cả các đỉnh, còn tìm kiếm Beam thì chọn k đỉnh tốt nhất để phát triển. Các đỉnh này được xác định bởi hàm đánh giá. Ví dụ, với đồ thì không gian trạng thái như hình 2.2 và lấy k=2 thì cây tìm kiếm Beam như hình 2.5. Các đỉnh được chọn ở mỗi mức là các đỉnh được tô màu đỏ: A 20 C 15 E 7 6 D K 12 F 10 I G 8 5 0 B 5 G B 3 H 0 Cây tìm kiếm Beam * Tìm kiếm nhánh cận Ý tưởng : thuật toán tìm kiếm leo đồi kết hợp với hàm đánh giá f(u). Tại mỗi bước, khi phát triển trạng thái u, chọn trạng thái con v tốt nhất (f(v) nhỏ nhất) của u để phát triển ở bước sau. Quá trình tiếp tục như vậy cho đến khi gặp trạng thái w là đích, hoặc w không có đỉnh kề, hoặc w có f(w) lớn hơn độ dài đường đi tối ưu tạm thời (đường đi đầy đủ ngắn nhất trong số những đường đi đầy đủ đã tìm được). Trong các trường hợp này, chúng ta không phát triển đỉnh w nữa, tức là cắt bỏ những nhánh xuất phát từ w, và quay lên cha của w để tiếp tục đi xuống trạng thái tốt nhất trong số những trạng thái còn lại chưa được phát triển. Procedure Branch-and-Bound; Begin 1. Khởi tạo ngăn xếp S chỉ chứa trạng thái đầu; Gán giá trị ban đầu cho cost; /*cost là giá trị đường đi tối ưu tạm thời*/",
        "Summary": "Văn bản mô tả các thuật toán tìm kiếm trong không gian trạng thái, bao gồm tìm kiếm leo đồi, tìm kiếm Beam và tìm kiếm nhánh cận. Tìm kiếm leo đồi dễ bị mắc kẹt ở cực đại cục bộ và có thể gặp vòng lặp vô hạn. Tìm kiếm Beam khắc phục hạn chế này bằng cách giới hạn số lượng đỉnh được mở rộng ở mỗi mức, dựa trên hàm đánh giá. Cuối cùng, tìm kiếm nhánh cận kết hợp ý tưởng của tìm kiếm leo đồi với một hàm đánh giá để cắt bỏ các nhánh không tiềm năng, tối ưu hóa quá trình tìm kiếm bằng cách loại bỏ các đường đi không hiệu quả.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Tóm tắt tập trung vào việc mô tả các thuật toán tìm kiếm và hạn chế của chúng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00002",
        "Article": "Ngoài ra, chính phủ Mông Cổ đã có những tiến bộ trong việc sử dụng công nghệ thông tin truyêng thông trong việc đơn giản hóa thủ tục để công dân đóng thuế. Cơ quan thuế trực tuyến của Mông Cổ Trang web của Cơ quan Thuế Mông Cổ (http://www.mta.mn) chứa thông tin không chỉ về quyền mà còn một danh sách đầy đủ các dịch vụ đối với công dân và tổ chức. Trong số này là các hình thức thuế có thể tải về , in trong mẫu sẵn và được mua lại với giá từ đại lý thuế. Các doanh nghiệp hoặc cá nhân có thể tải các mẫu đơn từ trang web về, điền thông tin và trình các mẫu đơn này tại 'dịch vụ một điểm”. Đây là một bước tiến lớn trong việc sử dụng công nghệ thông tin truyền thông trong quản lý thuế tại Mông Cổ. Tuy nhiên, chỉ những người có quyền truy cập vào dịch vụ Internet có thể truy cập các website và hưởng lợi từ việc sử dụng này. Một cuộc khảo sát năm 2003 cho thấy, đã có 50.000 người sử dụng chỉ Internet ở Mông Cổ, đại diện cho khoảng 4% dân số. Trong khi dự án đã đạt được hầu hết các mục tiêu của nó, vẫn còn có vấn đề về việc làm thế nào để tiếp cận với các nhóm thiệt thòi, làm thế nào để cải thiện giao diện với người hưởng lợi và đảm bảo sự tham gia của cộng đồng, và làm thế nào để đào tạo lại lực lượng lao động và thay đổi thái độ của tổ chức. Nguồn: Adapted from Mongolian Taxation Authority, http://www.mta.mn. Hệ thống Chính phủ điện tử như cơ quan thuế Mông Cổ có thể làm giảm chi phí giao dịch cho cả hai chính phủ và cho các công dân, qua đó nâng cao thu thuế và tăng tính minh bạch trong hoạt động của chính phủ. Tuy nhiên, trường hợp của Cơ quan thuế của Mông Cổ cũng minh họa những thách thức của chính phủ điện tử mang lại cho người nghèo.",
        "Summary": "Đây là một bước tiến lớn trong việc sử dụng công nghệ thông tin truyền thông trong quản lý thuế tại Mông Cổ. Trong khi dự án đã đạt được hầu hết các mục tiêu của nó, vẫn còn có vấn đề về việc làm thế nào để tiếp cận với các nhóm thiệt thòi, làm thế nào để cải thiện giao diện với người hưởng lợi và đảm bảo sự tham gia của cộng đồng, và làm thế nào để đào tạo lại lực lượng lao động và thay đổi thái độ của tổ chức.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều được lấy trực tiếp từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được trích dẫn liên tiếp nhau và có liên quan đến chủ đề chung. Tuy nhiên, vì là trích đoạn nên sự liên kết giữa các ý có thể chưa được hoàn hảo như một bản tóm tắt được viết lại hoàn toàn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào việc Mông Cổ sử dụng công nghệ thông tin trong quản lý thuế và những thách thức còn tồn tại. Tuy nhiên, việc chỉ trích dẫn hai câu có thể bỏ qua một số chi tiết quan trọng khác, ví dụ như việc trang web của Cơ quan Thuế Mông Cổ cung cấp các dịch vụ gì."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá. Điểm mạnh là tính trung thực cao, đảm bảo thông tin chính xác. Tuy nhiên, để cải thiện, bản tóm tắt nên bao gồm nhiều ý chính hơn từ văn bản gốc để cung cấp cái nhìn toàn diện hơn về chủ đề, đồng thời diễn đạt lại các ý thay vì chỉ trích dẫn để tăng tính mạch lạc."
            }
        }
    },
    {
        "Index": "00003",
        "Article": "JAX-RPC và SAAJ: Java API cho RPC XML-Based (JAX-RPC) và SOAP với Attachments API cho Java (SAAJ) cung cấp giao diện lập trình ứng dụng Java để xử lý các thông điệp SOAP. JAX-RPC cao cấp hơn và được xây dựng trên SAAJ. JAX-RPC xử lý chuyển đổi giữa các đối tượng Java và XML, thực hiện kiểm tra kiểu trong chuyển đổi. JAX-RPC cũng bao gồm các công cụ để tạo ra các tài liệu WSDL từ mã Java và từ các tài liệu WSDL. Đối với SOAP, SAAJ tự xây dựng trên JAXP và cung cấp một API đơn giản hướng về SOAP. Ví dụ, các API bao gồm các phương pháp để quản lý các kết nối SOAP, tạo thông điệp SOAP, trích xuất nội dung thích hợp (tiêu đề, phần thân), và xử lý các phản hồi. Java API cho việc gửi thông điệp XML (JAXM) cung cấp các API cho việc tạo và xử lý bản tin SOAP. JAXM ở mức thấp hơn so với JAX-RPC và đã được thay thế bởi SAAJ. Web Services Invocation Framework: Dịch vụ Web Services Invocation Framework của dự án Apache (WSIF) là một tiếp cận để gọi dịch vụ dựa trên WSDL. WSIF mang quan điểm là client. Tuy nhiên, nó được dựa trên mô tả WSDL của các dịch vụ và về nguyên tắc, là độc lập với các kết nối (binding). Một kết nối cho SOAP có sẵn và quan trọng, nhưng một WSIF client có thể dễ dạng chuyển sang một ràng buộc kết nối khác. JAXR: Java API XML cho XML Registries (JAXR) là một cách tiếp cận dựa trên Java để truy cập vào nhiều loại registry khác nhau, bao gồm cả ISO 11.179, OASIS, ebXML, và UDDI. Nó hữu ích nhất cho việc truy cập một UDDI hoặc ebXML registry để quảng cáo hoặc tìm kiếm một dịch vụ. JAXP: JAXP là một API để xử lý các tài liệu XML. Một trong những thành phần của JAXP là một công cụ phân tích cú pháp dựa trên DOM (Document Object Model). DOM cung cấp một khái niệm đơn giản để duyệt cây phân tích cú pháp của một tài liệu qua xử lý đệ quy. Có một công cụ phân tích cú pháp khác nữa là dựa trên Simple API cho XML (SAX). Hơn nữa, JAXP hỗ trợ các biến đổi XSL (XSLT).",
        "Summary": "JAX-RPC và SAAJ cung cấp API Java để xử lý thông điệp SOAP, trong đó JAX-RPC hỗ trợ chuyển đổi giữa Java và XML, tạo tài liệu WSDL, còn SAAJ cung cấp API đơn giản để quản lý và xử lý thông điệp SOAP. WSIF là một framework của Apache để gọi dịch vụ dựa trên WSDL, hỗ trợ chuyển đổi giữa các kết nối. JAXR cho phép truy cập các registry như UDDI và ebXML, trong khi JAXP hỗ trợ xử lý tài liệu XML, bao gồm phân tích cú pháp DOM, SAX và biến đổi XSLT.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, với sự liên kết tốt giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc và loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo tính súc tích và hiệu quả của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, tính mạch lạc và tính liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin chính xác và trình bày một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00004",
        "Article": "Sự cần thiết của tri thức và lập luận Một yêu cầu quan trọng đối với hệ thống thông minh là phải có khả năng sử dụng tri thức về thế giới xung quanh và lập luận (reasoning) với tri thức đó. Rất khó để đạt được những hành vi thông minh và mềm dẻo mà không có tri thức về thế giới xung quanh và khả năng suy diễn với tri thức đó. Sử dụng tri thức và lập luận đem lại những lợi ích sau. - - Hệ thống dựa trên tri thức có tính mềm dẻo cao. Việc kết hợp tri thức và lập luận (bao gồm suy diễn và suy luận) cho phép tạo ra tri thức khác, giúp hệ thống đạt được những mục tiêu khác nhau, đồng thời có khả năng lập luận về bản thân mục tiêu. Chương trước đã đề cập tới kỹ thuật giải quyết vấn đề bằng cách tìm kiếm. Những hệ thống tìm kiếm chỉ sử dụng tri thức hạn chế, thể hiện trong việc biểu diễn bài toán (như cách sinh ra các chuyển động) và các heuristic. Hệ thống như vậy không có khả năng tự thay đổi mục đích cũng như không có khả năng hành động một cách mềm dẻo, ngoài những gì chứa trong giải thuật và mô tả bài toán. Vì vậy kỹ thuật tìm kiếm là chưa đủ để tạo ra hệ thống thông minh. Sử dụng tri thức và lập luận cho phép hệ thống hoạt động cả trong trường hợp thông tin quan sát về môi trường là không đầy đủ. Hệ thống có thể kết hợp tri thức chung đã có để bổ sung cho thông tin quan sát được khi cần ra quyết định. Ví dụ, khi giao tiếp bằng ngôn ngữ tự nhiên, có thể hiểu một câu ngắn gọn nhờ sử dụng tri thức đã có về ngữ cảnh giao tiếp và nội dung liên quan tới chủ đề. - Việc sử dụng tri thức thuận lợi cho việc xây dựng hệ thống. Thay vì lập trình lại hoàn toàn hệ thống, có thể thay đổi tri thức trang bị cho hệ thống và mô tả mục đích cần đạt được, đồng thời giữ nguyên thủ tục lập luận. Các hệ thống có sử dụng tri thức được gọi là hệ dựa trên tri thức. Hệ thống loại này gồm thành phần cơ bản là cơ sở tri thức (tiếng Anh là Knowledge Base, viết tắt là KB). Cơ sở tri thức gồm các câu hay các công thức trên một ngôn ngữ nào đó và chứa các tri thức về thế giới của bài toán. Cùng với cơ sở tri thức, hệ thống còn có khả năng lập luận, gồm cả suy diễn (inference) và suy luận (deduction), cho phép đưa ra các hành động hoặc câu trả lời hợp lý dựa trên tri thức và thông tin quan sát được. Thực chất, suy diễn hay suy luận là cách tạo ra các câu mới từ những câu đã có. Như vậy, một hệ dựa trên tri thức bao gồm cơ sở tri thức và thủ tục suy diễn.",
        "Summary": "\"Hệ thống thông minh cần tri thức và khả năng lập luận để đạt được hành vi mềm dẻo và thông minh. Việc này giúp hệ thống linh hoạt, tự thay đổi mục đích và hành động ngay cả khi thông tin không đầy đủ, bằng cách kết hợp tri thức chung. Sử dụng tri thức giúp xây dựng hệ thống dễ dàng hơn bằng cách thay đổi tri thức và mục đích, thay vì lập trình lại. Hệ thống dựa trên tri thức (Knowledge-Based System) gồm cơ sở tri thức (Knowledge Base) chứa thông tin về thế giới của bài toán và khả năng lập luận (suy diễn và suy luận) để đưa ra hành động hợp lý.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tóm tắt đúng trọng tâm và có giá trị."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, làm nổi bật được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00005",
        "Article": "Các bước thiết kế chương trình • Xác định bài toán • Phân tích bài toán • Thiết kế thuật toán 5 Chương 1 CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH • Cài đặt chương trình • Thử nghiệm chương trình Định nghĩa. Thuật toán (algorithm) là tập hợp hữu hạn các chỉ thị được định nghĩa rõ ràng nhằm giải quyết một vấn đề cụ thể nào đó. Tính chất. Một thuật toán phải có các tính chất sau • Tính chính xác: quá trình tính toán hay các thao tác máy tính thực hiện là chính xác. • Tính rõ ràng: các câu lệnh minh bạch được sắp xếp theo thứ tự nhất định. • Tính khách quan: được viết bởi nhiều người trên máy tính nhưng kết quả phải như nhau. • Tính phổ dụng: có thể áp dụng cho một lớp các bài toán có đầu vào tương tự nhau. • Tính kết thúc: hữu hạn các bước tính toán Trình bày thuật toán như thế nào? • Trình bày bằng ngôn ngữ tự nhiên • Trình bày bằng mã giả • Trình bày bằng lưu đồ Ví dụ 1.2 Hãy trình bày cách làm món sữa dâu bằng ngôn ngữ tự nhiên Cách 1 • Lấy một ít sữa. • Đổ nước ép dâu vào. • Trộn hỗn hợp này và làm lạnh. Cách 2 • Rót một ly sữa vào máy xay • Đổ thêm vào một ít nước dâu ép • Đóng nắm máy xay • Mở điện và bắt đầu trộn • Dừng máy trộn lại • Nếu đã trộn đều thì tắt máy, ngược lại thì trộn tiếp 6 Chương 1 CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH • Khi đã trộn xong, rót hỗn hợp vào tô và đặt vào tủ lạnh • Để lạnh một lúc rồi lấy ra dùng Ví dụ 1.3 Hãy trình bày cách sắp xếp một dãy số L theo thứ tự tăng dần bằng ngôn ngữ mã giả MergeSort(L) if Size(L)>1 Split(L, L , L ) (tách dãy L thành L và L ) 1 2 1 2 MergeSort(L ) (sắp xếp dãy L ) 1 1 MergeSort(L ) (sắp xếp dãy L ) 2 2 Merge(L , L , L) (trộn dãy L và L thành L) 1 2 1 2 7 Chương 2 LƯU ĐỒ THUẬT TOÁN 2 LƯU ĐỒ THUẬT TOÁN A picture is worth a thousand words thành ngữ Chương này sẽ trình bày các ký hiệu biểu diễn lưu đồ thuật toán, cách biểu diễn các cấu trúc điều khiển rẽ nhánh, cấu trúc lặp và các kỹ thuật liên quan đến lưu đồ thuật toán.",
        "Summary": "Văn bản mô tả khái niệm thuật toán, bao gồm các tính chất như tính chính xác, rõ ràng, khách quan, phổ dụng và tính kết thúc. Thuật toán có thể được trình bày bằng ngôn ngữ tự nhiên, mã giả hoặc lưu đồ. Văn bản minh họa bằng ví dụ về cách làm sữa dâu và sắp xếp mảng số bằng thuật toán MergeSort, nhấn mạnh vào việc sử dụng mã giả để biểu diễn thuật toán. Cuối cùng, văn bản giới thiệu về việc sử dụng lưu đồ để trực quan hóa thuật toán.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa, tính chất, cách trình bày thuật toán và ví dụ minh họa, phản ánh đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00006",
        "Article": "Cách kết hợp hai thuật toán cho phép tìm ra lời giải chất lượng hơn với độ phức tạp tính toán chập nhận được. Kết quả. Thực nghiệm với các trường phổ thông với trên 30 lớp và trên 50 giáo viên cho thấy các kỹ thuật trình bầy ở trên tìm ra thời khoá biểu có chất lượng tốt hơn nhiều (hàm mục tiêu nhỏ hơn nhiều) so với thời khoá biểu xếp bằng tay và các phương pháp heuristic. Quá trình xếp thời khoá biểu có thể thực hiện trên máy tính cá nhân thông thường trong vòng vài phút tới vài chục phút tuỳ kích thước trường. 2.7. CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1. Giả sử ta có ba can đựng nước với dung tích 3 lít, 8 lít và 12 lít. Ta có thể đổ nước đầy các can hoặc rót toàn bộ nước trong can ra ngoài hoặc sang can khác. Cần tìm cách đổ đầy và rót nước khỏi can để đong được 1 lít nước. Trình bầy bài toán này dưới dạng bài toán tìm kiếm và viết chương trình để tìm lời giải, sử dụng một thuật toán tìm kiếm phù hợp. Giải quyết vấn đề bằng tìm kiếm 2. Bài toán nhà truyền giáo và người ăn thịt người. Có ba nhà truyền giáo và ba người thuộc bộ lạc ăn thịt người ở trên bờ một con sông. Cần chuyển cả sáu người sang bờ bên kia bằng một con thuyền có thể chở tối đa hai người. Yêu cầu đặt ra là không có lúc nào số người ăn thịt trên một bờ sông hoặc trên thuyền lớn hơn số nhà truyền giáo. • Hãy phát biểu bài toán dưới dạng bài toán tìm kiếm trong không gian trạng thái và sử dụng thuật toán tìm kiếm phù hợp để tìm ra lời giải. • Xây dựng chương trình máy tính để thực hiện hiện thuật toán.",
        "Summary": "Thực nghiệm với các trường phổ thông với trên 30 lớp và trên 50 giáo viên cho thấy các kỹ thuật trình bầy ở trên tìm ra thời khoá biểu có chất lượng tốt hơn nhiều hàm mục tiêu nhỏ hơn nhiều so với thời khoá biểu xếp bằng tay và các phương pháp heuristic. CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1. Yêu cầu đặt ra là không có lúc nào số người ăn thịt trên một bờ sông hoặc trên thuyền lớn hơn số nhà truyền giáo.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt gần như trung thực. Tuy nhiên, việc trích dẫn hai câu không liên quan đến nhau và đặt cạnh nhau có thể gây hiểu lầm về ý nghĩa ban đầu của văn bản gốc. Câu 'CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1' được chèn vào giữa hai nội dung khác nhau, tạo cảm giác không tự nhiên và có thể không chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt chưa được mạch lạc. Việc trích dẫn các câu từ văn bản gốc một cách rời rạc và không có sự liên kết rõ ràng giữa chúng làm giảm tính mạch lạc của bản tóm tắt. Đặc biệt, việc chèn tiêu đề 'CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1' vào giữa câu làm gián đoạn dòng chảy của ý tưởng."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số chi tiết không thực sự liên quan đến ý chính của đoạn văn. Ví dụ, câu 'CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1' không phải là một phần nội dung cần tóm tắt, mà chỉ là tiêu đề của một phần khác trong văn bản gốc. Việc đưa câu này vào bản tóm tắt làm giảm tính liên quan của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt này có chất lượng ở mức trung bình. Điểm mạnh là nó giữ lại một số thông tin quan trọng từ văn bản gốc. Tuy nhiên, nó mắc phải một số lỗi về tính mạch lạc và tính liên quan, làm giảm giá trị của bản tóm tắt. Để cải thiện, cần tập trung vào việc chọn lọc các ý chính một cách cẩn thận hơn và đảm bảo rằng các ý này được trình bày một cách logic và liên kết với nhau."
            }
        }
    },
    {
        "Index": "00007",
        "Article": "Khi chương trình lớn, việc chia nhỏ chương trình thành các package sẽ thuận lợi hơn cho việc quản lý và phát triển. - Tên gói còn được dùng để định danh lớp cho ứng dụng. - Dòng lệnh khai báo tên khối phải được đặt đầu tiên trong tệp tin mã - Chỉ được khai báo tối đa một tên khối đối với mỗi tệp mã nguồn Java. - Các tệp tin của các lớp nằm cùng gói ứng dụng phải được lưu trong cùng một thư mục (tên thư mục là tên khối) theo cấu trúc khối của dự án. - Tên khối nên đặt theo chữ thường vì tên khối sẽ là tên thư mục tương ứng trong ổ đĩa, tránh nhầm lẫn với tên các tệp tin là tên các lớp của - Khi không phân chia chương trình thành khối (chương trình đơn giản), không cần thiết phải khai báo tên khối ở đầu chương trình. Khai báo thư viện để chỉ ra những thư viện đã được định nghĩa sẵn mà chương trình sẽ tham khảo tới. Cú pháp khai báo thư viện với từ khóa import như sau: Ví dụ, nếu trong chương trình cần đến các thao tác chuyển đổi kiểu dữ liệu tường minh (từ kiểu string sang kiểu int), thì ta sẽ phải tham khảo thư viện java.lang - Nếu muốn khai báo tham khảo nhiều thư viện, phải khai báo tham khảo mỗi thư viện với một từ khóa import. - Nếu chỉ tham khảo một vài lớp trong một thư viện, nên chỉ rõ tham khảo lớp nào, thay vì phải khai báo tham khảo cả gói (bằng kí hiệu “*”) vì tham khảo cả gói sẽ tăng kích thước tệp tin class sau khi biên dịch. - Nếu không tham khảo thư viện nào, không nhất thiết phải khai báo các tham khảo với từ khóa import.",
        "Summary": "Khi chương trình lớn, việc chia nhỏ chương trình thành các package sẽ thuận lợi hơn cho việc quản lý và phát triển. - Các tệp tin của các lớp nằm cùng gói ứng dụng phải được lưu trong cùng một thư mục tên thư mục là tên khối theo cấu trúc khối của dự án. - Tên khối nên đặt theo chữ thường vì tên khối sẽ là tên thư mục tương ứng trong ổ đĩa, tránh nhầm lẫn với tên các tệp tin là tên các lớp của - Khi không phân chia chương trình thành khối chương trình đơn giản, không cần thiết phải khai báo tên khối ở đầu chương trình.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả các thông tin được trình bày trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các ý được trình bày theo một trình tự nhất định và có liên kết với nhau. Tuy nhiên, việc sử dụng dấu '-' ở đầu mỗi câu có thể làm giảm tính trôi chảy khi đọc. Nên sử dụng các liên từ hoặc cấu trúc câu phức tạp hơn để tăng tính liên kết giữa các ý."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt khá liên quan, tập trung vào các ý chính về package trong Java. Tuy nhiên, phần tóm tắt đã bỏ qua phần quan trọng về khai báo thư viện (import), đây là một nội dung lớn thứ hai trong văn bản gốc. Việc lược bỏ hoàn toàn phần này làm giảm giá trị của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt về tính trung thực và mạch lạc. Tuy nhiên, tính liên quan có thể được cải thiện bằng cách bao gồm các ý chính về khai báo thư viện (import). Cần cân nhắc kỹ hơn về việc lựa chọn các ý quan trọng nhất để đưa vào bản tóm tắt, đảm bảo bao quát được các chủ đề chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00008",
        "Article": "IEEE 802.11 Control Frame: có 6 kiểu control frame • Request-to-Send (RTS) RTS được sử dụng để yêu cầu dành đường truyền như một phần của cơ chế truy cập đường truyền trong 802.11. Duration (D): thời gian cần thiết để việc trao đổi frame giữa các trạm diễn ra. Nó bao gồm thời gian để truyền frame RTS (gồm cả khoảng chèn ngắn giữa các khung SIFS-Short InterFrame Space), thời gian để nhận frame CTS (gồm cả SIFS), thời gian để truyền frame dữ liệu và thời gian để nhận frame ACK (gồm cả SIFS). Receiver address: địa chỉ MAC của đích nhận frame. Transmitter address: địa chỉ MAC của nguồn gởi frame. • Clear To Send (CTS) Frame CTS được dùng để hồi đáp cho frame RTS. Frame này báo cho trạm nhận biết rằng đường truyền đã được dành riêng cho nó trong một khoảng thời gian xác định. Duration (D): giá trị này được lấy từ trường Duration của frame RTS trừ đi thời gian cần để truyền frame CTS và khoảng thời gian SIFS. Receiver address: địa chỉ MAC của đích nhận frame. • Acknowledgment (ACK) Dùng để báo nhận trong quá trình truyền frame. Khi trạm nhận nhận được một frame thì nó sẽ gởi frame ACK đến trạm truyền để thông báo rằng nó đã nhận frame thành công. Duration (D): khoảng thời gian để truyền ACK thường là 0 bởi vì frame mà nó đang báo nhận đã bao gồm khoảng thời gian truyền cần thiết cho cả frame ACK và SIFS. Receiver address: địa chỉ MAC của đích muốn nhận. Power-Save Poll (PS-Poll) Được dùng để chỉ cho AP biết rằng có một trạm không dây đang yêu cầu nhận các frame đã lưu trữ dành cho nó. AID: giá trị AID của client không dây với 2 bit đầu tiên được thiết lập thành 1. BSS Identifier (BSSID): địa chỉ MAC của AP trong mạng Infrastructure. Transmitter Address (TA): địa chỉ MAC của trạm không dây (tron chế độ Power save). CF-End và CF-ACK Các frame này được sử dụng trong hoạt động của chức năng phân phối điểm PCF (Point Co-ordination Function). CF-End báo hiệu sự kết thúc của khoảng thời gian không tranh giành đường truyền CFP (Contention-free period) trong khi CF-End + CF- ACK vừa báo hiệu kết thúc CFP đồng thời cũng kèm theo một lời báo nhận cho frame đã nhận trước đó bởi điểm điều phối (chính là AP). Duration (D): được thiết lập về 0. Receiver address: địa chỉ MAC của đích nhận frame. Đối với frame CF-End thì nó là địa chỉ MAC quảng bá (broadcast) bởi vì mọi trạm phải nhận được thông báo này. BSSID: địa chỉ MAC của AP. IEEE 802.11 Management Frame (MMPDU): có tổng cộng 11 kiểu frame: • Beacon • Probe Request • Probe Response • Association Request • Association Response • Disassociation • Reassociation Request • Reassociation Response • (IBSS) Annoucement Traffic Indication Map • Authentication • Deauthentication . IEEE 802.11 Data Frame (MPDU): • FC – 802.11: Frame Control • D – 802.11: Duration • SC – 802.11: Sequence Control • QC – 802.11e: QoS Control • FCS – 802.11: Frame Check Sequence",
        "Summary": "IEEE 802.11 định nghĩa ba loại frame: Control, Management và Data. Control frame (6 kiểu) bao gồm RTS (yêu cầu đường truyền, chứa thông tin thời gian và địa chỉ), CTS (hồi đáp RTS, báo đường truyền đã được dành riêng), ACK (báo nhận frame thành công), PS-Poll (trạm yêu cầu AP gửi frame đã lưu trữ), CF-End và CF-ACK (sử dụng trong PCF, báo hiệu kết thúc CFP). Management frame (11 kiểu) quản lý kết nối và thông tin mạng. Data frame chứa dữ liệu và các trường điều khiển, thời gian, QoS và kiểm tra lỗi.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, giúp người đọc dễ dàng nắm bắt thông tin. Cách phân loại các loại frame và liệt kê các chức năng chính của từng loại rất hiệu quả."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm các loại frame IEEE 802.11 và chức năng của chúng. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00009",
        "Article": "Mạch Trigơ số (có tên là FlipFlop, viết tắt là FF) là một phần tử logic tuẩn tự hết sức quan trọng và cơ bản trong kỹ thuật điện tử số. Một FF thường có 2 đầu ra và có ít nhất hai đầu vào thực hiện các chức năng tối thiểu sau: \n 1. Có hai trạng thái ra là Q và Q̅ ổn định và có tính liên hợp, khi Q =1 thì Q̅ = 0 và ngược lại khi Q = 0 thì Q̅ = 1. \n 2. Các trạng thái đầu ra không những phụ thuộc vào các trạng thái đầu vào áp đến ngay lúc đang xét mà còn phụ thuộc vào trạng thái quá khứ của mình (trước khi áp tín hiệu vào, Q đang ở trạng thái nào?) \n 3. Có khả năng tiếp nhận (ghi vào), lưu giữ trong một thời gian tùy yêu cầu và đưa ra (đọc ra) một trạng thái (1bít) nhị phân đang được lưu giữ trong FF. \n 4. Việc mở rộng chức nãng của FF sẽ được thực hiện nhờ có các đầu vào điều khiến hành vì của FF ngoài các đầu vào tín hiệu đã nói tới (xóa tín hiệu đang lưu, cho phép ghi hay đọc...). Có thể sử dụng các cách sau để thực hiện chức năng của một FF: \n a) Áp tới các lối vào (gọi là lối vào dữ liệu) mức điện thế thích hợp với mức logic 0 hay mức logic 1 - đây là loại FF làm việc ở chế độ không đồng bộ. \n b) Đồng thời với việc trên cần có một lối vào đặc biệt (gọi là đầu vào nhịp) để đưa tới 1 tín hiệu điều khiển (ở mức 1 hoặc mức 0 hoặc lúc ở mức 1 về mức 0 hay lúc ở mức 0 lên mức 1). Chỉ khi xuất hiện tín hiệu điều khiển này (còn được gọi là tín hiệu đồng bộ) khả năng làm việc của FF mới được thực hiện với các đầu vào dữ liệu, đây là loại FF làm việc ở chế độ đồng bộ. \n c) Chỉ sử dụng 1 trong số 2 đầu vào đặc biệt gọi là đầu vào điều khiển trực tiếp ghi hay xoá (xem hình 4.3) mà không dùng hai cách đã nêu trên.",
        "Summary": "Mạch Trigơ số (Flip-Flop - FF) là phần tử logic tuần tự cơ bản trong kỹ thuật điện tử số. FF có hai đầu ra Q và Q̅ (luôn trái trạng thái), có khả năng ghi, lưu giữ và đọc ra 1 bit nhị phân. FF hoạt động ở chế độ không đồng bộ (áp mức điện thế vào lối vào dữ liệu), chế độ đồng bộ (kết hợp lối vào dữ liệu và tín hiệu điều khiển ở đầu vào nhịp) hoặc sử dụng đầu vào điều khiển trực tiếp để ghi/xóa.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, chức năng và các chế độ hoạt động của Flip-Flop, là những thông tin cốt lõi."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được những ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu."
            }
        }
    },
    {
        "Index": "00010",
        "Article": "I.3.2. Ẩn hiện một Tab lệnh\n Để làm ẩn hay xuất hiện một nhóm lệnh hoặc một Tab lệnh trong thanh công cụ Ribbon làm\n như sau:\n - Nhấp phải chuột vào một khoảng trống bất kỳ trên thanh công cụ Ribbon.\n - Một menu nhanh xuất hiện chọn Customize the Ribbon, hộp thoại Excel Option xuất\n hiện và trỏ tới mục Customize the Ribbon.\n - Trong danh sách Main Tabs bên phía tay phải của màn hình liệt kê danh sách các Tab\n Ribbon muốn ẩn Tab nào chỉ cần bỏ dấu tính ở đầu tên Tab đó. Ngược lại muốn hiện\n chúng lên đánh dấu tính cho những Tab bị ẩn. Cuối cùng nhấp OK để lưu lại.\n Lưu ý: Trường hợp muốn ẩn toàn bộ thanh công cụ Ribbon, nhấp chọn biểu tượng Minimize\n the Ribbon (hoặc nhấn tổ hợp phím Ctrl + F1) phía góc phải trên của màn hình chính.\n Khi muốn hiện lại thanh công cụ này, nhấp chuột vào nút lệnh đó một lần nữa.\n I.3.3. Tự tạo một Tab lệnh và các nhóm lệnh trên thanh công cụ Ribbon\n Ngoài những Tab lệnh sẵn có Microsoft Excel còn cung cấp cho người dùng chức năng tự tạo\n ra các Tab lệnh mới, cách thực hiện như sau:\n - Nhấp phải chuột vào một khoảng trống bất kỳ trên thanh công cụ Ribbon.\n - Một menu nhanh xuất hiện, chọn Customize the Ribbon, hộp thoại Excel Option xuất\n hiện và trỏ tới mục Customize the Ribbon.\n - Để thêm một Tab mới, nhấp chọn nút New Tab, một Tab, một nhóm lệnh mới xuất\n hiện như hình dưới đây:\n - Có thể đổi tên cho Tab bằng cách nhấp chuột phải vào Tab này chọn Rename\n - Làm tương tự để đổi tên cho nhóm lệnh\n - Ngoài ra có thể bổ xung các nhóm lệnh khác vào Tab này bằng cách nhấp chọn Tab\n vừa thêm rồi nhấn nút New Group\n Kết quả Tab các lệnh sẽ có được như hình dưới đây\n Công việc cuối cùng của là chọn những lệnh cần thiết để bổ xung vào các nhóm lệnh tương\n ứng. Cuối cùng nhấp OK để hoàn tất.\n Tab lệnh vừa tạo khi xuất hiện trên màn hình chính của chương trình sẽ như hình dưới đây:\n Đây là một ví dụ cơ bản hoàn toàn có thể tạo ra các Tab lệnh được bố trí khoa học và thuận\n tiện cho quá trình sử dụng.",
        "Summary": "\"Để ẩn/hiện Tab lệnh trên thanh Ribbon trong Excel, nhấp chuột phải vào Ribbon, chọn Customize the Ribbon, bỏ/đánh dấu vào ô tương ứng với Tab cần ẩn/hiện. Để ẩn toàn bộ Ribbon, chọn Minimize the Ribbon (Ctrl+F1). Người dùng cũng có thể tự tạo Tab lệnh mới bằng cách chọn New Tab trong Customize the Ribbon, đổi tên Tab và nhóm lệnh, sau đó thêm các lệnh cần thiết vào nhóm. Tab mới tạo sẽ xuất hiện trên thanh Ribbon.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, dễ hiểu. Các câu liên kết với nhau một cách trôi chảy, tạo thành một dòng thông tin liên tục và có ý nghĩa."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào cách ẩn/hiện Tab lệnh và cách tạo Tab lệnh mới trên thanh Ribbon, đúng như nội dung chính của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách ngắn gọn, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00011",
        "Article": "Ngôn ngữ lập trình java có 8 kiểu dữ liệu cơ sở: byte, short, int, long, float, double, boolean và char. 24 Kiểu Kích thước (bytes) Giá trị min Giá trị max Giá trị mặc định byte 1 -256 255 0 short 2 -32768 32767 0 int 4 -231 2 31 - 1 0 long 8 -263 2 63 - 1 0L float 4 0.0f double 8 0.0d 2.2.1.Kiểu số nguyên - Java cung cấp 4 kiểu số nguyên khác nhau là: byte, short, int, long. Kích thước, giá trị nhỏ nhất, lớn nhất, cũng như giá trị mặc định của các kiểu dữ liệu số nguyên được mô tả chi tiết trong bảng trên. - Kiểu mặc định của các số nguyên là kiểu int. - Các số nguyên kiểu byte và short rất ít khi được dùng. - Trong java không có kiểu số nguyên không dấu như trong ngôn ngữ C/C++. Kiểu cơ sở Kiểu luận lý boolean Kiểu số kiểu nguyên kiểu thực Kiểu ký tự char byte short int long float double 25 Khai báo và khởi tạo giá trị cho các biến kiểu nguyên: int x = 0; long y = 100; Một số lưu ý đối với các phép toán trên số nguyên: - Nếu hai toán hạng kiểu long thì kết quả là kiểu long. Một trong hai toán hạng không phải kiểu long sẽ được chuyển thành kiểu long trước khi thực hiện phép toán. - Nếu hai toán hạng đầu không phải kiểu long thì phép tính sẽ thực hiện với kiểu int. - Các toán hạng kiểu byte hay short sẽ được chuyển sang kiểu int trước khi thực hiện phép toán. - Trong java không thể chuyển biến kiểu int và kiểu boolean như trong ngôn ngữ C/C++. Ví dụ: có đoạn chương trình như sau boolean b = false; if (b == 0) { System.out.println(\"Xin chao\"); } Lúc biên dịch đoạn chương trình trên trình dịch sẽ báo lỗi: không được phép so sánh biến kiểu boolean với một giá trị kiểu int. 26 2.2.2.Kiểu dấu chấm động Đối với kiểu dấu chấm động hay kiểu thực, java hỗ trợ hai kiểu dữ liệu là float và double. Kiểu float có kích thước 4 byte và giá trị mặc định là 0.0f Kiểu double có kích thước 8 byte và giá trị mặc định là 0.0d Số kiểu dấu chấm động không có giá trị nhỏ nhất cũng không có giá trị lớn nhất. Chúng có thể nhận các giá trị: - Số âm - Số dương - Vô cực âm - Vô cực dương Khai báo và khởi tạo giá trị cho các biến kiểu dấu chấm động: float x = 100.0/7; double y = 1.56E6; Một số lưu ý đối với các phép toán trên số dấu chấm động: - Nếu mỗi toán hạng đều có kiểu dấn chấm động thì phép toán chuyển thành phép toán dấu chấm động. - Nếu có một toán hạng là double thì các toán hạng còn lại sẽ được chuyển thành kiểu double trước khi thực hiện phép toán. - Biến kiểu float và double có thể ép chuyển sang kiểu dữ liệu khác trừ kiểu boolean. 2.2.3.Kiểu ký tự (char) Kiểu ký tự trong ngôn ngữ lập trình java có kích thước là 2 bytes và chỉ dùng để biểu diễn các ký tự trong bộ mã Unicode. Như vậy kiểu char trong java có thể biểu diễn tất cả 216 = 65536 ký tự khác nhau. Giá trị mặc định cho một biến kiểu char là null. 27 2.2.4.Kiểu luận lý (boolean) - Kiểu boolean chỉ nhận 1 trong 2 giá trị: true hoặc false. - Trong java kiểu boolean không thể chuyển thành kiểu nguyên và ngược lại. - Giá trị mặc định của kiểu boolean là false.",
        "Summary": "Java cung cấp 8 kiểu dữ liệu cơ sở, bao gồm các kiểu số nguyên (byte, short, int, long), số thực (float, double), ký tự (char) và luận lý (boolean). Các kiểu số nguyên có kích thước và phạm vi giá trị khác nhau, với kiểu `int` là kiểu mặc định. Kiểu số thực `float` và `double` biểu diễn số dấu chấm động, có thể nhận giá trị âm, dương, vô cực. Kiểu `char` sử dụng mã Unicode 2 byte, trong khi kiểu `boolean` chỉ nhận hai giá trị `true` hoặc `false` và không thể chuyển đổi trực tiếp sang kiểu số.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các kiểu dữ liệu cơ bản trong Java và đặc điểm chính của từng kiểu."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về các kiểu dữ liệu cơ bản trong Java. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00012",
        "Article": "Mức độ bảo mật của SSL như trên mô tả phụ thuộc chính vào độ dài khoá hay phụ thuộc vào việc sử dụng phiên bản mã hoá 40 bits và 128bits. Phương pháp mã hoá 40 bits được sử dụng rộng rãi không hạn chế ngoài nước Mỹ và phiên bản mã hoá 128 bits chỉ được sử dụng trong nước Mỹ và Canada. Theo luật pháp Mỹ, các mật mã \"mạnh\" được phân loại vào nhóm \"vũ khí\" (weapon) và do đó khi sử dụng ngoài Mỹ (coi như là xuất khẩu vũ khí) phải được phép của chính phủ Mỹ hay phải được cấp giấy phép của Bộ Quốc phòng Mỹ (DoD). Đây là một lợi điểm cho quá trình thực hiện các dịch vụ thương mại và thanh toán điện tử trong Mỹ và các nước đồng minh phương Tây và là điểm bất lợi cho việc sử dụng các sản phẩm cần có cơ chế bảo mật và an toàn trong giao dịch điện tử nói chung và thương mại điện tử nói riêng trong các nước khác.\n Các phương thức tấn công (hay bẻ khoá) của các thuật toán bảo mật thường dùng dựa trên phương pháp \"tấn công vét cạn\" (brute-force attack) bằng cách thử-sai miền không gian các giá trị có thể của khoá. Số phép thử-sai tǎng lên khi độ dài khoá tăng và dẫn đến vượt quá khả nǎng và công suất tính toán, kể cả các siêu máy tính hiện đại nhất. Thí dụ, với độ dài khoá là 40 bits, thì số phép thử sẽ là 240=1,099,511,627,776 tổ hợp. Tuy nhiên độ dài khoá lớn kéo theo tốc độ tính toán giảm (theo luỹ thừa nghịch đảo) và dẫn đến khó có khả nǎng áp dụng trong thực tiễn. Một khi khoá bị phá, toàn bộ thông tin giao dịch trên mạng sẽ bị kiểm soát toàn bộ. Tuy nhiên do độ dài khoá lớn (thí dụ 128 bits, 256 bits), số phép thử-sai trở nên \"không thể thực hiện\" vì phải mất hàng năm hoặc thậm chí hàng nghìn nǎm với công suất và nǎng lực tính toán của máy tính mạnh nhất hiện nay.\n Ngay từ năm 1995, bản mã hoá 40 bits đã bị phá bởi sử dụng thuật toán vét cạn. Ngoài ra, một số thuật toán bảo mật (như DES 56 bits, RC4, MD4,...) hiện nay cũng bị coi là không an toàn khi áp dụng một số phương pháp và thuật toán tấn công đặc biệt. Đã có một số đề nghị thay đổi trong luật pháp Mỹ nhằm cho phép sử dụng rộng rãi các phần mềm mã hoá sử dụng mã hoá 56 bits song hiện nay vẫn chưa được chấp thuận.",
        "Summary": "\"Mức độ bảo mật của SSL phụ thuộc vào độ dài khóa mã hóa (40 bits hoặc 128 bits). Mã hóa 40 bits được sử dụng rộng rãi ngoài Mỹ, trong khi 128 bits giới hạn ở Mỹ và Canada do luật pháp Mỹ coi mật mã mạnh như \"vũ khí\". Việc \"tấn công vét cạn\" (brute-force attack) để bẻ khóa trở nên khó khăn hơn khi độ dài khóa tăng, nhưng khóa dài cũng làm giảm tốc độ tính toán. Mã hóa 40 bits đã bị phá từ năm 1995, và một số thuật toán khác cũng bị coi là không an toàn.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc có thể dễ dàng hiểu được nội dung chính của văn bản gốc thông qua bản tóm tắt này."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào mức độ bảo mật của SSL, sự khác biệt trong việc sử dụng mã hóa ở các quốc gia khác nhau, và các phương pháp tấn công bảo mật."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00013",
        "Article": "Mã hóa âm thanh và hình ảnh là kỹ thuật biểu diễn dữ liệu đa phương tiện trong máy tính, chuyển đổi tín hiệu analog thành dạng số để lưu trữ và xử lý. Đối với âm thanh, PCM (Pulse Code Modulation) là phương pháp cơ bản, lấy mẫu tín hiệu âm thanh (sampling) ở tần số cố định, như 44.1kHz trong CD, rồi lượng tử hóa (quantization) thành giá trị nhị phân, thường 16 bit/mẫu, tạo dãy số biểu diễn biên độ sóng âm. Tần số lấy mẫu cao hơn (96kHz, 192kHz) tăng chất lượng nhưng đòi hỏi dung lượng lớn, trong khi độ sâu bit (bit depth) cao hơn cải thiện độ chính xác. Mã nén như MP3 dùng thuật toán psychoacoustic, loại bỏ tần số con người không nghe được, giảm kích thước tệp từ 10MB/phút (PCM) xuống 1MB/phút, dù mất mát (lossy). Mã FLAC (lossless) nén mà không mất dữ liệu, tiết kiệm 50% dung lượng so với PCM. Hình ảnh tĩnh dùng mã hóa bitmap, gán mỗi điểm ảnh (pixel) một giá trị RGB, như 24 bit (8 bit đỏ, xanh, lục) cho 16 triệu màu; ảnh 1920x1080 chiếm khoảng 6MB chưa nén. JPEG nén lossy bằng cách chuyển sang miền tần số (DCT – Discrete Cosine Transform), loại bỏ chi tiết nhỏ, giảm dung lượng còn vài trăm KB, phù hợp web hoặc lưu trữ. PNG (lossless) dùng nén LZW, giữ chất lượng nhưng lớn hơn JPEG. Video kết hợp mã hóa hình ảnh và âm thanh, như MPEG-4, nén không gian (spatial) trong từng khung và thời gian (temporal) giữa các khung, chỉ lưu thay đổi (motion compensation), giảm từ hàng GB xuống MB. Chuẩn H.264/H.265 cải tiến nén, hỗ trợ 4K với bitrate thấp. Các mã này cần cân bằng giữa chất lượng, dung lượng, và tốc độ xử lý, với phần cứng như GPU hoặc DSP hỗ trợ giải mã thời gian thực. Mã hóa âm thanh và hình ảnh không chỉ tối ưu hóa lưu trữ mà còn định hình cách máy tính xử lý đa phương tiện trong truyền thông và giải trí.",
        "Summary": "Mã hóa âm thanh và hình ảnh là kỹ thuật chuyển đổi dữ liệu đa phương tiện thành định dạng số để lưu trữ, truyền tải và xử lý. Các định dạng phổ biến gồm MP3, AAC cho âm thanh và MPEG, H.264 cho hình ảnh. Mã hóa giúp giảm dung lượng dữ liệu mà vẫn giữ được chất lượng chấp nhận được, hỗ trợ truyền phát qua mạng hoặc lưu trữ lâu dài. Đây là công nghệ thiết yếu trong truyền hình số, phát trực tuyến và các ứng dụng đa phương tiện hiện đại.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt nhìn chung trung thực, tuy nhiên có một vài chi tiết không hoàn toàn khớp với văn bản gốc. Ví dụ, bản tóm tắt đề cập đến AAC như một định dạng âm thanh phổ biến, nhưng văn bản gốc không trực tiếp nhắc đến nó. Ngoài ra, việc tóm tắt 'truyền tải' dữ liệu không được đề cập trực tiếp trong văn bản gốc, mặc dù nó là một hệ quả logic của việc mã hóa và lưu trữ."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu liên kết với nhau một cách logic và dễ hiểu. Tuy nhiên, có thể cải thiện bằng cách làm rõ hơn mối quan hệ giữa các định dạng mã hóa và mục đích sử dụng của chúng."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính của văn bản gốc, như mục đích của mã hóa âm thanh và hình ảnh, các định dạng phổ biến và vai trò của nó trong các ứng dụng đa phương tiện. Tuy nhiên, có thể lược bỏ một số chi tiết ít quan trọng hơn để tập trung vào các khía cạnh kỹ thuật của mã hóa, như các phương pháp nén lossy và lossless."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, truyền tải được ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Tuy nhiên, có thể cải thiện bằng cách tăng tính chính xác trong việc lựa chọn thông tin và làm rõ hơn mối liên hệ giữa các khái niệm kỹ thuật. Cần đảm bảo mọi thông tin đều xuất phát trực tiếp từ văn bản gốc và tránh đưa thêm các chi tiết không có trong đó."
            }
        }
    },
    {
        "Index": "00014",
        "Article": "2. TỔNG QUAN NGHIÊN CỨU\n 2.1. Công nghệ thực tế ảo (VR)\n Công nghệ thực tế ảo, tiếng anh là Virtual Reality (tên viết tắt: VR) hiện nay có rất nhiều định nghĩa\n trên toàn thế giới.\n Theo sách “Virtual Reality” của tác giả Steven M. LaValle, công nghệ thực tế ảo được định nghĩa là\n một hệ thống máy tính mô phỏng một môi trường ảo được hiển thị cho sinh vật có thể cảm nhận được\n giống như thực tế [2].\n Khi sử dụng công nghệ sẽ mang lại nhiều lợi ích, bao gồm:\n - Trải nghiệm tương tác độc đáo\n - Nâng cao chất lượng đào tạo\n - Tiết kiệm chi phí và thời gian\n - Tạo ra cơ hội sáng tạo\n Phần cứng của hệ thống VR được phân loại gồm có 3 thành phần chính (Hình 3) [2]:\n - Cảm biến (đầu vào): thiết bị trích xuất thông tin từ thế giới thực, kích thích giác quan của người\n dùng, tạo cảm giác thật trong môi trường ảo.\n - Máy tính (xử lý): Thiết bị xử lý dữ liệu đầu vào và đầu ra\n - Màn hình (đầu ra): hiển thị mô phỏng thông qua đồ họa, âm thanh, xung lực.2.2. Ứng dụng công nghệ thực tế ảo\n Công nghệ VR tạo ra một môi trường tương tác rất hấp dẫn và chân thực, cho phép người dùng có\n những trải nghiệm mới mẻ và đắm chìm trong thế giới ảo mà không cần phải đi thực tế. Vì vậy, công\n nghệ này được áp dụng trong nhiều lĩnh vực.\n Trong ngành công nghiệp Game giải trí, công nghệ mở ra cho người chơi đắm chìm vào môi trường\n ảo, tạo ra cảm giác sống động và thực sự như đang ở trong trò chơi. Các tựa game sử dụng VR mang\n lại trải nghiệm độc đáo và thú vị, từ các Game chiến đấu trong không gian vũ trụ đến việc khám phá\n thế giới huyền bí [2].\n VR mở ra không gian sáng tạo mới, cho phép các nhà làm phim trong lĩnh vực điện ảnh tạo ra các\n trải nghiệm tương tác độc đáo và góp phần tạo nên các bộ phim bom tấn [3].\n Bên cạnh đó, thay vì chỉ sử dụng các phần mềm họp trực tuyến thông thường, VR cho phép các thành\n viên tham gia họp từ xa trong môi trường ảo như thật. Điều này tạo ra cảm giác như đang gặp mặt\n trực tiếp, giúp cho hiệu quả cuộc họp và tương tác giữa các thành viên tốt hơn [4].",
        "Summary": "\"Công nghệ thực tế ảo (VR) là hệ thống máy tính mô phỏng môi trường ảo, mang lại trải nghiệm tương tác độc đáo, nâng cao chất lượng đào tạo, tiết kiệm chi phí và tạo cơ hội sáng tạo. Phần cứng VR gồm cảm biến (đầu vào), máy tính (xử lý) và màn hình (đầu ra). VR được ứng dụng rộng rãi trong Game giải trí, điện ảnh (tạo trải nghiệm tương tác) và họp trực tuyến (tạo cảm giác gặp mặt trực tiếp).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính về định nghĩa VR, lợi ích, thành phần phần cứng và ứng dụng đều được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ định nghĩa đến lợi ích, thành phần và ứng dụng. Các câu liên kết với nhau một cách tự nhiên, tạo thành một đoạn văn dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Các ý chính được trình bày rõ ràng và logic, giúp người đọc nhanh chóng nắm bắt được nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00015",
        "Article": "AI đang ngày càng khẳng định vai trò quan trọng trong việc cải thiện quản lý và phân phối tài nguyên, đồng thời nâng cao chất lượng dịch vụ và trải nghiệm bệnh nhân trong ngành y tế. Việc áp dụng AI vào quản lý tài nguyên giúp tối ưu hóa quy trình, giảm lãng phí và bảo đảm rằng các nguồn lực được sử dụng hiệu quả. Các hệ thống AI có khả năng phân tích dữ liệu lớn, dự đoán nhu cầu và tự động điều chỉnh việc phân phối tài nguyên, từ đó giúp các tổ chức y tế hoạt động hiệu quả hơn. Một ứng dụng nổi bật của AI trong quản lý tài nguyên là hệ thống quản lý chuỗi cung ứng thông minh. Hệ thống này theo dõi và dự báo nhu cầu về thuốc, thiết bị y tế và vật tư khác, giúp giảm tình trạng thiếu hụt hoặc dư thừa. AI còn hỗ trợ trong việc lập kế hoạch và điều phối nhân lực, bảo đảm bác sĩ và nhân viên y tế được phân bổ hợp lý, nâng cao hiệu quả làm việc và giảm áp lực công việc. Lý do chính khiến chi tiêu cho chăm sóc sức khỏe quá mức là do phân bổ đáng kể vào chi phí hành chính bao gồm nhiều nhiệm vụ “thừa” như xem xét hồ sơ bệnh nhân, ghi chép các cuộc gặp gỡ và quản lý hồ sơ y tế. Nhiệm vụ hành chính là không thể thiếu trong hệ thống chăm sóc sức khỏe; tuy nhiên, chúng tiêu tốn một lượng thời gian và công sức đáng kể. Trung bình, y tá ở Hoa Kỳ dành 25% giờ làm việc của mình cho các nhiệm vụ hành chính6 . Mặc dù những nhiệm vụ này cần thiết, nhưng AI có tiềm năng tự động hóa và hợp lý hóa chúng, giảm gánh nặng cho nhà cung cấp dịch vụ và tối ưu hóa quy trình. Bằng cách phân công các nhiệm vụ lặp đi lặp lại cho AI, thời gian quý báu có thể được dành cho các tương tác chăm sóc bệnh nhân. Ngoài quản lý tài nguyên, AI còn nâng cao chất lượng dịch vụ và trải nghiệm bệnh nhân. Các trợ lý ảo y tế sử dụng AI để cung cấp thông tin và hỗ trợ bệnh nhân 24/7, trả lời câu hỏi, nhắc lịch uống thuốc, và theo dõi triệu chứng, giúp bệnh nhân an tâm và giảm bớt gánh nặng cho nhân viên y tế. Hệ thống đặt lịch hẹn thông minh và quản lý bệnh án điện tử cũng sử dụng AI để tối ưu hóa quy trình khám chữa bệnh, giảm thời gian chờ đợi và nâng cao chất lượng chăm sóc. Nhờ đó, AI mang lại những thay đổi tích cực trong quản lý và phân phối tài nguyên, góp phần nâng cao chất lượng dịch vụ và trải nghiệm bệnh nhân. Sự kết hợp giữa công nghệ AI và các phương pháp quản lý hiện đại giúp các tổ chức y tế hoạt động hiệu quả hơn, mang lại lợi ích thiết thực cho bệnh nhân và cộng đồng.",
        "Summary": "AI đóng vai trò quan trọng trong quản lý tài nguyên y tế, giúp tối ưu hóa quy trình, dự báo nhu cầu, điều phối nhân lực và tự động hóa các nhiệm vụ hành chính, từ đó giảm lãng phí và nâng cao hiệu quả hoạt động. Ngoài ra, AI cải thiện chất lượng dịch vụ và trải nghiệm bệnh nhân thông qua trợ lý ảo y tế, hệ thống đặt lịch hẹn thông minh và quản lý bệnh án điện tử, giúp giảm thời gian chờ đợi và nâng cao chất lượng chăm sóc. Sự kết hợp giữa AI và quản lý hiện đại mang lại lợi ích thiết thực cho cả tổ chức y tế và bệnh nhân.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào vai trò của AI trong quản lý tài nguyên và cải thiện dịch vụ y tế."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00016",
        "Article": "Là một Designer, đôi lúc bạn sẽ phải đối mặt với một căn bệnh cực kì khó chịu “Cạn ý tưởng” hoặc “Ý tưởng chưa về”. Những lúc đó bạn phải làm gì? cứ ngồi đó và đợi nó hết ư? Đối với mình thì mình không làm thế đâu các bạn. Mình phải chủ động tìm ý tưởng, và đây là những nơi mà mình thường làm khi phải đối mặt với vần đề trên. IDEA FOR DESIGN Liều thuốc Quên Đôi lúc thì đối mặt trực tiếp không giải quyết được vấn đề gì đâu các bạn. Nếu các bạn cứ căn óc, mở hai mắt ra mà đối mặt thì hậu quả sẽ là các bạn sẽ bị stress nặng đấy. Cho nên, lời khuyên của mình là hãy Start > Shutdown cái máy tính. Rời bàn làm việc và gọi cho những người bạn thân, các bạn có thể đi giải trí ở đâu đó tùy ý như đi xem phim, đá banh, đánh banh, tenis,… rất nhiều các bạn ạ, mỗi người một sở thích mà, riêng mình thì phim hài của Châu Tinh Trì là lựa chọn số 1. Các bạn có thể dành một ngày để vui chơi, lúc đó, đầu ốc của mình sẽ trở nên cực kì thoái mái. Có thể ý tưởng sẽ tới lúc vui chơi, cũng có thể nó sẽ xuất hiện trong giấc ngủ chẳng hạn. ^^! Và hãy bắt đầu công việc vào ngày hôm sau với tình thần thật thoải mái. Phát triển Web 2012 32 www.izwebz.com Demon Warlock Liều thuốc Notebook Đôi lúc, ý tưởng chợt ùa về, lúc đó bạn sẽ làm thế nào nhỉ? Tớ thì có một cuốn notebook, lúc nào cũng có bên mình, có ý tưởng thì vẽ ra ngay và để dành đó. Sẽ có những lúc death-line cận kề rồi mà ý tưởng nó cứ ở đâu đâu ấy, chưa về tới. Lúc này cuốn notebook lại là vũ khí quan trọng đấy.",
        "Summary": "Khi đối mặt với tình trạng \"cạn ý tưởng\" trong thiết kế, thay vì chờ đợi, tác giả khuyên nên chủ động tìm kiếm ý tưởng bằng cách: (1) Tạm dừng công việc, thư giãn, giải trí để đầu óc thoải mái, biết đâu ý tưởng sẽ đến bất ngờ; (2) Ghi chép mọi ý tưởng thoáng qua vào sổ tay để sử dụng khi cần thiết, đặc biệt là khi thời hạn công việc đang đến gần.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Tóm tắt tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các ý được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ thông điệp quan trọng nhất của bài viết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00017",
        "Article": "Bức tường lửa với cổng giao tiếp ở tầng ứng dụng, hay còn gọi là proxy, đóng vai trò như một trung gian giữa người dùng và dịch vụ mà họ muốn truy cập. Proxy có quyền truy cập đầy đủ vào giao thức ứng dụng, giúp kiểm soát và bảo vệ hệ thống mạng hiệu quả hơn. Khi người dùng gửi yêu cầu truy cập một dịch vụ, proxy sẽ tiếp nhận yêu cầu, kiểm tra xem nó có hợp lệ không, sau đó xử lý và gửi phản hồi lại cho người dùng. Điều này giúp proxy có thể giám sát và kiểm soát luồng dữ liệu ở tầng ứng dụng, tăng cường khả năng bảo mật bằng cách ngăn chặn các yêu cầu độc hại hoặc không hợp lệ ngay từ đầu. Tuy nhiên, để hoạt động hiệu quả, mỗi dịch vụ cần có một proxy chuyên biệt, phù hợp với giao thức mà nó hỗ trợ. Một số dịch vụ, chẳng hạn như HTTP hoặc FTP, có thể tích hợp với proxy một cách tự nhiên mà không cần thay đổi nhiều. Trong khi đó, một số dịch vụ khác yêu cầu giải quyết các vấn đề liên quan đến giao thức và cách thức vận hành của chúng để có thể hoạt động qua proxy một cách hiệu quả. Nhờ khả năng kiểm tra chi tiết từng yêu cầu ở tầng ứng dụng, proxy giúp bảo vệ hệ thống khỏi các cuộc tấn công tinh vi, kiểm soát nội dung truy cập và thậm chí hỗ trợ cân bằng tải trong một số trường hợp. Ngoài ra, proxy còn giúp ẩn danh người dùng bằng cách che giấu địa chỉ IP thực của họ, tăng cường quyền riêng tư trong khi duyệt web. Mặc dù mang lại nhiều lợi ích, việc triển khai proxy cũng đòi hỏi tài nguyên đáng kể, có thể làm chậm kết nối nếu không được tối ưu hóa tốt. Dù vậy, với khả năng bảo vệ mạnh mẽ và kiểm soát chi tiết các yêu cầu truy cập, proxy vẫn là một thành phần quan trọng trong nhiều hệ thống tường lửa hiện đại, đặc biệt là trong các môi trường yêu cầu bảo mật cao.",
        "Summary": "Proxy, là một thành phần trong tường lửa ở tầng ứng dụng, đóng vai trò như trung gian giữa người dùng và dịch vụ, giúp kiểm soát và bảo vệ hệ thống mạng bằng cách kiểm tra và xử lý yêu cầu truy cập. Nó giúp ngăn chặn các yêu cầu độc hại, bảo vệ hệ thống khỏi tấn công tinh vi, và có thể ẩn danh người dùng để tăng cường quyền riêng tư. Tuy nhiên, việc triển khai proxy có thể yêu cầu tài nguyên đáng kể và ảnh hưởng đến hiệu suất kết nối nếu không được tối ưu hóa tốt.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải được thông điệp quan trọng nhất của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Bản tóm tắt đã làm nổi bật được vai trò, lợi ích và hạn chế của proxy một cách ngắn gọn và đầy đủ. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00018",
        "Article": "Purchasing offers and discounts Chiết khấu trong mua bán Cách thức xuất vận sản phẩm Tiêu chí 2 : Đánh giá một Website thƣơng mại điện tử dựa trên các tiêu chí sau: Các yếu tố kỹ thuật Những nội dung cần công bố Giải quyết tranh chấp va bảo mật thông tin Trọng số biểu thị mức độ quan trọng của tiêu chí Các yếu tố kỹ thuật: 1.Thời gian tải các website bằng modem thông thƣờng 3.Bố trí các liên kết trong website 4.Công cụ tìm kiếm trong nội bộ website 5.Thông số an toàn của website Những nội dung cần công bố: 1.Thông tin liên hệ và giới thiệu về ngƣời ngƣời quản lý website và 2.Các điều kiện và điều khoản quy định cách thức kinh doanh trƣớc khi tiến hành giao dịch 3.Thông tin giới thiệu , mô tả về hàng hóa , dịch vụ 4.Thông tin về chi phí , giá cả , lệ phí 1.Cho phép khách hàng xem xét , điều chỉnh đơn đặt hàng 2.Xác nhận các đơn đặt hàng 3.Hệ thống thanh toán an toàn , dễ sử dụng 4.Giao hàng hóa và dich vụ theo thời gian và điều kiện thỏa thuận Giải quyết tranh chấp và bảo mật thông tin: 1.Chính sách riêng cho việc sử lý và giải quyết khiếu lại , tranh chấp 2.Chính sách bảo vệ thông tin của khách hàng Quy trình phát triển website chuẩn đƣợc mô phỏng theo mô hình thác nuớc, các giai đọan chủ chốt đƣợc chia thành các công đọan nhỏ hơn, cho phép thực hiện việc thiết kế web song song một lúc nhiều công đọan. Quy trình chuẩn có thể đƣợc thêm, bớt hoặc thay đổi để phù hợp với nhu cầu của dự án.  Các bước trong quy trình chuẩn:  Bước 1: Lấy thông tin yêu cầu và nghiên cứu tính khả thi Ngay từ giai đoạn đầu, sẽ chỉ định một ngƣời làm đầu mối quản lý account manager để giữ mối liên hệ thƣờng xuyên với ngƣời yêu cầu thực hiện Website trong suốt thời gian thực hiện dự án website. Ngƣời yêu cầu thực hiện Website sẽ thảo luận về yêu cầu và xác định mục tiêu chính cho website cho đơn vị thiết kế Website. Khi đơn vị thiết kế Website hiểu rõ mục đích chủ yếu của ngƣời yêu cầu thực hiện Website, đơn vị thiết kế Website sẽ xác định gói thiết kế Website phù hợp với yêu cầu của ngƣời làm đầu mối nhất. Đơn vị thiết kế Website sẽ cung cấp cho ngƣời làm đầu mối một kế hoạch xây dựng Website để giúp ngƣời làm đầu mối giải quyết tốt các yêu cầu cần thiết cho trang Website.  Bước 2: Phân tích yêu cầu và lên kế hoạch thiết kế website Sau khi các yêu cầu cho việc thiết kế website được thu thập đầy đủ, Đơn vị thiết kế web sẽ tiến hành phân tích yêu cầu để chuyển thành yêu cầu kỹ thuật, phân tích hệ thống, các nhân sự cần thiết và lên kế hoạch thiết kế website. Quá trình này nhằm đảm bảo cho website của bạn được thiết kế sẽ tuân thủ theo quy trình và thực hiện đúng theo kế  Bước 3: Thiết kế giao diện Giai đoạn thiết kế giao diện cho website là một quá trình sáng tạo nhằm chuyển đổi hình ảnh doanh nghiệp của bạn thành một website chất lƣợng, giúp quảng bá doanh nghiệp của ngƣời yêu cầu thực hiện Website thông qua website theo cách chuyên nghiệp nhất. Bản dự án xây dựng website đƣợc hoàn thành trong giai đoạn 1, sẽ giúp các nhân viên thiết kế giao diện hiểu rõ những yêu cầu kỹ thuật và sáng tạo mà website đòi hỏi. Trên cơ sở đó, các nhân viên thiết kế giao diện của đơn vị thiết kế web sẽ chuẩn bị một khái niệm mô hình, minh họa hình dáng và cấu trúc trang web của bạn. Giao diện website mẫu này sẽ đƣợc chuyển cho ngƣời yêu cầu thực hiện Website để lấy ý kiến. Trên cơ sở ý kiến phản hồi của bạn, nhân viên thiết kế giao diện sẽ chỉnh sửa giao diện (nếu đƣợc yêu cầu) trƣớc khi nghiệm thu giao diện lần cuối.",
        "Summary": "Purchasing offers and discounts Chiết khấu trong mua bán Cách thức xuất vận sản phẩm Tiêu chí 2 Đánh giá một Website thƣơng mại điện tử dựa trên các tiêu chí sau Các yếu tố kỹ thuật Những nội dung cần công bố Giải quyết tranh chấp va bảo mật thông tin Trọng số biểu thị mức độ quan trọng của tiêu chí Các yếu tố kỹ thuật 1. Thời gian tải các website bằng modem thông thƣờng 3. Bố trí các liên kết trong website 4.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực, mọi thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, tuy nhiên, do chỉ đơn thuần liệt kê các tiêu chí và yếu tố, nên thiếu sự liên kết rõ ràng giữa các ý. Cần thêm một vài từ nối để tăng tính trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có liên quan đến văn bản gốc, nhưng chỉ dừng lại ở việc liệt kê một số tiêu chí và yếu tố kỹ thuật. Nó bỏ qua các bước trong quy trình phát triển website chuẩn, là một phần quan trọng của văn bản gốc. Do đó, tính liên quan chưa cao vì chưa bao quát hết các ý chính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có độ trung thực cao, tuy nhiên, tính mạch lạc và liên quan cần được cải thiện. Để tăng tính mạch lạc, nên sử dụng các từ nối để liên kết các ý. Để tăng tính liên quan, cần bao gồm thêm thông tin về quy trình phát triển website chuẩn, đảm bảo tóm tắt bao quát được các ý chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00019",
        "Article": "Chức năng của máy tính là thực hiện chương trình thông qua xử lý một tập lệnh do người lập trình cung cấp. Chương trình là tập hợp các lệnh được người lập trình chọn lọc và sắp xếp theo một tuần tự chặt chẽ thông qua nguyên tắc xử lý, giải quyết một vấn đề cụ thể (hay còn gọi là thuật giải). Để thực hiện chức năng này, chương trình được lưu giữ trong bộ nhớ, việc thực hiện chương trình thực chất là các tác vụ thực thi lệnh theo tuần tự được người lập trình quy định. Quá trình thực thi 1 lệnh, như đã trình bày ở trên, gồm các giai đoạn sau: 1. Instruction Fetch - Nhận lệnh IF-Instruction Fetch 2. Giải mã lệnh ID-Instruction Decoder 3. Tạo địa chỉ toán hạng GOA-Generate Operand Address 4. Nhận toán hạng OF-Operand Fetch 5. Xử lý lệnh EX-Execute 6. Lưu kết quả WB-Write Back. Việc đảm bảo thực hiện chương trình theo tuần tự, như đã nói ở trên, là do CU đảm nhận thông qua việc điều khiển sự thay đổi nội dung của thanh đếm chương trình PC. Tuần tự các lệnh trong chương trình là do người lập trình quyết định thông qua việc viết chương trình theo thuật giải. Khi thực hiện một chương trình, thông thường máy tính thực hiện các công việc sau: Thứ nhất, Xử lý dữ liệu: Xử lý các yêu cầu của con người/thiết bị trên cơ sở các dữ liệu được nhập vào. Đây là chức năng quan trọng nhất. Dữ liệu có thể nhiều dạng khác nhau và các yêu cầu xử lý cũng rất khác biệt. Tuy nhiên máy tính chỉ có thể thực hiện được một số lượng hữu hạn các thao tác xử lý cơ bản, người lập trình dựa trên các khả năng xử lý đó mà tạo ra những khả năng xử lý các vấn đề lớn hơn và phức tạp hơn thông qua công việc lập trình. Thứ hai, Lưu trữ dữ liệu: Muốn công việc xử lý dữ liệu đạt hiệu quả cao, máy tính phải có khả năng lưu trữ tạm thời dữ liệu và lưu trữ dữ liệu dài hơn để tái sử dụng sau này. Thứ ba, Di chuyển dữ liệu: Để phục vụ việc xử lý, dữ liệu phải có thể di chuyển từ điểm này tới điểm khác bên trong máy tính. Ngoài ra, để có dữ liệu cho xử lý và gửi kết quả ra bên ngoài, máy tính phải có khả năng trao đổi dữ liệu với môi trường bên ngoài. Thứ tư, Điều khiển: Để thực hiện có hiệu quả ba chức năng nói trên, các tác vụ máy tính thực hiện phải được điều khiển một cách đồng bộ và hợp lý. Quy trình điều khiển này sẽ được thực hiện như con người cung cấp lệnh cho máy tính thi hành thông qua một đơn vị điều khiển bên trong máy tính. Kiến trúc máy tính phải được thiết kế để máy tính có khả năng thực hiện những công việc này.",
        "Summary": "Máy tính thực hiện chương trình bằng cách xử lý một tập lệnh do lập trình viên cung cấp, và quá trình thực thi lệnh bao gồm các giai đoạn như nhận lệnh, giải mã, xử lý và lưu kết quả. Máy tính thực hiện bốn chức năng chính: xử lý dữ liệu, lưu trữ dữ liệu, di chuyển dữ liệu và điều khiển các tác vụ thông qua đơn vị điều khiển. Việc thực hiện các chức năng này đảm bảo sự đồng bộ và hiệu quả trong quá trình xử lý chương trình.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic với nhau, giúp người đọc dễ dàng hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tóm tắt đúng trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan đến nội dung gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00020",
        "Article": "Đặc điểm của L/C\n - L/C là giao dịch kinh tế hai bên giữa ngân hàng phát hành và bên bán, mọi chỉ thị,\n yêu cầu của bên mua sẽ do ngân hàng phát hành đại diện. Cụ thể, ngân hàng phát hành là\n người sẽ thanh toán cho bên bán nên khi bên bán muốn ký phát hối phiếu đòi tiền thì phải gửi\n đến ngân hàng phát hành, không phải là bên mua.\n - L/C độc lập với hợp đồng ngoại thương và hàng hóa: L/C thể hiện cam kết thanh\n toán của ngân hàng phát hành cho người thụ hưởng khi người này xuất trình được bộ chứng\n từ phù hợp, nó hình thành trên cơ sở hợp đồng nhưng sau đó lại hoàn toàn độc lập với hợp\n đồng này.\n - L/C chỉ giao dịch bằng chứng từ và chỉ thanh toán căn cứ vào chứng từ: Ngân hàng\n phát hàng không dựa vào tình trạng của hàng hoá thực tế mà sẽ dựa vào bộ chứng từ thanh\n toán mà bên bán cung cấp có phù hợp với điều khoản trong L/C hay không nên nếu bộ chứng\n từ hợp lệ thì ngân hàng sẽ thanh toán cho bên bán vô điều kiện vì vậy bên mua cần lưu ý trong\n công tác kiểm tra hàng hoá.\n - L/C yêu cầu tuân thủ chặt chẽ của bộ chứng từ: Bộ chứng từ phải tuân thủ chặt chẽ\n các điều khoản của L/C.\n - L/C không thể huỷ ngang (theo quy định của UPC 600 – Phiên bản áp dụng mới nhất\n của bộ Quy tắc thực hành thống nhất về tín dụng chứng từ)\n - Các bên phải thống nhất và ghi rõ phiên bản áp dụng UPC vào L/C.\n - Trước khi mở L/C, bên bán và bên mua cần thống nhất với nhau về các điều khoản\n trong L/C như thời gian giao hàng và thanh toán…\n ü Lợi ích của L/C\n Hình thức thanh toán qua L/C được đánh giá là an toàn được nhiều công ty sử dụng,\n có lợi cho bên bán, bên mua và cả ngân hàng.\n - Đối với bên mua\n + Đảm bảo nhận được hàng hoá: Với L/C, chỉ khi nhận được hàng hoá từ người bán\n thì bên mua mới phải thanh toán cho họ.\n + Đảm bảo các quy định đã đưa ra trong L/C: Giúp cho bên mua yên tâm rằng bên bán59\n phải đảm bảo thực hiện các điều khoản về thời gian, quy chuẩn hàng hoá đã đưa ra trong L/C.\n + Có thể được ngân hàng phát hành cho vay để thanh toán tiền hàng cho bên bán.\n - Đối với bên bán\n + Nhận được thanh toán: Khi bên bán thực hiện đúng theo quy định trong thư tín dụng\n thì chắc chắn sẽ nhận được thanh toán từ ngân hàng phát hành theo điều khoản thanh toán\n trong thư tín dụng.\n + Không phải phụ thuộc vào bên mua: Được đảm bảo quyền lợi dựa trên điều khoản\n của L/C, không phải phụ thuộc vào bên mua như các phương thức thanh toán khác.\n - Đối với ngân hàng\n + Gia tăng doanh thu cho ngân hàng thông qua việc thu phí các dịch vụ liên quan đến\n thư tín dụng\n + Mở rộng quan hệ trong thương mại, tạo được uy tín và danh tiếng trong ngành xuất\n nhập khẩu.",
        "Summary": "\"L/C (Letter of Credit) là giao dịch kinh tế giữa ngân hàng phát hành và bên bán, độc lập với hợp đồng ngoại thương và hàng hóa. Ngân hàng phát hành thanh toán dựa trên chứng từ, yêu cầu tuân thủ chặt chẽ các điều khoản L/C và không thể hủy ngang. Các bên cần thống nhất điều khoản L/C trước khi mở.\n \n L/C mang lại lợi ích cho cả bên mua (đảm bảo nhận hàng, tuân thủ quy định, có thể được vay), bên bán (đảm bảo thanh toán, không phụ thuộc bên mua) và ngân hàng (tăng doanh thu, mở rộng quan hệ).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Tóm tắt tập trung vào đặc điểm và lợi ích của L/C, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Đảm bảo tính trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày một cách hiệu quả những thông tin quan trọng nhất từ văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00021",
        "Article": "Hệ thống ứng dụng được chia thành nhiều loại: hệ thống quản lý thông tin (phân loại theo cấp bậc, chức năng nghiệp vụ hoặc quy mô tích hợp), hệ thông tin bảng tính (như Excel), hệ quản trị cơ sở dữ liệu và hệ thống thông minh (trí tuệ nhân tạo). Cơ sở dữ liệu (database) được định nghĩa là tập hợp dữ liệu có tổ chức, liên quan đến một chủ đề cụ thể, như danh sách sinh viên hoặc sản phẩm. Hệ quản trị cơ sở dữ liệu là phần mềm cho phép tạo, lưu trữ, truy xuất và cập nhật dữ liệu hiệu quả, ví dụ MySQL, Oracle. Giáo trình nhấn mạnh rằng DBMS giúp quản lý dữ liệu lớn, đảm bảo tính nhất quán và bảo mật, vượt trội hơn so với cách lưu trữ thủ công như tệp văn bản. Các chức năng chính của DBMS bao gồm định nghĩa cấu trúc dữ liệu (schema), nhập dữ liệu, truy vấn (query) để lấy thông tin, và cập nhật khi cần. Ví dụ, một cơ sở dữ liệu sinh viên có thể chứa bảng với các cột như mã số, họ tên, điểm, và DBMS cho phép tra cứu nhanh sinh viên có điểm trên 8.0. Hệ thống thông tin bảng tính hỗ trợ xử lý số liệu qua các hàm tính toán, trong khi hệ thống thông minh áp dụng thuật toán học máy để dự đoán hoặc phân tích. Giáo trình cũng đề cập đến phân loại hệ thống quản lý thông tin: theo cấp bậc (chiến lược, chiến thuật, tác nghiệp), theo chức năng (kế toán, nhân sự), hoặc theo tích hợp (hệ thống nhỏ lẻ hoặc toàn doanh nghiệp). Sự khác biệt giữa các loại này nằm ở mục đích sử dụng và quy mô dữ liệu xử lý. Nội dung này không chỉ cung cấp kiến thức lý thuyết mà còn nhấn mạnh ứng dụng thực tiễn, như quản lý thông tin trong doanh nghiệp hoặc nghiên cứu khoa học. Bằng cách hiểu và sử dụng các hệ thống này, sinh viên có thể áp dụng tin học vào giải quyết các vấn đề thực tế, từ quản lý dữ liệu cá nhân đến vận hành tổ chức lớn.",
        "Summary": "Hệ thống ứng dụng được phân loại theo chức năng như: ứng dụng văn phòng (xử lý văn bản, bảng tính), ứng dụng đồ họa (thiết kế, chỉnh sửa ảnh), phần mềm kế toán, quản lý, và các hệ thống chuyên dụng trong y tế, giáo dục, công nghiệp. Mỗi loại phục vụ mục tiêu khác nhau, có giao diện và tính năng riêng biệt. Việc lựa chọn đúng ứng dụng theo nhu cầu giúp nâng cao hiệu suất làm việc, giảm sai sót và tiết kiệm thời gian. Sự phát triển của công nghệ kéo theo sự đa dạng và chuyên biệt hóa của các ứng dụng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chứa nhiều thông tin không có trong văn bản gốc và diễn giải sai lệch ý chính. Văn bản gốc tập trung vào phân loại hệ thống ứng dụng theo cấp bậc, chức năng nghiệp vụ, quy mô tích hợp, hệ thông tin bảng tính, hệ quản trị cơ sở dữ liệu và hệ thống thông minh. Bản tóm tắt lại liệt kê các loại ứng dụng văn phòng, đồ họa, kế toán, quản lý, y tế, giáo dục, công nghiệp, điều này không được đề cập trong văn bản gốc. Ngoài ra, các ý về cơ sở dữ liệu và hệ quản trị cơ sở dữ liệu hoàn toàn bị bỏ qua."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có tính mạch lạc tương đối, các câu liên kết với nhau một cách logic. Tuy nhiên, do nội dung không bám sát văn bản gốc nên tính mạch lạc không thực sự hiệu quả."
            },
            "Tính liên quan": {
                "Điểm": 1,
                "Đánh giá": "Bản tóm tắt rất ít liên quan đến văn bản gốc. Các ý chính của văn bản gốc về các loại hệ thống ứng dụng và cơ sở dữ liệu đã bị bỏ qua, thay vào đó là các thông tin không có trong văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất kém. Nội dung tóm tắt không trung thực, không liên quan đến văn bản gốc và bỏ qua các ý chính. Cần viết lại bản tóm tắt, tập trung vào các ý chính của văn bản gốc và tránh đưa thêm thông tin không có trong văn bản gốc."
            }
        }
    },
    {
        "Index": "00022",
        "Article": "Các tiêu chí để xác định sự thành công của một dự án gồm 3 tiêu chí chính + Dự án được thực hiện đúng theo tiến độ, hoàn thành đúng thời hạn yêu cầu của khách hàng. Để thực hiện được điều đó đội dự án cần thực hiện tốt các công việc lập kế hoạch, ước lượng, và kiểm soát việc thực thi các công việc trong hệ thống. + Dự án được thực hiện với chi phí trong phạm vi ngân sách cho phép. Một lần nữa để đạt được tiêu chí này, các công việc lập kế hoạch, ước lượng và kiểm soát cần được thực hiện tốt. + Tuân thủ theo đúng yêu cầu của khách hàng. Để đạt được tiêu chí này đội dự án phải ý thức được tầm quan trọng về yêu cầu của bài toán (hệ thống) mà cả đội đang phát triển. Tìm hiểu kỹ và nhận thức tốt những khái niệm và những thỏa thuận quan trọng. Để dự án thành công, giám đốc dự án cần nắm được những điểm mấu chốt sau: + Học cách nói “không”, thường xuyên nói “không” vào những lúc cần thiết, nhưng với thái độ lịch sự mà cứng rắn. + Nhận thức giá trị của các phiên bản trung gian trong quá trình phát triển dự án. Tận dụng các kết quả và dùng chúng (nếu có thể) trong những pha phát triển tiếp theo. + Luôn có nhiều phương pháp để phòng tránh rủi ro khi cần thiết. + Luôn nắm được yêu cầu của bài toán (hệ thống đang xây dựng) một cách chặt chẽ và tập trung + Thực hiện xem xét một dự án tại một mốc thời gian + Nên giải quyết mọi công việc theo một cách càng đơn giản càng tốt nhưng không nên quá đơn giản mà hỏng chuyện + Phân nhỏ các công việc hay yêu cầu ra để dễ giải quyết. + Đối với thái độ xử lý các công việc trong toàn bộ quá trình phát triển dự án: không nên quá nghiêm khắc với các thành viên trong đội, cũng không nên đưa ra quá nhiều giải pháp và tiến hành chúng một cách quá cặn kẽ vì người ta thường nói rằng “quá nhiều thuốc sẽ giết chết bệnh nhân”. + Điều hành và quản lý đội dự án nên ở trạng thái cân bằng là quan trọng nhất, đừng quá lộn xộn và cũng đừng quá quy củ, công thức. Theo thống kê, tỉ lệ thành công của các dự án trong thực tế được phân chia theo các ngành, theo kích cỡ. Nếu phân chia theo các ngành thì dự án cho ngành bán buôn là có tỉ lệ thành công cao nhất, vì nhìn chung những dự án này được kiểm soát về chi phí rất chặt chẽ, các dự án cho chính phủ có tỉ lệ ít thành công nhất bởi vì sự kiểm soát về chi phí rất lỏng lẻo. Nếu phân chia các dự án theo kích cỡ thì những dự án càng nhỏ có tỉ lệ thành công càng cao bởi vì những dự án này càng nhỏ thì càng dễ quản lý chi phí, thời gian thực hiện và nhân lực làm việc của đội.",
        "Summary": "\"Để một dự án thành công, cần đáp ứng ba tiêu chí: đúng tiến độ, trong ngân sách và tuân thủ yêu cầu khách hàng. Giám đốc dự án cần biết cách từ chối hợp lý, tận dụng các phiên bản trung gian, phòng tránh rủi ro, nắm vững yêu cầu bài toán, xem xét dự án định kỳ, đơn giản hóa công việc, chia nhỏ yêu cầu và duy trì sự cân bằng trong quản lý đội dự án. Theo thống kê, dự án ngành bán buôn có tỷ lệ thành công cao nhất do kiểm soát chi phí chặt chẽ, trong khi dự án nhỏ dễ thành công hơn do dễ quản lý.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ lại một cách chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các tiêu chí thành công của dự án, vai trò của giám đốc dự án và thống kê về tỷ lệ thành công theo ngành và kích cỡ dự án."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về các điểm chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00023",
        "Article": "Trong hệ thống mã hóa đối xứng, cả hai bên tham gia truyền thông phải chia sẻ một khóa bí mật chung. Một trong những thách thức quan trọng là làm thế nào để phân phối khóa một cách an toàn, vì nhiều hệ thống đã bị bẻ khóa do lỗ hổng trong quá trình phân phối khóa. Có một số phương pháp phổ biến để phân phối khóa giữa hai đối tác A và B. Một cách đơn giản là A tự chọn khóa và gửi trực tiếp cho B, tuy nhiên, điều này tiềm ẩn nguy cơ bị đánh cắp khóa trong quá trình truyền. Một cách khác là sử dụng một bên thứ ba tin cậy để tạo và phân phối khóa đến cả A và B. Ngoài ra, A và B có thể sử dụng một khóa đã có từ trước để mã hóa khóa mới. Một phương pháp khác là cả A và B cùng trao đổi thông tin một cách bí mật với một bên thứ ba C, sau đó C sẽ đóng vai trò trung gian chuyển tiếp khóa giữa hai bên.Khóa trong hệ thống mã hóa thường được phân thành hai loại chính. Khóa phiên (session key) là khóa tạm thời, chỉ được sử dụng trong một phiên làm việc giữa các người dùng và sau đó bị loại bỏ. Trong khi đó, khóa chính (master key) có vai trò quan trọng hơn, được sử dụng để mã hóa các khóa phiên. Khóa chính thường được chia sẻ giữa người dùng và một trung tâm phân phối khóa (Key Distribution Center - KDC).Với các hệ thống mạng lớn, việc phân phối khóa yêu cầu một cơ chế phân cấp với KDC. Tuy nhiên, điều này đòi hỏi phải thiết lập sự tin cậy giữa người dùng với KDC và giữa các KDC với nhau. Để tăng cường bảo mật, thời gian sống của mỗi khóa cần được giới hạn nhằm giảm nguy cơ bị tấn công. Việc phân phối khóa có thể được tự động hóa để giảm tải cho người dùng, nhưng hệ thống này cần đảm bảo tính ngẫu nhiên trong việc tạo khóa. Đồng thời, cần triển khai một hệ thống phân phối khóa phân tán và phân cấp, hỗ trợ kiểm soát mục đích sử dụng khóa nhằm đảm bảo an toàn trong quá trình truyền thông.",
        "Summary": "Trong hệ thống mã hóa đối xứng, việc phân phối khóa bí mật giữa hai bên là một thách thức quan trọng, với các phương pháp như gửi trực tiếp, sử dụng bên thứ ba tin cậy, hoặc trao đổi thông tin qua một bên trung gian. Khóa trong hệ thống mã hóa được chia thành khóa phiên (tạm thời) và khóa chính (dùng để mã hóa khóa phiên), với khóa chính thường được chia sẻ qua một trung tâm phân phối khóa (KDC). Để đảm bảo bảo mật, hệ thống phân phối khóa cần được phân cấp và có cơ chế kiểm soát chặt chẽ, đồng thời giới hạn thời gian sống của khóa và tự động hóa quá trình phân phối.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các phương pháp phân phối khóa, phân loại khóa, và các biện pháp bảo mật đều được tóm tắt chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ thách thức phân phối khóa đến các phương pháp, phân loại khóa, và cuối cùng là các biện pháp bảo mật. Các câu liên kết với nhau một cách trôi chảy, tạo thành một dòng chảy thông tin dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Các ý chính như thách thức phân phối khóa, các phương pháp phân phối, phân loại khóa, và các biện pháp bảo mật đều được đề cập một cách súc tích."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách rõ ràng và súc tích. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00024",
        "Article": "Nếu bên gửi gửi đi tin nhắn có độ dài lớn hơn 160 kí tự thì tin nhắn sẽ được cắt ra thành các tin nhắn có độ dài ngắn hơn, với mỗi tin nhắn có độ dài dưới 160 kí tự. Để làm được điều này, Android cung cấp phương thức một số API để làm điều này: - divideMessage(): đầu vào là đoạn văn bản muốn gửi đi, đầu ra là mảng ArrayList chứa các tin nhắn có chiều dài dưới 160 kí tự. - sendMultipartTextMessage(): cho phép truyền 1 mảng tin nhắn đã phân ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>(); for (int i = 0; i < messageArray.size(); i++) Nhận tin nhắn trong chính ứng dụng Để nhận tin nhắn SMS trong chính ứng dụng cần tạo ra 1 lớp Java kế thừa từ lớp BroadcastReceiver cho phép ứng dụng nhận các Intent gửi từ ứng dụng khác thông qua sendBroadcast(). Việc cài đặt như sau: Cấp quyền cho phép nhận tin nhắn trong chính ứng dụng, trong Trong đó : thuộc tính android:priority được thiết lập có giá trị càng cao thì ứng dụng càng có khả năng cao nhận được tin nhắn. Cài đặt lệnh nhận tin nhắn SMS trong chính ứng dụng: public class SMSReceiver extends BroadcastReceiver public void onReceive(Context context, Intent intent) //---get the SMS message passed in--- SmsMessage[] msgs = null; String str = \"SMS from \"; //---retrieve the SMS message received--- Object[] pdus = (Object[]) bundle.get(\"pdus\"); for (int i=0; i<msgs.length; i++){ //---get the sender address/phone number--- //---display the new SMS message--- Khi ứng dụng nhận được tin nhắn gửi tới, onReceive() được thực thi. Tin nhắn SMS được chứa trong đối tượng Intent ( tham số thứ 2 của onReceive()) thông qua đối Mỗi tin nhắn SMS được chứa trong 1 mảng Object theo định dạng PDU. Nếu tin nhắn SMS có độ dài nhỏ hơn 160 kí tự thì mảng đó chứa 1 phần tử, ngược lại nếu tin nhắn có độ dài lớn hơn 160 kí tự thì mảng sẽ chứa các phần tử, mỗi phần tử là 1 đoạn trong nội dung tin nhắn có độ dài nhỏ hơn 160 kí tự.",
        "Summary": "Để làm được điều này, Android cung cấp phương thức một số API để làm điều này - divideMessage đầu vào là đoạn văn bản muốn gửi đi, đầu ra là mảng ArrayList chứa các tin nhắn có chiều dài dưới 160 kí tự. Việc cài đặt như sau Cấp quyền cho phép nhận tin nhắn trong chính ứng dụng, trong Trong đó thuộc tính androidpriority được thiết lập có giá trị càng cao thì ứng dụng càng có khả năng cao nhận được tin nhắn. Cài đặt lệnh nhận tin nhắn SMS trong chính ứng dụng public class SMSReceiver extends BroadcastReceiver public void onReceiveContext context, Intent intent ---get the SMS message passed in--- SmsMessage msgs null String str SMS from ---retrieve the SMS message received--- Object pdus Object bundle.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số thông tin không chính xác hoặc không đầy đủ so với văn bản gốc. Ví dụ, phần code được trích dẫn bị cắt xén và không đầy đủ, gây khó hiểu. Ngoài ra, một số câu cú bị lược bỏ khiến ý nghĩa không rõ ràng."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc, các ý không được liên kết một cách rõ ràng. Việc trích dẫn các đoạn code không đầy đủ và không có sự giải thích khiến người đọc khó hiểu được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có đề cập đến một số ý chính trong văn bản gốc, nhưng lại bỏ qua nhiều chi tiết quan trọng khác. Việc tập trung quá nhiều vào các đoạn code mà không giải thích đầy đủ khiến bản tóm tắt trở nên khó hiểu và ít giá trị."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt hiện tại có chất lượng kém. Cần cải thiện đáng kể về tính trung thực, mạch lạc và liên quan. Nên tập trung vào việc tóm tắt các ý chính một cách đầy đủ và rõ ràng, thay vì chỉ trích dẫn các đoạn code một cách rời rạc. Cần đảm bảo rằng mọi thông tin trong bản tóm tắt đều chính xác và dễ hiểu."
            }
        }
    },
    {
        "Index": "00025",
        "Article": "• Xét các đoạn lệnh sau. Hãy cho biết kết quả xuất ra màn hình của các biến x, y. Giải thích. … int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) à for ( int j = 0; j < 5; j++ ) 84 if ( ( i + j ) % 2 == 0 ) x++; y += x; â … • Như bài tập trên … int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ ) à if ( ( i + j ) % 2 == 0 ) x++; y += x; â … • Như bài tập trên … 85 int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) à for ( int j = 0; j < 5; j++ ) if ( (x + y ) % 2 == 0 ) x++; y += x; â … • Như bài tập trên … int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ ) à if ( ( i + j ) % 2 == 0 ) x++; else y += x; 86 â … • Như bài tập trên … int i = 0, x = 0; doà if ( x %5 == 0 ) à x++; cout << setw( 4 ) << x; â i++; â while ( i < 20 ); … • Như bài tập trên … int i = 0, x = 0; while ( i < 20 ) 87 à if ( x % 5 == 0 ) à x += i; cout << setw( 4 ) << x; â i++; â … • Như bài tập trên … int i, x = 0; for ( i = 1; i < 10; i*=2 ) à x++; cout << setw( 4 ) << x; â … 88 • Như bài tập trên … int i, x = 0; for (i = 1; i < 10; i++) à if ( i % 2 == 1 ) x += i; else x–– ; cout << setw( 4 ) << x; â … • Như bài tập trên … int i, j, k, x = 0; for ( i = 1; i < 5; i++ ) for ( j = 0; j < i; j++ ) à 89 k = (i + j – 1); if ( k % 2 == 0 ) x += k; else if ( k % 3 ==0 ) x += k – 2; cout << setw( 4 ) << x; â … • Như bài tập trên … int i, j, k, x = 0; for ( i = 1; i < 5; i++ ) for ( j = 0; j < i; j++ ) à switch ( i + j – 1 ) à case –1: 90 case 0: x += 1; break; case 1: case 2: case 3: x += 2; break; default: x += 3; â cout << setw( 4 ) << x; â …",
        "Summary": "Văn bản trình bày một loạt các đoạn mã C++ với các vòng lặp `for` và `while`, cùng câu lệnh điều kiện `if` và `switch`. Mỗi đoạn mã thực hiện các phép tính khác nhau trên các biến `x` và `y`, thay đổi giá trị của chúng dựa trên điều kiện modulo. Kết quả cuối cùng của `x` và `y` phụ thuộc vào logic của mỗi đoạn mã, bao gồm cả việc tăng hoặc giảm giá trị biến dựa trên điều kiện chia hết cho 2, 3 hoặc 5. Các đoạn mã minh họa các kỹ thuật lập trình cơ bản như vòng lặp lồng nhau, điều kiện và toán tử modulo trong C++.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Bản tóm tắt đã nắm bắt được bản chất của các đoạn mã C++ được trình bày trong văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Cách diễn đạt súc tích giúp người đọc nhanh chóng nắm bắt được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm việc sử dụng các vòng lặp, câu lệnh điều kiện, và các phép toán trên biến. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt trở nên ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã thành công trong việc tóm gọn nội dung chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00026",
        "Article": "Tường lửa đóng vai trò như một rào chắn giữa mạng nội bộ tin cậy và các mạng bên ngoài không tin cậy như Internet, kiểm soát luồng lưu lượng mạng ra vào dựa trên một tập hợp các quy tắc xác định trước. Có hai loại tường lửa chính: tường lửa phần cứng và tường lửa phần mềm. Tường lửa phần cứng là các thiết bị chuyên dụng, thường được triển khai tại ranh giới giữa mạng nội bộ và Internet, trong khi tường lửa phần mềm là các chương trình được cài đặt trên hệ điều hành máy chủ hoặc máy trạm. Ngoài ra, còn có tường lửa thế hệ mới (Next Generation Firewall – NGFW) tích hợp thêm các chức năng như kiểm tra gói tin ở lớp ứng dụng, phát hiện xâm nhập, và lọc nội dung nâng cao. Các kỹ thuật lọc của tường lửa có thể bao gồm lọc gói tin (packet filtering), kiểm tra trạng thái kết nối (stateful inspection), và lọc theo proxy. Tường lửa có thể được cấu hình để chặn hoặc cho phép lưu lượng dựa trên các tiêu chí như địa chỉ IP, cổng, giao thức hoặc nội dung. Việc cấu hình tường lửa cần được thực hiện cẩn thận để đảm bảo không làm gián đoạn các dịch vụ hợp lệ, đồng thời ngăn chặn các lưu lượng độc hại. Tường lửa không thể bảo vệ khỏi tất cả các mối đe dọa, nhưng là một phần không thể thiếu trong kiến trúc phòng thủ nhiều lớp (defense in depth). Ngoài ra, tường lửa cần được giám sát và cập nhật định kỳ để đảm bảo hiệu quả hoạt động và thích ứng với các mối đe dọa mới. Trong các hệ thống lớn, thường triển khai tường lửa theo tầng – ví dụ: tường lửa tại biên mạng, tường lửa trong nội bộ và cả trên các thiết bị đầu cuối. Sự kết hợp giữa tường lửa truyền thống và các công nghệ bảo mật khác giúp tăng cường khả năng bảo vệ hệ thống trước các tấn công ngày càng tinh vi.",
        "Summary": "Tường lửa là công cụ bảo vệ hệ thống bằng cách kiểm soát lưu lượng mạng ra vào dựa trên các quy tắc bảo mật được thiết lập trước. Có thể chia tường lửa thành phần cứng, phần mềm hoặc dịch vụ đám mây, mỗi loại phù hợp với quy mô và nhu cầu khác nhau. Tường lửa giúp ngăn chặn truy cập trái phép, lọc nội dung nguy hiểm và hạn chế các kết nối không mong muốn. Việc cấu hình đúng, cập nhật định kỳ và tích hợp với các hệ thống bảo mật khác là yếu tố then chốt để phát huy hiệu quả bảo vệ toàn diện.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt nhìn chung trung thực với văn bản gốc. Tuy nhiên, việc đề cập đến 'dịch vụ đám mây' như một loại tường lửa có thể gây hiểu nhầm, vì văn bản gốc chỉ đề cập đến tường lửa phần cứng, phần mềm và NGFW. Mặc dù tường lửa có thể được triển khai trên đám mây, nhưng cách diễn đạt này có thể không hoàn toàn chính xác so với nội dung gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các ý được trình bày một cách logic, từ định nghĩa tường lửa đến các loại, chức năng và yếu tố để đảm bảo hiệu quả. Tuy nhiên, có thể cải thiện bằng cách liên kết rõ ràng hơn giữa các câu."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa, các loại, chức năng và tầm quan trọng của việc cấu hình và cập nhật tường lửa. Tuy nhiên, có thể lược bỏ chi tiết 'dịch vụ đám mây' để tập trung hơn vào các loại tường lửa được đề cập trong văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, đã nắm bắt được các ý chính của văn bản gốc. Tuy nhiên, cần chú ý hơn đến tính chính xác tuyệt đối so với văn bản gốc và đảm bảo mọi thông tin đều có thể truy xuất trực tiếp từ đó. Việc diễn giải nên cẩn trọng để tránh thêm thông tin mới hoặc làm sai lệch ý nghĩa ban đầu. Cần xem xét lại chi tiết về 'dịch vụ đám mây' để đảm bảo tính trung thực và liên quan."
            }
        }
    },
    {
        "Index": "00027",
        "Article": "Trong phân tích tín hiệu miền thời gian, có nhiều dạng tín hiệu thông dụng được phân thành ba nhóm chính: tín hiệu năng lượng, tín hiệu công suất và tín hiệu phân bố. Tín hiệu năng lượng bao gồm các dạng như xung vuông, xung tam giác, xung hàm mũ giảm, tín hiệu sin suy giảm theo hàm mũ và tín hiệu Sa, với đặc điểm chung là năng lượng hữu hạn. Tín hiệu công suất bao gồm tín hiệu bước nhảy, tín hiệu hàm mũ tăng, hàm dấu, tín hiệu sin - cos, dãy xung vuông lưỡng cực và đơn cực, có công suất trung bình hữu hạn và thường tồn tại trong khoảng thời gian vô hạn. Tín hiệu phân bố bao gồm phân bố Delta Dirac và phân bố lược, đóng vai trò quan trọng trong lý thuyết xử lý tín hiệu. Các thông số đặc trưng của tín hiệu gồm tích phân tín hiệu, trị trung bình, năng lượng và công suất trung bình. Trị trung bình mô tả giá trị trung bình của tín hiệu theo thời gian, trong khi năng lượng và công suất giúp phân biệt tín hiệu năng lượng và tín hiệu công suất. Một tín hiệu có năng lượng hữu hạn nhưng công suất bằng không thường chỉ tồn tại trong một khoảng thời gian nhất định, còn tín hiệu công suất có giá trị trung bình hữu hạn trong suốt khoảng thời gian vô hạn. Bên cạnh đó, phân tích thành phần tín hiệu giúp tách tín hiệu thành các phần thực - ảo, một chiều - xoay chiều, và chẵn - lẻ. Thành phần thực và ảo của một tín hiệu phức giúp dễ dàng biểu diễn và phân tích trong các hệ thống xử lý tín hiệu số. Thành phần một chiều và xoay chiều giúp xác định sự biến thiên của tín hiệu theo thời gian. Thành phần chẵn - lẻ hỗ trợ trong việc đơn giản hóa các phép biến đổi tín hiệu bằng cách xác định tính đối xứng của nó. Cuối cùng, phân tích tương quan đóng vai trò quan trọng trong việc xác định mối quan hệ giữa hai tín hiệu, giúp đánh giá mức độ tương đồng và sự phụ thuộc giữa chúng theo thời gian. Các khái niệm và phương pháp trong chương này là nền tảng quan trọng để hiểu rõ hơn về cách tín hiệu thay đổi và được xử lý trong thực tế.",
        "Summary": "\"Trong phân tích tín hiệu miền thời gian, các tín hiệu được phân loại thành tín hiệu năng lượng (năng lượng hữu hạn), tín hiệu công suất (công suất trung bình hữu hạn) và tín hiệu phân bố (Delta Dirac và lược). Các thông số đặc trưng bao gồm tích phân, trị trung bình, năng lượng và công suất. Phân tích thành phần tín hiệu giúp tách tín hiệu thành phần thực-ảo, một chiều-xoay chiều, chẵn-lẻ để đơn giản hóa biểu diễn và xử lý. Phân tích tương quan xác định mối quan hệ và độ tương đồng giữa các tín hiệu.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào việc phân loại tín hiệu, các thông số đặc trưng, phân tích thành phần và phân tích tương quan, đúng với trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về nội dung chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00028",
        "Article": "Truyền dữ liệu tin cây trên kênh truyền có lỗi bit Một dạng kênh truyền thực tế hơn là gói tin trên kênh truyền có thể bị lỗi, thường bit bị lỗi xảy ra trên đường truyền vật lý của mạng. Giả sử tất cả các gói dữ liệu truyền đi đều đến được đích và theo đúng thứ tự gửi mặc dù các bit trong gói dữ liệu có thể bị lỗi. Xuất phát từ thực tế cuộc hội thoại giữa hai người, nếu người nghe đã rõ thì xác nhận, ngược lại sẽ yêu cầu người nói nhắc lại, cơ chế này đã được áp dụng cho rdt 2.0. Trong mạng máy tính, giao thức truyền tin cậy dựa trên cơ chế truyền lại như vậy được gọi là các giao thức yêu cầu nhắc lại tự động (ARQ - Automatic Repeat Request). Các giao thức ARQ cần phải có ba khả năng sau để xử lý trường hợp có lỗi bit: - Phát hiện lỗi: Cơ chế cho phép bên nhận phát hiện được khi nào trong gói tin có bit bị lỗi, kỹ thuật CRC thường được sử dụng để thực hiện công việc này. Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 86 - Phản hồi từ phía nhận: Khi phía gửi và phía nhận nằm trên các thiết bị đầu cuối khác nhau - có thể cách nhau hàng nghìn km, cách duy nhất để phía gửi biết được kết quả gửi là phía nhận gửi thông tin phản hồi thông báo tình trạng nhận cho phía gửi. Báo nhận đúng ACK và báo nhận sai NAK trong ví dụ trên chính là các thông tin phản hồi. Giao thức rdt 2.0 yêu cầu phía nhận gửi phản hồi các bản tin ACK hay NAK cho phía gửi. Đoạn dữ liệu phản hồi chỉ cần sử dụng một bit, ví dụ giá trị 0 ứng với NAK và giá trị 1 ứng với ACK. - Truyền lại: Đoạn dữ liệu bị lỗi sẽ được bên gửi phát lại.",
        "Summary": "\"Trên kênh truyền có lỗi bit, các gói tin có thể bị lỗi do lỗi bit trên đường truyền vật lý. Các giao thức yêu cầu nhắc lại tự động (ARQ) dựa trên cơ chế truyền lại để đảm bảo truyền tin cậy. Để xử lý lỗi bit, giao thức ARQ cần có ba khả năng: phát hiện lỗi (thường dùng kỹ thuật CRC), phản hồi từ phía nhận (ACK hoặc NAK) và truyền lại dữ liệu bị lỗi.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của vấn đề truyền dữ liệu tin cậy trên kênh truyền có lỗi bit và các yếu tố cần thiết để giải quyết vấn đề này."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00029",
        "Article": "11. Bộ điều khiển gửi một thông điệp tới nút đi lên ở tầng 3 để nó trở về trạng thái bình 12. Bộ điều khiển thang máy gửi một loạt thông điệp tới thang máy để nó di chuyển lên tới 13. Bộ điều khiển thang máy gửi một thông điệp tới nút 7 ở thang máy để nó trở về trạng thái bình thường (không sáng). 14. Bộ điều khiển thang máy gửi một thông điệp tới cửa thang máy yêu cầu mở cửa để cho phép người dùng A bước ra khỏi thang máy. 15. Bộ điều khiển thang máy bắt đầu đặt thời gian. Người dùng A bước ra khỏi thang máy. 16. Bộ điều khiển thang máy gửi một thông điệp tới cửa thang máy để đóng cửa sau một 17. Bộ điều khiển thang máy gửi một loạt thông điệp tới thang máy để nó di chuyển lên Hình 12.10 Vòng lặp thứ hai của kịch bản chuẩn Các biểu đồ đóng vai trò quan trọng trong phân tích hướng đối tượng. Các biểu đồ thường xuyên thay đổi do đó cần có các công cụ vẽbiểu đồ. Các công cụ hỗ trợ cho UML: Các công cụ mang tính thương mại như: IBM Rational Rose và Together. Các công cụ Open-source: AgroUML Mục đích của bước này là viết các kịch bản (scenario) cho các use case đã xác định được trong pha lấy yêu cầu. Để tập trung vào phần nghiệp vụ chuyên môn, các kịch bản trong mục này sẽ bỏ qua phần đăng nhập của các nhân viên cho ngắn gọn. a. Kịch bản sửa thông tin phòng Nhân viên quản lí (QL) vào hệ thống để sửa thông tin phòng 305 của khách sạn. Hệ thống hiện giao diện đăng nhập, có ô nhập tên đăng nhập, mật khẩu, và nút đăng nhập. Nhân viên nhập thông tin tài khoản của mình và click đăng nhập Hệ thống hiện giao diện chính của nhân viên quản lí, có 3 chức năng lựa chọn: quản lí thông tin khách sạn, quản lí thông tin phòng, xem thống kê.",
        "Summary": "Bộ điều khiển thang máy gửi một thông điệp tới cửa thang máy yêu cầu mở cửa để cho phép người dùng A bước ra khỏi thang máy. Các công cụ Open-source AgroUML Mục đích của bước này là viết các kịch bản scenario cho các use case đã xác định được trong pha lấy yêu cầu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt trích dẫn chính xác các câu từ có trong văn bản gốc mà không hề thêm thông tin hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc. Các câu trích dẫn được lấy ra từ văn bản gốc một cách ngẫu nhiên và không có sự liên kết logic nào với nhau. Điều này khiến cho người đọc khó hiểu được ý nghĩa tổng thể mà bản tóm tắt muốn truyền đạt."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chứa các chi tiết không quan trọng và bỏ qua nhiều ý chính của văn bản gốc. Ví dụ, việc trích dẫn tên một công cụ Open-source (AgroUML) không thực sự cần thiết trong một bản tóm tắt tổng quan. Hơn nữa, bản tóm tắt không làm rõ được ngữ cảnh của các thông điệp mà bộ điều khiển thang máy gửi đi, khiến cho thông tin trở nên rời rạc và khó hiểu."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có tính trung thực cao vì trích dẫn chính xác từ văn bản gốc, nhưng lại rất yếu về tính mạch lạc và tính liên quan. Các ý được chọn lọc một cách ngẫu nhiên, không có sự liên kết và không tập trung vào các ý chính. Để cải thiện, cần chọn lọc các ý quan trọng nhất, sắp xếp chúng một cách logic và đảm bảo sự liên kết giữa các câu."
            }
        }
    },
    {
        "Index": "00030",
        "Article": "Phân tích toán học Mục đích cuối cùng của thuật toán phân cụm K-means là từ dữ liệu đầu vào và số lượng cụm cần tìm, hãy xác định tâm mỗi cụm và phân các điểm dữ liệu vào cụm tương ứng. Giả sử thêm rằng mỗi điểm dữ liệu chỉ thuộc đúng một cụm. Giả sử N điểm dữ liệu trong tập huấn luyện được ghép lại thành ma trận X = [x1, x2, . . . , xN ] ∈ R d×N và K < N là số cụm được xác định trước. Ta cần tìm các tâm cụm m1, m2, . . . , mK ∈ R d×1 và nhãn của mỗi điểm dữ liệu. Ở đây, mỗi cụm được đại diển bởi một nhãn, thường là một số tự nhiên từ 1 đến K. Nhắc lại rằng các điểm dữ liệu trong bài toán phân cụm K-means ban đầu không có nhãn cụ thể. Với mỗi điểm dữ liệu xi , ta cần tìm nhãn yi = k của nó, ở đây k ∈ {1, 2, . . . , K}. Nhãn của một điểm cũng thường được biểu diễn dưới dạng một vector hàng K 25 Vonoroi diagram – Wikipedia (https://goo.gl/xReCW8). Machine Learning cơ bản 129 https://thuviensach.vn Chương 10. Phân cụm K-means phần tử yi ∈ R 1×K, trong đó tất cả các phần tử của yi bằng 0 trừ phần tử ở vị trí thứ k bằng 1. Cách biểu diễn này còn được gọi là mã hoá one-hot. Cụ thể, yij = 0, ∀j 6= k, yik = 1. Khi chồng các vector yi lên nhau, ta được một ma trận nhãn Y ∈ R N×K. Nhắc lại rằng yij là phần tử hàng thứ i, cột thứ j của ma trận Y, và cũng là phần tử thứ j của vector yi . Ví dụ, nếu một điểm dữ liệu có vector nhãn là [1, 0, 0, . . . , 0] thì nó thuộc vào cụm thứ nhất, là [0, 1, 0, . . . , 0] thì nó thuộc vào cụm thứ hai,... Điều kiện của yi có thể viết dưới dạng toán học: yij ∈ {0, 1}, ∀i, j; X K j=1 yij = 1, ∀i",
        "Summary": "\"Thuật toán K-means nhằm xác định tâm của K cụm và phân loại N điểm dữ liệu vào các cụm tương ứng. Dữ liệu đầu vào là ma trận X chứa các điểm dữ liệu và số lượng cụm K. Kết quả là các tâm cụm m1, m2, ..., mK và nhãn yi cho mỗi điểm dữ liệu xi, với yi thuộc tập {1, 2, ..., K}. Nhãn yi có thể được biểu diễn dưới dạng vector one-hot, trong đó chỉ có một phần tử bằng 1 tương ứng với cụm mà điểm dữ liệu thuộc về, còn lại bằng 0. Ma trận Y chứa tất cả các vector nhãn.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ mục tiêu của thuật toán K-means đến cách biểu diễn nhãn của các điểm dữ liệu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng hiểu được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm mục tiêu của thuật toán K-means, dữ liệu đầu vào, kết quả đầu ra và cách biểu diễn nhãn. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách rõ ràng và ngắn gọn. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00031",
        "Article": "Ứng dụng công nghệ thông tin (CNTT) không chỉ tác động mạnh mẽ đến doanh nghiệp mà còn mang lại những thay đổi sâu sắc cho xã hội. CNTT tạo ra nhiều loại hình nghề nghiệp mới, góp phần giảm tỷ lệ thất nghiệp và nâng cao cơ hội cho người tàn tật. Thời gian và không gian làm việc được mở rộng đến mức \"mọi lúc\" và \"mọi nơi\", nhờ sự hỗ trợ của các thiết bị kết nối mạng. Cuộc cách mạng robot cũng mang lại lợi ích tiềm tàng trong các môi trường độc hại, nguy hiểm. Đối với doanh nghiệp, CNTT giúp đạt được mục tiêu kinh doanh thông qua các hệ thống cung cấp thông tin hữu ích hỗ trợ quá trình ra quyết định. Sơ đồ chuỗi giá trị thông tin (Information Value Chain) cho thấy khả năng hỗ trợ của CNTT đối với tất cả các hoạt động quản lý và quản trị kinh doanh. Một hệ thống thông tin điển hình thực hiện ba hoạt động chính: thu thập, xử lý và phân phối thông tin. Thông tin được sử dụng trong lập kế hoạch, điều phối, kiểm soát, mô hình hóa và ra quyết định, cũng như quản trị \"xuyên suốt\" chuỗi cung ứng doanh nghiệp. Quan điểm truyền thống về quản lý bao gồm lập kế hoạch, tổ chức, điều khiển và kiểm soát. Mintzberg chia vai trò của người quản lý thành ba dạng: kết nối cá nhân, thông tin và quyết định. CNTT hỗ trợ các vai trò này thông qua các công cụ giao tiếp, thu thập và phân tích thông tin. Trong môi trường ứng dụng CNTT, quản lý và kinh doanh có những thay đổi đáng kể. Các lớp quản lý trung gian giảm bớt, quyết định được đưa ra nhanh chóng hơn và vai trò của cán bộ quản lý thay đổi. Internet và các mạng hỗ trợ khác giúp nhà quản lý tiếp cận thông tin nhanh chóng. CNTT cũng ảnh hưởng đến cách thức làm việc, tạo điều kiện cho làm việc từ xa và làm việc nhóm ảo. Tuy nhiên, việc triển khai ứng dụng CNTT cũng đặt ra nhiều thách thức, bao gồm lựa chọn chiến lược phù hợp, đảm bảo an toàn thông tin và đào tạo người dùng. Sự thành công của ứng dụng CNTT phụ thuộc vào sự hiểu biết về các yếu tố cấu thành hệ thống thông tin và mối liên hệ giữa chúng.",
        "Summary": "Ứng dụng CNTT tạo ra tác động lớn đến doanh nghiệp và xã hội, mở ra nhiều cơ hội nghề nghiệp và thay đổi phương thức làm việc. Đối với doanh nghiệp, CNTT hỗ trợ ra quyết định và quản trị chuỗi cung ứng thông qua các hệ thống thu thập, xử lý và phân phối thông tin. CNTT cũng thay đổi vai trò quản lý, giảm bớt lớp trung gian và tăng tốc độ ra quyết định. Tuy nhiên, triển khai CNTT đặt ra thách thức về chiến lược, an toàn thông tin và đào tạo người dùng. Thành công phụ thuộc vào sự hiểu biết về hệ thống thông tin.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ lại một cách chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được sắp xếp theo trình tự hợp lý, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ những ý chính và quan trọng nhất từ văn bản gốc được giữ lại. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Bản tóm tắt đã chọn lọc và trình bày một cách hiệu quả những thông tin quan trọng nhất từ văn bản gốc, đồng thời đảm bảo tính dễ hiểu và logic."
            }
        }
    },
    {
        "Index": "00032",
        "Article": "Tìm kiếm tài liệu trên Google có thể trở thành một kỹ năng quan trọng giúp bạn tiết kiệm thời gian và có được thông tin chính xác hơn. Để cải thiện khả năng tìm kiếm của mình, bạn có thể áp dụng một số kỹ thuật nâng cao. Một trong những cách hiệu quả là tìm kiếm cụm từ chính xác. Điều này đặc biệt hữu ích khi bạn cần tìm thông tin cụ thể và không muốn bị làm phiền bởi các kết quả không liên quan. Để thực hiện việc này, bạn chỉ cần đưa cụm từ cần tìm vào dấu nháy kép (\"\"). Ví dụ, thay vì chỉ gõ \"hướng dẫn làm seo web\", bạn hãy gõ \"hướng dẫn làm seo web\" vào hộp tìm kiếm. Cách này sẽ giúp Google trả về các kết quả có chứa cụm từ chính xác mà bạn tìm kiếm, tránh các kết quả liên quan nhưng không đúng yêu cầu. Đây là một mẹo cực kỳ hữu ích khi bạn cần tìm kiếm tài liệu chuyên sâu, báo cáo hay các bài hướng dẫn có nội dung cụ thể. Ngoài ra, bạn cũng có thể kết hợp sử dụng các bộ lọc tìm kiếm khác của Google để nâng cao kết quả tìm kiếm. Ví dụ, bạn có thể sử dụng toán tử \"site:\" để tìm tài liệu trong một trang web cụ thể, hoặc \"filetype:\" để tìm kiếm tài liệu ở định dạng nhất định như PDF, Word, PowerPoint. Những kỹ thuật tìm kiếm này không chỉ giúp bạn tiết kiệm thời gian mà còn giúp bạn tìm được tài liệu chính xác hơn, phục vụ cho công việc nghiên cứu, học tập, hay giải quyết các vấn đề trong công việc. Hãy làm quen với các phương pháp tìm kiếm nâng cao này để nâng cao hiệu quả khi sử dụng Google, từ đó tiếp cận nguồn tài liệu phong phú và đa dạng hơn",
        "Summary": "Kỹ năng tìm kiếm tài liệu trên Google có thể giúp tiết kiệm thời gian và nâng cao độ chính xác. Một trong những kỹ thuật hiệu quả là tìm kiếm cụm từ chính xác bằng cách sử dụng dấu nháy kép (\"\"). Ngoài ra, bạn cũng có thể sử dụng các bộ lọc như toán tử \"site:\" và \"filetype:\" để tìm kiếm tài liệu trong các trang web cụ thể hoặc định dạng tệp mong muốn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào kỹ năng tìm kiếm trên Google, cách sử dụng dấu nháy kép và các bộ lọc tìm kiếm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt. Tóm tắt trung thực, mạch lạc và liên quan đến nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00033",
        "Article": "2.4 Thực đơn và thanh công cụ\n Thực đơn (menu) của Microsoft Visual Studio.NET IDE ... 'biến hóa' tùy theo công việc đang làm nhưng tổng quát, thực đơn (menu) chính hiển thị bao gồm:\n  \n File:\n  \n Tiêu chuẩn chung cho mọi ứng dụng (application) trong nền Windows. File dùng để mở (open) hay đóng (close) các tập tin (files) hay dự án (project).\n Edit:\n Edit cung cấp các chọn lựa khi soạn nguồn mã và dùng các công cụ lập trình, tỷ như: Undo, Redo, Cut, Copy, Paste và Delete\n View:\n View cung cấp sư chọn lựa hiển thị các Windows tạo môi trường của IDE, tỷ như: Solution Explorer, Properties, Output, Tool Box, Server Explorer. Nếu ta để ý sẽ thấy các Windows này thường nằm 2 bên hoặc bên dưới window thiết kế Form hay soạn nguồn mã.Các windows này cũng có thể hiển lộ hay thu kín lại nhường chổ cho window thiết kế được rộng rãi.\n Project:\n Dùng để quản lý dự án (project) bằng cách thêm vào hay xóa bỏ các tập tin liên hệ. Build:\n Một lựa chọn quan trọng trong thực đơn là Build cho phép ta xây dựng và chạy ứng dụng (application) 1 cách độc lập bên ngoài IDE.\n Debug:\n Debug không những giúp phương tiện rà tìm các lỗi lập trình trong môi trường IDE mà còn giúp kiểm tra từng bước một các nguồn mã trong dự án (project).\n Data:\n Giúp ta nối và sử dụng dữ kiện hay thông tin trong Cơ Sở Dữ Liệu (Database). Tools:\n Chứa các công cụ bố trí Microsoft Visual Studio.NET IDE. Windows:\n Tiêu chuẩn chung dùng quản lý mọi windows trong IDE. Help:\n Cung cấp nối yêu cầu giúp đỡ với Microsoft Visual Studio.NET documentation hay từ mạng Internet.\n \n Cách dùng thanh công cụ sẽ được hướng dẫn tùy từng dự án (project). Tuy nhiên, 1 cách tổng quát, thanh công cụ mặc định (default) bao gồm như sau (theo thứ tự từ trái qua phải):\n • New Project\n • Add Item\n • Open File\n • Save (lưu trữ form hay module đang dùng)\n • Save All (lưu trữ mọi forms, modules, ... đang dùng hay đang mở)\n • Cut\n • Copy\n • Paste (sẽ hiển lộ sau khi ta nhấp nút Cut hay Copy)\n • Undo\n • Redo\n • Navigate Backward (lướt lui)\n  \n • Navigate Forwards (lướt tới)\n • Nút Start để chạy thử ứng dụng trong IDE\n • Build Configuration (bố trí xây dựng ứng dụng) trong IDE. Ở đây, cho ta biết bố trí hiện dùng là Debug\n • Truy tìm tập tin (Find in files)\n và cuối cùng, nút Toolbar Options để hiển thị thêm các công cụ phụ thuộc khác.\n Nhấp đơn hộp công cụ nằm phía bên tay trái window thiết kế như hình sau. Hộp công cụ bao gồm:\n • Hộp Data\n • Hộp Components\n • Hộp Windows Forms\n • Hộp Clipboard Ring\n • Hộp Gerneral\n Hình 2.17: Màn hình soạn thảo\n Bài kế tiếp, ta sẽ bắt đầu soạn dự án (project) đâu tiên với Microsoft Visual Studio.NET",
        "Summary": "Trong Microsoft Visual Studio .NET IDE, thực đơn chính (menu) cung cấp các chức năng File (mở/đóng tập tin/dự án), Edit (soạn mã nguồn), View (hiển thị các cửa sổ như Solution Explorer, Properties), Project (quản lý dự án), Build (xây dựng ứng dụng), Debug (rà soát lỗi), Data (kết nối CSDL), Tools (bố trí IDE), Windows (quản lý cửa sổ) và Help (trợ giúp). Thanh công cụ mặc định bao gồm các nút New Project, Add Item, Open File, Save, Save All, Cut, Copy, Paste, Undo, Redo, Navigate Backward/Forward, Start, Build Configuration, Find in Files và Toolbar Options. Hộp công cụ bên trái window thiết kế chứa các hộp Data, Components, Windows Forms, Clipboard Ring và General.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, giúp người đọc dễ dàng nắm bắt thông tin. Các chức năng của menu, các nút trên thanh công cụ và các hộp công cụ được liệt kê một cách có hệ thống."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ những ý chính và quan trọng từ văn bản gốc được giữ lại, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các chức năng chính của thực đơn, thanh công cụ và hộp công cụ trong Microsoft Visual Studio .NET IDE."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00034",
        "Article": "Thông qua truy cập thông tin sinh hoạt hàng ngày của một ngƣời, phân tích giấc ngủ và xem xét thói quen các buổi sáng trƣớc đó, công nghệ TTNT có thể cho biết thời điểm nào thích hợp để robot chuẩn bị bữa sáng. TTNT và robot đƣợc kết hợp mạnh mẽ nhằm tự động hóa các tác vụ bên trong và bên ngoài cơ sở sản xuất. Những năm gần đây, TTNT ngày càng hiện diện phổ biến thông qua cac robot, có tính linh hoạt và khả năng học các trải nghiệm, vốn không có trong các ứng dụng trƣớc đây. TTNT trong robot thể hiện dƣới dạng các khả năng trí tuệ nhƣ: suy nghĩ, lập luận, lập kế hoạch, học tập và thích nghi. Robot thông minh thông qua chƣơng trình phần mềm mô phỏng hoạt động tƣ duy hoặc suy luận. Ngoài ra, robot trí tuệ nhân tạo còn có hai đặc điểm quan trọng. Đó là robot có khả năng học để thích nghi với môi trƣờng xung quanh, có thể thay đổi hành vi dần theo thời gian. Đặc điểm thứ hai là hành vi phát sinh, thực hiện các hành động không đƣợc lập trình sẵn một cách tƣờng minh theo chủ ý của ngƣời thiết kế. e) Phương tiện tự hành Những năm gần đây, nhờ sự tiến bộ của trí tuệ nhân tạo đã có nhiều cải thiện đáng kể khả năng thông minh của các phƣơng tiện tự hành trong nhiều mặt hoạt động sản xuất và đời sống [40]. Nhiều chính phủ và nhiều công ty công nghệ lớn nhƣ Google, Baidu, Apple, Tesla, v.v cũng đang đầu tƣ rất mạnh vào lĩnh vực này. Khả năng tự hành của phƣơng tiện đƣợc chia theo 5 cấp độ, đƣợc diễn giải nhƣ sau: Cấp độ một và cấp độ hai - Hỗ trợ người lái: Ở cấp độ này, phƣơng tiện chỉ cung cấp các phần mềm ứng dụng nhƣ cảnh báo điểm mù, cảnh báo không khởi hành và cải tiến một số thiết bị trong hệ thống xe, giúp nâng cao mức độ an toàn, giảm thiểu lỗi liên quan đến sức khỏe và tính mạng con ngƣời. Một số loại xe đã tích hợp khả năng xử lý tự động giảm tốc, can thiệp điểu chỉnh chuyển động ngang trong các tình huống nguy hiểm. Nhƣng vai trò chính vẫn phụ thuộc hoàn toàn vào ngƣời lái.",
        "Summary": "Robot thông minh thông qua chƣơng trình phần mềm mô phỏng hoạt động tƣ duy hoặc suy luận. Khả năng tự hành của phƣơng tiện đƣợc chia theo 5 cấp độ, đƣợc diễn giải nhƣ sau Cấp độ một và cấp độ hai - Hỗ trợ người lái Ở cấp độ này, phƣơng tiện chỉ cung cấp các phần mềm ứng dụng nhƣ cảnh báo điểm mù, cảnh báo không khởi hành và cải tiến một số thiết bị trong hệ thống xe, giúp nâng cao mức độ an toàn, giảm thiểu lỗi liên quan đến sức khỏe và tính mạng con ngƣời.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được trích dẫn từ văn bản gốc và ghép lại với nhau. Tuy nhiên, vì là trích dẫn nên sự liên kết giữa các ý có thể chưa được mượt mà như khi viết lại hoàn toàn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào robot thông minh và phương tiện tự hành. Tuy nhiên, việc chỉ trích dẫn một vài câu có thể khiến người đọc khó nắm bắt được toàn bộ ý chính nếu không đọc văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá. Điểm mạnh là tính trung thực cao, không thêm thông tin sai lệch. Tuy nhiên, để cải thiện, nên viết lại các ý chính bằng ngôn ngữ của người tóm tắt thay vì chỉ trích dẫn, để đảm bảo tính mạch lạc và liên kết giữa các ý, đồng thời làm nổi bật các ý quan trọng hơn."
            }
        }
    },
    {
        "Index": "00035",
        "Article": "Định danh của luồng (ThreadId): ThreadId là định danh của luồng, được dùng để phân biệt với các luồng khác cùng tiến trình hoặc cùng tập luồng. Đây là thông số mà máy ảo Java tự tạo ra khi ta tạo luồng nên ta không thể sửa đổi cũng 44 như áp đặt thông số này khi tạo luồng. Nhưng ta có thể lấy được ThreadId thông qua phương thức getId() của lớp Thread. Tên của luồng (ThreadName): ThreadName là tên của luồng, đây là thuộc tính mà ta có thể đặt hoặc không đặt cho luồng. Nếu ta không đặt cho luồng thì máy ảo Java sẽ tự đặt với quy tắc sau: “Thread-” + Thứ tự luồng được tạo ra, bắt đầu từ 0. Độ ưu tiên của luồng (Priority): Như đã nói ở phần trước, mỗi luồng có 1 độ ưu tiên nhất định. Đây sẽ là thông số quyết định mức ưu tiên khi cấp phát CPU cho các luồng. Trong Java, đế đặt độ ưu tiên cho 1 luồng ta dùng phương thức: void setPriority(int newPriority) • int newPriority: Mức độ ưu tiên từ 1 đến 10. Java có định nghĩa sẵn 3 mức ưu tiên chuẩn như sau: • Thread.MIN_PRIORITY (giá trị 01) • Thread.NORM_PRIORITY (giá trị 05) • Thread.MAX_PRIORITY (giá trị 10) Để lấy độ ưu tiên của 1 luồng, ta dùng phương thức: int getPriority(). Ví dụ 3-3. Chương trình xác định mức độ ưu tiên của luồng. WorkingThread.java package vn.tbit.info; public class WorkingThread extends Thread à public WorkingThread(String name) à super(name); â public void run() à for (int i = 0; i &lt; 5; i++) à System.out.printf(\"Luồng: %s có độ ưu tiên là %d \\n\", getName(), getPriority()); â â â ThreadInfoExample.java package vn.tbit.info; public class ThreadInfoExample à public static void main(String[] args) à 45 Thread t1 = new WorkingThread(\"Luồng 1\"); Thread t2 = new WorkingThread(\"Luồng 2\"); Thread t3 = new WorkingThread(\"Luồng 3\"); System.out.println(\"ID luồng 1: \" + t1.getId()); System.out.println(\"ID luồng 2: \" + t2.getId()); System.out.println(\"ID luồng 3: \" + t3.getId()); t1.setPriority(1); t2.setPriority(5); t3.setPriority(10); t1.start(); t2.start(); t3.start(); â â Kết quả thực thi chương trình trên: ID luồng 1: 10 ID luồng 2: 11 ID luồng 3: 12 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 1 có độ ưu tiên là 1",
        "Summary": "Văn bản mô tả các thuộc tính của luồng (thread) trong Java, bao gồm ThreadId (định danh tự động tạo bởi máy ảo Java), ThreadName (tên luồng có thể đặt hoặc tự động đặt theo quy tắc \"Thread-\" + thứ tự), và Priority (độ ưu tiên, có thể đặt bằng `setPriority()` với giá trị từ 1 đến 10, hoặc sử dụng các hằng số `MIN_PRIORITY`, `NORM_PRIORITY`, `MAX_PRIORITY`). Ví dụ minh họa cho thấy cách lấy ThreadId bằng `getId()` và đặt/lấy độ ưu tiên luồng, ảnh hưởng đến thứ tự thực thi. Kết quả cho thấy luồng có độ ưu tiên cao hơn được ưu tiên thực thi trước.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Các khái niệm như ThreadId, ThreadName, Priority, các phương thức getId(), setPriority(), và các hằng số MIN_PRIORITY, NORM_PRIORITY, MAX_PRIORITY đều được mô tả chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic. Cách sắp xếp thông tin theo thứ tự ThreadId, ThreadName, và Priority giúp người đọc dễ dàng nắm bắt các thuộc tính của luồng trong Java. Việc đề cập đến các phương thức và hằng số liên quan cũng được tích hợp một cách tự nhiên vào nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, đó là các thuộc tính quan trọng của luồng trong Java. Các chi tiết không cần thiết như code ví dụ đầy đủ đã được lược bỏ, chỉ giữ lại những phần quan trọng nhất để minh họa cho các khái niệm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được các thông tin quan trọng nhất từ văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00036",
        "Article": "Khuôn khổ chính sách cũng có xu hướng tập trung hơn và kiểm soát đối với các công nghệ. Những quy định thực tế như vậy dễ xảy ra xung đột với tiềm năng của công nghệ thông tin truyền thông. Công nghệ không chỉ đơn thuần là phần cứng mà là sự thành lập một bộ phận quản lý và thực tiễn hoạt động. Vì vậy, chính sách quản sử dụng của họ cần duy trì mở, linh hoạt, sáng tạo và có khả năng đáp ứng. Đánh giá thường xuyên là cần thiết để đảm bảo rằng các nhu cầu đặc biệt của các dự án dựa trên công nghệ thông tin truyền thông và các chương trình được thực hiện. Module 2 lập luận cho các loại hình gắn kết trong hình thành chính sách công nghệ thông tin truyền thông phục vụ cho phát triển và thực hành. Các sáng kiến thiết kế và thực hiện bởi các chính phủ thông thường như một phần của một chương trình nghị sự phát triển rộng rãi có xu hướng phản ánh sự quá lệ thuộc vào quy ước của các tổ chức hiện có: họ kết hợp các hệ thống thứ bậc và quan liêu của trong quản lí. Nhưng các mô hình quản lý dự án hoặc các sáng kiến được tập trung triển khai thực hiện không đầy đủ thì địa phương lại có nhu cầu xem xét. Sự phát triển của các giải pháp ở địa phương là cần thiết. Môđun 3 bàn về các thiết kế và phát triển dụng công nghệ thông tin truyền thông liên quan đến cả chính phủ và các công dân. Phương pháp thông thường để quản lý dự án sử dụng công nghệ thông tin truyền thông thường giả định rằng cơ sở hạ tầng là cần thiết đầu tiên và do đó, đầu tư phần cứng, các tòa nhà, thiết bị và thuê nhân viên, được ưu tiên. Phần lớn đầu tư 98 nói chung đi vào các chi phí trên kia và vài nguồn lực được để lại cho các hoạt động của dự án. Sự đầu tư song song vào con người, trong nghiên cứu chất lượng của xã hội, quản lý dự án và huy động cộng đồng và sự tham gia, hiếm khi diễn ra.",
        "Summary": "Những quy định thực tế như vậy dễ xảy ra xung đột với tiềm năng của công nghệ thông tin truyền thông. Nhưng các mô hình quản lý dự án hoặc các sáng kiến được tập trung triển khai thực hiện không đầy đủ thì địa phương lại có nhu cầu xem xét. Phương pháp thông thường để quản lý dự án sử dụng công nghệ thông tin truyền thông thường giả định rằng cơ sở hạ tầng là cần thiết đầu tiên và do đó, đầu tư phần cứng, các tòa nhà, thiết bị và thuê nhân viên, được ưu tiên. Sự đầu tư song song vào con người, trong nghiên cứu chất lượng của xã hội, quản lý dự án và huy động cộng đồng và sự tham gia, hiếm khi diễn ra.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả các câu đều được trích dẫn trực tiếp từ văn bản gốc mà không có bất kỳ sự thay đổi hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, tuy nhiên, vì các câu được trích dẫn từ các phần khác nhau của văn bản gốc nên sự liên kết giữa chúng không được tự nhiên và rõ ràng. Cần có sự chỉnh sửa để các ý tưởng được kết nối tốt hơn."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số chi tiết liên quan đến chủ đề chính, nhưng việc lựa chọn các câu có vẻ ngẫu nhiên và không tập trung vào các ý chính của văn bản gốc. Ví dụ, việc tập trung vào đầu tư cơ sở hạ tầng mà không đề cập đến các khía cạnh khác có thể làm mất đi sự cân bằng trong thông tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có độ trung thực cao, nhưng tính mạch lạc và liên quan còn yếu. Để cải thiện, cần chọn lọc các ý chính một cách cẩn thận hơn và sắp xếp chúng một cách logic để tạo ra một bản tóm tắt dễ hiểu và phản ánh đúng nội dung của văn bản gốc. Cần tập trung vào việc làm nổi bật các luận điểm quan trọng và loại bỏ các chi tiết không cần thiết."
            }
        }
    },
    {
        "Index": "00037",
        "Article": "Trong phần này, chúng ta sẽ làm quen với một thuật toán xây dựng cây quyết định ra đời từ rất sớm. ID3 (Iterative Dichotomiser 3) do Ross Quinlan đề xuất năm 1986, là một thuật toán xây dựng/học cây quyết định được áp dụng cho các bài toán phân loại mà tất cả các thuộc tính đều có kiểu định danh/phạm trù. Trong ID3, chúng ta cần xác định thứ tự của thuộc tính cần được xem xét tại mỗi bước. Với các bài toán có nhiều thuộc tính và mỗi thuộc tính có nhiều giá trị khác nhau, việc tìm được cây tối ưu thường là không khả thi. Thay vào đó, một phương pháp đơn giản thường được sử dụng là tại mỗi bước, một thuộc tính tốt nhất sẽ được chọn ra dựa trên một tiêu chuẩn nào đó. Việc chọn ra thuộc tính tốt nhất ở mỗi bước như thế này được gọi là cách chọn tham lam (greedy). Cách chọn này có thể không phải là tối ưu, nhưng trực giác cho chúng ta thấy rằng cách làm này sẽ gần với cách làm tối ưu. Ngoài ra, cách làm này khiến cho bài toán cần giải quyết trở nên đơn giản hơn. ID3 thực hiện tìm kiếm tham lam trên không gian các cây quyết định để xây dựng một cây quyết định theo chiến lược top-down, bắt đầu từ nút gốc. Cụ thể: • Ởmỗi nút, chọn thuộc tính kiểm tra tốt nhất- là thuộc tính có khả năng phân loại tốt nhất đối với các mẫu học gắn với nút đó. • Tạo mới một cây con của nút hiện tại cho mỗi giá trị có thể của thuộc tính kiểm tra, và tập học sẽ được tách ra thành các tập con tương ứng với cây con vừa tạo. Quá trình phát triển cây quyết định sẽ tiếp tục cho đến khi: • Cây quyết định phân loại hoàn toàn các mẫu học, hoặc • Tất cả các thuộc tính đã được sử dụng Trong quá trình xây dựng một cây quyết định, với mỗi thuộc tính được chọn, ta chia dữ liệu tại nút đang xét vào các nút con tương ứng với tất cả các giá trị có thể của thuộc tính đó rồi tiếp tục áp dụng phương pháp này cho mỗi nút con. Do vậy, mỗi thuộc tính chỉ được phép xuất hiện tối đa 1 lần đối với bất kỳ một đường đi nào trong cây.",
        "Summary": "Thuật toán ID3 (Iterative Dichotomiser 3) là một thuật toán xây dựng cây quyết định cho bài toán phân loại với thuộc tính định danh. ID3 sử dụng phương pháp tìm kiếm tham lam để chọn thuộc tính tốt nhất tại mỗi nút dựa trên tiêu chuẩn phân loại, từ đó xây dựng cây quyết định theo chiến lược top-down. Quá trình này tiếp tục cho đến khi cây phân loại hoàn toàn các mẫu học hoặc tất cả thuộc tính đã được sử dụng, đảm bảo mỗi thuộc tính chỉ xuất hiện tối đa một lần trên mỗi đường đi trong cây.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tính súc tích và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt đầy đủ, chính xác các ý chính của văn bản gốc, đồng thời đảm bảo tính mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00038",
        "Article": "a. IPTV phân phối trên mạng truy cập cáp quang\n Đối với IPTV thì yêu cầu về băng thông lớn nhưng chi phí hoạt động phải thấp và\n tránh được các can nhiễu. Do đó, người ta quan tâm tới việc sử dụng mạng cáp quang\n đang có sẵn để triển khai các dịch vụ IPTV. Các liên kết cáp quang cung cấp cho khách\n hàng đầu cuối một kết nối chuyên dụng tốt nhất để thuận tiện cho việc tiếp nhận nội\n dung IPTV. Có thể thực thi một trong các cấu trúc mạng sau:\n · Cáp quang tới khu vực văn phòng (FTTRO – Fiber to the regional office): Sợi\n quang từ trung tâm dữ liệu IPTV tới khu vực văn phòng một cách gần nhất được lắp\n đặt bởi các công ty viễn thông hoặc công ty cáp. Sau đó sợi cáp đồng sẽ được sử\n dụng để truyền tín hiệu tới người dùng đầu cuối IPTV trong khu vực văn phòng đó.\n · Cáp quang tới vùng lân cận (FTTN – Fiber to the neighborhood): FTTN đòi hỏi\n thiết lập sợi quang từ trung tâm dữ liệu IPTV tới bộ chia “vùng lân cận”. Đây là vị trí\n node có khoảng cách nhỏ hơn 1,5 Km tính từ nhà thuê bao. Việc triển khai FTTN\n cho phép người dùng nhận một gói các dịch vụ trả tiền bao gồm truyền hình IPTV,\n truyền hình chất lượng cao và video theo yêu cầu.\n · Cáp quang tới lề đường (FTTC – Fiber to the curd ): sợi quang được lắp đặt từ\n trung tâm dữ liệu IPTV tới các tủ cáp được đặt tại lề đường. Từ đó một sợi dây cáp\n đồng hoặc cáp đồng trục được sử dụng để nối từ đầu cuối cáp quang trong tủ cáp tới\n vị trí thiết bị IPTV của nhà thuê bao.\n · Cáp quang tới nhà khách hàng (FTTH – Fiber to the home): với sợi quang tới nhà\n khách hàng, toàn bộ các định tuyến từ trung tâm dữ liệu IPTV tới nhà khách hàng\n đều được kết nối bởi sợi quang này. FTTH dựa trên mạng quang có khả năng phân\n phối dung lượng dữ liệu cao tới người sử dụng trong hệ thống. FTTH là hệ thống\n thông tin song kênh và hỗ trợ tính năng tương tác của các dịch vụ IPTV.\n Việc phân phối những cấu trúc mạng này thường được triển khai bằng hai loại mạng\n khác nhau một chút đó là mạng quang thụ động và mạng quang tích cực:",
        "Summary": "\"IPTV đòi hỏi băng thông lớn và chi phí thấp, do đó việc sử dụng mạng cáp quang được quan tâm. Các cấu trúc mạng cáp quang phổ biến bao gồm: FTTRO (cáp quang đến khu vực văn phòng, sau đó dùng cáp đồng), FTTN (cáp quang đến bộ chia vùng lân cận), FTTC (cáp quang đến tủ cáp ở lề đường, sau đó dùng cáp đồng/đồng trục), và FTTH (cáp quang trực tiếp đến nhà khách hàng, cung cấp băng thông cao và tính năng tương tác). Các cấu trúc này thường được triển khai bằng mạng quang thụ động hoặc mạng quang tích cực.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào yêu cầu băng thông của IPTV, các cấu trúc mạng cáp quang phổ biến và phương pháp triển khai, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00039",
        "Article": "Có rất nhiều ứng dụng thực tế khác nhau của học máy. Hai lĩnh vực ứng dụng lớn nhất của học máy là khai phá dữ liệu (data mining) và nhận dạng mẫu (pattern recognition). Khai phá dữ liệu là ứng dụng kỹ thuật học máy vào các cơ sở dữ liệu hoặc các tập dữ liệu lớn để phát hiện quy luật hay tri thức trong dữ liệu đó hoặc để dự đoán các thông tin quan tâm trong tương lai. Ví dụ, từ tập hợp hóa đơn bán hàng có thể phát hiện ra quy luật “những người mua bánh mì thường mua bơ”. Nhận dạng mẫu là ứng dụng các kỹ thuật học máy để phát hiện các mẫu có tính quy luật trong dữ liệu, thường là dữ liệu hình ảnh, âm thanh. Bài toán nhận dạng mẫu cụ thể thường là xác định nhãn cho đầu vào cụ thể, ví dụ cho ảnh chụp mặt người, cần xác định đó là ai. Cần lưu ý, khai phá dữ liệu và nhận dạng mẫu có nhiều điểm trùng nhau cả trong phạm vi nghiên cứu và ứng dụng. Điểm khác nhau chủ yếu liên quan tới lĩnh vực ứng dụng và kỹ thuật sử dụng, theo đó khai phá dữ liệu liên quan tới dữ liệu thương mại trong khi nhận dạng mẫu liên quan nhiều tới dữ liệu âm thanh, hình ảnh và được dùng nhiều trong kỹ thuật. Ứng dụng cụ thể Sau đây là một số ví dụ ứng dụng cụ thể của học máy: - Nhận dạng ký tự: phân loại hình chụp ký tự thành các loại, mỗi loại ứng với một ký tự tương ứng. Phát hiện và nhận dạng mặt người: phát hiện vùng có chứa mặt người trong ảnh, xác định đó là mặt người nào trong số những người đã có ảnh trước đó, tức là phân chia ảnh thành những loại tương ứng với những người khác nhau. Lọc thư rác, phân loại văn bản: dựa trên nội dung thư điện tử, chia thư thành loại “thư rác” hay “thư bình thường”; hoặc phân chia tin tức thành các thể loại khác nhau như “xã hội”, “kinh tế”, “thể thao”.v.v. Dịch tự động: dựa trên dữ liệu huấn luyện dưới dạng các văn bản song ngữ, hệ thống dịch tự động học cách dịch từ ngôn ngữ này sang ngôn ngữ khác. Hệ thống dịch tự động tiêu biểu dạng này là Google Translate. Chẩn đoán y tế: học cách dự đoán người bệnh có mắc hay không mắc một số bệnh nào đó dựa trên triệu chứng quan sát được. Phân loại khách hàng và dự đoán sở thích: sắp xếp khách hàng vào một số loại, từ đây dự đoán sở thích tiêu dùng của khách hàng. Dự đoán chỉ số thí trường: căn cứ giá trị một số tham số hiện thời và trong lịch sử, đưa ra dự đoán, chẳng hạn dự đoán giá chứng khoán, giá vàng.v.v. Các hệ khuyến nghị, hay hệ tư vấn lựa chọn: cung cấp một danh sách ngắn các loại hàng hóa, phim, video, tin tức v.v. mà người dùng nhiều khả năng quan tâm. Ví dụ ứng dụng loại này là phần khuyến nghị trên Youtube hay trên trang mua bán trực tuyến Amazon. Ứng dụng lái xe tự động: dựa trên các mẫu học chứa thông tin về các tình huống trên đường, hệ thống học máy cho phép tự ra quyết định điều khiển xe, và do vậy không cần người lái. Hiện Google đã có kế hoạch thương mại hóa xe ôtô tự động lái như vậy.",
        "Summary": "Học máy có nhiều ứng dụng thực tế, trong đó lớn nhất là khai phá dữ liệu (phát hiện quy luật trong dữ liệu lớn) và nhận dạng mẫu (phát hiện mẫu trong dữ liệu hình ảnh, âm thanh). Các ứng dụng cụ thể bao gồm nhận dạng ký tự, phát hiện và nhận dạng khuôn mặt, lọc thư rác, dịch tự động, chẩn đoán y tế, phân loại khách hàng, dự đoán chỉ số thị trường, hệ thống khuyến nghị và lái xe tự động.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các ứng dụng lớn của học máy và các ví dụ cụ thể, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về các ứng dụng của học máy một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00040",
        "Article": "Những cơ hội marketing nhờ sự hội tụ của các phương tiện công nghệ là rất lớn. Ba sự hội tụ phương tiện trên Internet đáng chú ý nhất hiện nay gồm: Tiếng nói & hình ảnh và dữ liệu. Hình thức đầu tiên của sự hội tụ là hội tụ tiếng nói, hình ảnh, và dữ liệu trên Internet. Nó cho phép các DN chỉ cần sử dụng một ứng dụng chung cho việc truyền thông giọng nói, hình ảnh và dữ liệu thay vì sử dụng 3 hệ thống riêng biệt. Cisco đang đi đầu về phát triển cho thị trường này, hỗ trợ cả về cơ sở hạ tầng lẫn sự áp dụng của người sử dụng cuối cùng như điện thoại IP. Các thiết bị không dây và website. Sự hội tụ thứ hai của phương tiện truyền thông là sự hội tụ của những thiết bị không dây - điện thoại di động và những thiết bị kỹ thuật số trợ giúp cá nhân (PDAs) - với truy cập website và thỉnh thoảng còn bao gồm cả chức năng định vị toàn cầu (GPS). Sự giới hạn chính đối với trình duyệt web là kích cỡ màn hình của PDAs và điện thoại di động là có màn hình nhỏ hơn. Từ màn hình điện thoại di động nhỏ xíu có thể sử dụng để kiểm tra thư điện tử và thời tiết, tin tức và chỉ số chứng khoán,... Tuy nhiên, nội dung web chủ đạo là thiết kế màu sắc trên những hiển thị rộng. Dù sao, nhiều websites đang bắt đầu tạo nội dung cho giao thức truy cập không dây (WAP) đến khi nó hiển thị một cách phù hợp trên những màn hình nhỏ xíu. Sự giới hạn thứ hai của trình duyệt web trên các thiết bị không dây là tốc độ đường truyền. Mạng không dây trong vài trường hợp ngoại lệ, chậm hơn những mạng có dây dẫn. Mặc dù với những hạn chế, thị trường này vẫn đang phát triển một cách nhanh chóng. Một công nghệ được chú ý tới là các mạng Wi-Fi được xây dựng trên tiêu chuẩn Ethernet 802.11b. Ngoài ra, một công nghệ phổ biến hiện nay là mạng điện thoại di động 3G. Phát thanh truyền hình và Internet. Dạng hội tụ thứ ba là giữa phương tiện thông tin phát sóng rộng (vô tuyến truyền hình và máy thu thanh), và Internet, đôi lúc được gọi là ITV. Sự hội tụ này sẽ giúp cho việc nhận được nội dung của phát thanh, truyền hình thông qua Internet. Trở ngại lớn là thiếu băng thông lớn để có thể truyền tải trơn tru toàn bộ đoạn video. Tuy nhiên, bộ điều giải cáp, bộ điều giải DSL, và sự truy cập không dây cố định có thể cung cấp độ dài dải tần lớn hơn để vượt qua được những trở ngại này. Dạng hội tụ ban đầu của Web/TV là của MSN TV và Enhanced TV. Với dạng thứ nhất, những người sử dụng MSN TV có thể đọc các trang web trên màn hình TV. Tuy nhiên mô hình này không thành công lắm do tính năng hạn chế của màn hình TV và trên thực tế mà những người tiêu dùng không có thói quen đọc trên màn hình TV. Dạng thứ hai, ABC’s Enhanced TV yêu cầu những người sử dụng phải đăng nhập vào website của ABC trong khi họ đang xem một chương trình TV. Những người sử dụng có thể tìm được nhiều thông tin hơn về phát thanh truyền hình, chơi trò chơi với những người sử dụng khác, và đặc biệt trong việc thăm dò ý kiến và nói chuyện. Thật thú vị, khi xúc tiến triển lãm trên Enhanced TV, “Ai muốn trở thành triệu phú”, 97% những người sử dụng đăng nhập Enhanced TV nói họ muốn quay trở lại.",
        "Summary": "\"Sự hội tụ của các phương tiện công nghệ (tiếng nói, hình ảnh, dữ liệu, thiết bị không dây, phát thanh truyền hình và Internet) mang lại nhiều cơ hội marketing. Ba hình thức hội tụ đáng chú ý nhất là: (1) Hội tụ tiếng nói, hình ảnh và dữ liệu trên Internet, cho phép truyền thông đa phương tiện qua một ứng dụng duy nhất. (2) Hội tụ thiết bị không dây (điện thoại di động, PDA) với truy cập web, dù còn hạn chế về kích thước màn hình và tốc độ đường truyền. (3) Hội tụ phát thanh truyền hình và Internet (ITV), cho phép tiếp nhận nội dung phát sóng qua Internet, với thách thức về băng thông. Các mô hình ban đầu như MSN TV chưa thành công do hạn chế về trải nghiệm người dùng, trong khi Enhanced TV của ABC cho thấy tiềm năng tương tác cao.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ nguyên và trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách trôi chảy, tạo thành một đoạn văn thống nhất."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào ba hình thức hội tụ phương tiện và những đặc điểm, thách thức của chúng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00041",
        "Article": "Trong mạch cải tiến 2.2.18b, mạch tính cực T6, Rb, Rc thay thế R3 trong mạch 2.2.18a.\n Mạch cải tiến là mạch nguồn điều khiển hình thành mạch phóng điện cho bazơ T5.\n • Cải tiến đặc tính truyền đạt điện áp\n Vì emitơ T2 chỉ có thể thông qua mạch emitơ T5, T6 nên trước khi T5, T6 thông thì mạch cải tiến chẳng khác gì mạch gốc và không còn giai đoạn T2 thông mà T5 vẫn chưa thông. Trong mạch gốc, giai đoạn T2 thông mà T5 chưa thông tương ứng phần tuyến tính trên đặc tuyến truyển đạt điện áp. Hình 2.2.19 là đặc tính truyên đạt của mạch 2.2.18b, không có phần tuyến tính nữa.\n Từ hình 2.2.19, ta nhận thấy múc tạp âm cho phép khi đầu vào mức thấp của mạch cải tiến lớn hơn mạch gốc rõ rệt, VNL = 1V.\n • Cải tiến thời gian truyền đạt.\n Khi VI đột biến từ mức thấp đến xấp xỉ 1,4V thì cả T5, T6 đều bắt đầu thông. Ở thời điểm bắt đầu thông, hầu như toàn bộ dòng emitơ T2 chảy đến bazơ T5, cung cấp cho T5 xung dòng rất lớn (vượt quá giá trị cần để T5 thông bão hòa), vì vậy giảm nhỏ thời gian trễ thông mạch của T5. Có thể đạt được điểu đó là vì nối tiếp bazơ của T6, sự nạp điện điện dung chuyển tiếp emitơ T6 chậm hơn sự nạp điện điện dung chuyển tiếp emitơ T5. Kết quả T6 thông chậm hơn T5 một chút. Còn sau khi T6 đã thông thì mạch T6 phân dòng cho bazơ T5, giảm nhỏ dòng bazơ ở trạng thái ổn định, giảm bớt độ hão hòa của T5, có lợi cho sự tăng tốc quá trình ngắt mạch của T5.\n Sau khi điện áp đầu vào có đột biến âm, T2 ngắt đấu tiên. Tiếp đó, điện tích tồn trữ của T5 sẽ được phóng qua mạch T6. Lúc này T6 vẫn thông bão hòa, biểu thị một điện trở nhỏ của mạch phóng điện. Kết quả, T5 nhanh chóng rời vùng bão hòa và ngắt hở mạch.\n Vậy mạch tích cực T6, Rb, Rc thay thế R3 đem lại sự cải tiến: rút ngắn thời gian tồn trữ động, rút ngắn thời gian trễ thông, dẫn đến rút ngắn rõ rệt thời gian truyền đạt trung bình.\n Hiện nay mạch điện hình 2.2.18.b là cổng NAND TTL được dùng rộng.",
        "Summary": "\"Mạch cải tiến 2.2.18b sử dụng mạch tích cực T6, Rb, Rc thay thế R3 trong mạch 2.2.18a để điều khiển mạch phóng điện cho bazơ T5, cải thiện đặc tính truyền đạt điện áp và thời gian truyền đạt. Mạch cải tiến loại bỏ phần tuyến tính trên đặc tuyến truyền đạt điện áp, tăng mức tạp âm cho phép. Khi T5, T6 bắt đầu thông, T5 nhận xung dòng lớn giúp giảm thời gian trễ thông mạch. Sau khi T6 thông, nó phân dòng cho bazơ T5, giảm độ bão hòa và tăng tốc quá trình ngắt mạch của T5. Nhờ đó, mạch cải tiến rút ngắn thời gian tồn trữ động, thời gian trễ thông, và thời gian truyền đạt trung bình. Mạch điện cải tiến này (hình 2.2.18.b) là cổng NAND TTL được sử dụng rộng rãi.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và theo một trình tự hợp lý."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào mục đích cải tiến của mạch và kết quả đạt được."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00042",
        "Article": "Quá trình quản trị marketing TMĐT về cơ bản bao gồm 6 bước cụ thể: Bước 1: Phân tích tình thế chiến lược marketing TMĐT. Hoạch định chiến lược marketing TMĐT không có nghĩa là bắt đầu từ vạch xuất phát. Việc khởi đầu từ chính những mô hình kinh doanh hiện tại và từ kế hoạch marketing truyền thống là điểm hợp lý nhất để bắt đầu. Vận dụng ma trận TOWS, xem xét lại kế hoạch marketing hiện tại và xem xét lại các mục tiêu đề ra trong hoạt động kinh doanh ứng dụng TMĐT của DN, xem xét lại các chiến lược và phương thức tổ chức thực thi hiện tại chính là nội dung chính của bước này. Ví dụ: Phân tích TOWS tình thế chiến lược marketing TMĐT của một DN. Thời cơ: Thị trường dành cho giới trẻ ngày càng được mở rộng, chi phí gửi thư qua bưu điện giảm nhờ marketing qua email. Đe dọa: Luật an toàn mạng sắp ra đời có nghĩa chi phí để nâng cấp phần mềm tăng lên, đối thủ cạnh tranh X của DN ngày càng mạnh. Điểm mạnh: Dịch vụ khách hàng tốt, hệ thống cơ sở dữ liệu và website tốt. Điểm yếu: Văn hóa hợp tác kỹ thuật trong DN kém, nguồn vốn hạn hẹp. Mục tiêu ứng dụng TMĐT trong kinh doanh của DN: Bắt đầu áp dụng TMĐT thành công ngay trong năm thứ hai. Mục tiêu hoạt động: Đạt doanh thu 10 tỷ VNĐ từ TMĐT trong năm thứ nhất. Bước 2: Gắn kết mô hình ứng dụng TMĐT và thiết lập các mục tiêu chiến lược marketing TMĐT. Jeff Bezos - người sáng lập và đồng thời là chủ tịch của Amazon.com, một trong những DN kinh doanh qua mạng hàng đầu thế giới với doanh số năm 2005 khoảng 7 tỷ USD, đã phát biểu rằng: “Mọi DN đều phải chú trọng tới khách hàng, hướng tới nhu cầu của khách hàng trước khi đề cập tới sản phẩm của mình, cho dù trong thời đại CNTT hay các thời đại khác.” Trong mục trên đã giới thiệu các mô hình ứng dụng TMĐT phổ biến, ứng với mỗi mô hình là một cấu trúc tương ứng các dịch vụ TMĐT cho một loại hoặc đoạn thị trường khách hàng điện tử mục tiêu, đòi hỏi một kết cấu hạ tầng CNTT-TT tương hợp và có ảnh hưởng, làm điều kiện cho các dự báo và thiết lập mục tiêu marketing TMĐT trong dài hạn. Đối với DN, mục tiêu của marketing TMĐT không khác với marketing truyền thống, đều là doanh số, lợi nhuận, thị phần,... Điều này cho thấy, trong thời đại CNTT và Internet hiện nay, marketing TMĐT hay truyền thống đều hướng tới cùng một đối tượng, đó là khách hàng. Tuy nhiên, mục tiêu marketing TMĐT phải đảm bảo: đưa ra được nhiệm vụ cụ thể, đo được về số lượng, và có giới hạn thời gian nhất định. Trên thực tế, phần lớn kế hoạch marketing TMĐT hướng tới hoàn thiện nhiều mục tiêu, ví dụ như: tăng thị phần, tăng doanh thu, giảm chi phí, đạt được mục tiêu nhãn hiệu (tăng sự hiểu biết về nhãn hiệu sản phẩm), tăng cường hệ thống cơ sở dữ liệu, đạt được mục tiêu quan hệ khách hàng, cải thiện quản trị chuỗi cung ứng.",
        "Summary": "Quá trình quản trị marketing TMĐT gồm 6 bước, bắt đầu bằng **phân tích tình thế chiến lược** sử dụng ma trận TOWS để đánh giá mô hình kinh doanh hiện tại và kế hoạch marketing truyền thống, xác định cơ hội, thách thức, điểm mạnh, điểm yếu. Sau đó, **gắn kết mô hình ứng dụng TMĐT và thiết lập mục tiêu chiến lược marketing TMĐT**, chú trọng vào nhu cầu khách hàng và lựa chọn mô hình phù hợp, đồng thời đặt ra các mục tiêu cụ thể, đo lường được và có giới hạn thời gian (ví dụ: tăng thị phần, doanh thu, giảm chi phí, tăng nhận diện thương hiệu).",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các bước chính trong quản trị marketing TMĐT và mục tiêu của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về quá trình quản trị marketing TMĐT. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00043",
        "Article": "Mỗi chương trình bao gồm một số thành phần có ý nghĩa khác nhau: dữ liệu, lệnh, hàm, ngăn xếp.v.v., tuy nhiên, khi phân trang, chương trình được chia thành các trang kích thước đều nhau, không quan tâm đến tổ chức lôgic và ý nghĩa các thành phần. Bộ nhớ được coi như một khối duy nhất các byte hoặc các từ. Một cách tổ chức khác cho phép tính tới tổ chức lôgic của chương trình là phân đoạn (segmentation). Chương trình được chia thành những phần kích thước khác nhau gọi là đoạn (segment) tuỳ theo ý nghĩa của chúng. Chẳng hạn, ta có thể phân biệt: đoạn chương trình, chứa mã toàn bộ chương trình, hay một số hàm hoặc thủ tục của chương trình; đoạn dữ liệu, chứa các biến toàn cục, các mảng; đoạn ngăn xếp, chứa ngăn xếp của tiến trình trong quá trình thực hiện. Không gian địa chỉ lôgic của tiến trình khi đó sẽ gồm tập hợp các đoạn. Mỗi đoạn tương ứng với không gian địa chỉ riêng, được phân biệt bởi tên và độ dài của mình. Ngoài cách dùng tên, đoạn cũng có thể được đánh số để phân biệt. Mỗi địa chỉ lôgic do CPU sinh ra khi đó sẽ gồm hai phần: số thứ tự của đoạn và độ dịch trong đoạn. Việc chia chương trình thành các đoạn có thể do người lập trình thực hiện, chẳng hạn khi lập trình bằng assembly, hoặc do chương trình dịch tự của ngôn ngữ bậc cao tự động chia. Người lập trình khi đó cần biết kích thước tối đa được phép của đoạn, ví dụ để không khai báo mảng vượt kích thước tối đa này. Phân đoạn bộ nhớ giống với phân chương động ở chỗ bộ nhớ được cấp phát theo từng vùng kích thước thay đổi. Tuy nhiên, khác với phân chương động, mỗi chương trình có thể chiếm những đoạn bộ nhớ không nằm liền kề nhau. Mỗi khi có yêu cầu cấp phát bộ nhớ cho các đoạn, thuật toán cấp phát first-fit hoặc best-fit như phân chương động sẽ được sử dụng. Cũng như phân chương động, phân đoạn không sinh phân mảnh trong nhưng lại tạo phân mảnh ngoài. Mức độ phân mảnh ngoài phụ thuộc vào kích thước trung bình của đoạn. Đoạn càng nhỏ thì phân mảnh ngoài càng giảm. Trường hợp đặc biệt, nếu kích thước đoạn là một byte hay một từ tức là bằng đơn vị thông tin nhỏ nhất được đánh địa chỉ của bộ nhớ thì sẽ hoàn toàn không có phân mảnh ngoài. Tuy nhiên, số lượng đoạn tăng làm tăng kích thước của bảng phân đoạn và tăng thời gian quản lý các đoạn. Kích thước đoạn thường phụ thuộc kích thước bộ nhớ. Bộ nhớ càng lớn thì kích thước đoạn cũng được chọn càng lớn. Nhìn chung, phân mảnh ngoài khi phân đoạn nhỏ hơn phân chương động do tiến trình đã được chia thành các đoạn kích thước nhỏ hơn.",
        "Summary": "Phân đoạn bộ nhớ chia chương trình thành các đoạn có kích thước khác nhau dựa trên ý nghĩa của chúng, như đoạn chương trình, đoạn dữ liệu, và đoạn ngăn xếp. Mỗi địa chỉ lôgic do CPU sinh ra sẽ gồm số thứ tự đoạn và độ dịch trong đoạn. Mặc dù phân đoạn giúp tổ chức bộ nhớ linh hoạt và giảm phân mảnh trong, nó có thể gây phân mảnh ngoài, đặc biệt khi các đoạn nhỏ. Kích thước đoạn và số lượng đoạn phụ thuộc vào bộ nhớ, với phân mảnh ngoài ít hơn khi đoạn có kích thước nhỏ.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của phân đoạn bộ nhớ, ưu điểm và nhược điểm của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về phân đoạn bộ nhớ. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00044",
        "Article": "Thành phần cơ bản của PKI\n Dưới góc độ các hoạt động quản lý hệ thống PKI, những đối tượng tham gia vào hệ\n thống PKI bao gồm: các đối tượng sử dụng (EE), các đối tượng quản lý thẻ xác nhận (CA) và\n các đối tượng quản lý đăng ký (RA) và các hệ thống lưu trữ.\n - Thực thể cuối – Đối tượng sử dụng (EE – End Entity)91\n Là đối tượng sử dụng chứng nhận (chứng thư số): có thể là một tổ chức, một người cụ\n thể hay một dịch vụ máy chủ.\n - Tổ chức chứng nhận CA (Certificate Authority)\n Là cơ quan chuyên cung cấp và xác thực chứng chỉ số. CA có chức năng:\n + Có nhiệm vụ phát hành, quản lý và hủy bỏ các chứng thư số\n + Là thực thể quan trọng trong một PKI và được thực thể cuối tin cậy\n + Gồm tập hợp các con người và các hệ thống máy tính có độ an toàn cao.\n - Tổ chức đăng ký chứng nhận RA (Registration Authority)\n Là một cơ quan thẩm tra trên mạng máy tính, xác minh các yêu cầu của người dùng\n muốn sử dụng hoặc xác thực một chứng chỉ số và sau đó yêu cầu CA đưa ra kết quả. Mục\n đích chính của RA là để giảm tải công việc của CA. Chức năng thực hiện của một RA cụ thể\n sẽ khác nhau tùy theo nhu cầu triển khai PKI nhưng chủ yếu bao gồm các chức năng sau:\n + Được ủy quyền và có quyền thực hiện công việc mà CA cho phép\n + Tiếp nhận thông tin đăng ký chứng nhận\n + Gắn kết giữa khóa công khai và định danh của người giữ chứng nhận\n + Xác thực cá nhân, chủ thể đăng ký chứng thư số.\n + Kiểm tra tính hợp lệ của thông tin do chủ thể cung cấp.\n + Xác nhận quyền của chủ thể đối với những thuộc tính chứng thư số được yêu cầu.\n + Kiểm tra xem chủ thể có thực sự sở hữu khóa riêng đang được đăng ký hay không,\n điều này thường được đề cập đến như sự chứng minh sở hữu.\n + Tạo cặp khóa bí mật, công khai.\n + Phân phối bí mật được chia sẻ đến thực thể cuối (ví dụ khóa công khai của CA).\n + Thay mặt chủ thể thực thể cuối khởi tạo quá trình đăng ký với CA.\n + Lưu trữ khóa riêng.\n + Khởi sinh quá trình khôi phục khóa.\n + Phân phối thẻ bài vật lý (thẻ thông minh).\n - Hệ thống lưu trữ chứng nhận CR (Certificate Repository)\n Hệ thống lưu trữ chứng nhận CR có chức năng:\n + Hệ thống (có thể tập trung hoặc phân tán) lưu trữ chứng thư và danh sách các chứng\n thư bị thu hồi.\n + Cung cấp cơ chế phân phối chứng thư và danh sách thu hồi chứng thư (CRLs –\n Certificate Revocatio Lists).\n - Chứng chỉ số\n Chứng chỉ số là một tệp tin điện tử được sử dụng để nhận diện một cá nhân, một máy\n chủ, một công ty…trên Internet. Giống như bằng lái xe, hộ chiếu, chứng minh thư hay những\n giấy tờ nhận diện cá nhân thông thường khác, chứng chỉ số cung cấp bằng chứng cho sự nhận\n diện của một đối tượng.\n Để có chứng minh thư, bạn phải được cơ quan Công an sở tại cấp. Chứng chỉ số cũng92\n vậy, phải do một tổ chức đứng ra chứng nhận những thông tin của bạn là chính xác, được gọi\n là Nhà cung cấp chứng thực số (Certificate Authority, viết tắt là CA). CA phải đảm bảo về độ\n tin cậy, chịu trách nhiệm về độ chính xác của chứng chỉ số mà mình cấp.\n - Ủy quyền xác nhận hợp lệ - Validation Authority (VA)\n Validation Authority (VA) – Ủy quyền xác nhận hợp lệ: Xác nhận tính hợp lệ thẻ\n chứng thực số của một đối tác trao đổi thông tin. Hoặc VA là một thực thể cung cấp dịch vụ\n được sử dụng để xác minh tính hợp lệ của chứng chỉ kỹ thuật số theo các cơ chế được mô tả\n trong tiêu chuẩn X.509 và RFC 5280",
        "Summary": "\"Hệ thống PKI bao gồm các thành phần chính: đối tượng sử dụng (EE) là người dùng chứng thư số, tổ chức chứng nhận (CA) chịu trách nhiệm phát hành, quản lý và hủy bỏ chứng thư số, tổ chức đăng ký chứng nhận (RA) thẩm tra và xác minh yêu cầu chứng thư số, hệ thống lưu trữ chứng nhận (CR) lưu trữ chứng thư và danh sách thu hồi, và chứng chỉ số dùng để xác định danh tính trên Internet do CA cấp. Ngoài ra, còn có Ủy quyền xác nhận hợp lệ (VA) để xác nhận tính hợp lệ của chứng thư số.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các thành phần của hệ thống PKI được liệt kê rõ ràng và mối quan hệ giữa chúng được mô tả một cách logic. Câu văn trôi chảy và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các thành phần chính của hệ thống PKI và chức năng của chúng, loại bỏ các chi tiết không cần thiết. Các ý chính được giữ lại và trình bày một cách ngắn gọn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về các thành phần cơ bản của hệ thống PKI. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00045",
        "Article": "Bản thân Dữ liệu lớn được hình thành dựa trên lý thuyết. Ví dụ, nó sử dụng các lý thuyết thống kê và toán học, và đôi khi sử dụng cả khoa học máy tính. Đúng, chúng không phải là những lý thuyết về động lực quan hệ nhân quả của một hiện tượng đặc biệt như trọng lực, nhưng dù sao chúng vẫn là những lý thuyết. Và, như chúng ta đã chỉ ra, các mô hình dựa trên chúng có khả năng dự đoán rất hữu ích. Thật ra, dữ liệu lớn có thể cung cấp một cái nhìn tươi mát và những hiểu biết mới mẻ một cách chính xác vì nó không bị cản trở bởi lối suy nghĩ thông thường và những thành kiến cố hữu tiềm ẩn trong các lý thuyết của một lĩnh vực cụ thể. Hơn nữa, vì việc phân tích dữ-liệu-lớn được dựa trên các lý thuyết, ta không thể thoát khỏi chúng. Chúng định hình cả các phương pháp và các kết quả của chúng ta. Trước tiên là cách chúng ta lựa chọn dữ liệu. Các quyết định của chúng ta có thể được định hướng bởi sự tiện lợi: Phải chăng dữ liệu đã có sẵn? Hoặc bởi tính kinh tế: Liệu có thể thu thập được dữ liệu một cách ít tốn kém? Lựa chọn của chúng ta bị ảnh hưởng bởi các lý thuyết. Những gì chúng ta chọn sẽ ảnh hưởng tới những gì chúng ta tìm thấy, như các nhà nghiên cứu công nghệ số Danah Boyd và Kate Crawford đã lập luận. Xét cho cùng, Google đã sử dụng các từ khóa tìm kiếm như một phương tiện đo lường cho dịch cúm, chứ không sử dụng độ dài của tóc người. Tương tự như vậy, khi phân tích dữ liệu, chúng ta chọn những công cụ dựa trên các lý thuyết. Và khi giải thích kết quả, chúng ta lại áp dụng các lý thuyết. Thời đại của dữ liệu lớn rõ ràng không phải là không có lý thuyết - chúng có mặt khắp mọi nơi, với tất cả những gì chúng thừa hưởng. Anderson xứng đáng được vinh danh khi nêu lên những câu hỏi xác đáng - và đặc biệt là ông đã làm thế sớm hơn những người https://thuviensach.vn khác. Dữ liệu lớn có thể không chỉ rõ vào “Sự kết thúc của lý thuyết” , nhưng nó chuyển đổi một cách cơ bản cách chúng ta cảm nhận thế giới. Sự thay đổi này sẽ đòi hỏi rất nhiều công sức để làm quen. Nó thách thức nhiều tổ chức. Tuy nhiên, giá trị to lớn mà nó mang lại sẽ làm cho nó không chỉ là một sự đánh đổi đáng giá, mà còn là thứ không thể tránh khỏi. Tuy nhiên trước khi đạt tới đó, cũng đáng để lưu tâm xem chúng ta đã tới đây như thế nào. Nhiều người trong ngành kỹ thuật cao muốn gán công trạng chuyển đổi cho các công cụ kỹ thuật số mới, từ các chip nhanh tới phần mềm hiệu quả, bởi vì họ là những người làm ra công cụ. Sự kỳ diệu của kỹ nghệ là quan trọng, nhưng không quan trọng nhiều như người ta tưởng. Lý do sâu xa hơn của những xu hướng này là chúng ta có nhiều dữ liệu hơn rất nhiều. Và lý do chúng ta có nhiều dữ liệu hơn là vì chúng ta đã đưa nhiều khía cạnh hơn của thực tế vào một định dạng dữ liệu, cũng chính là chủ đề của chương kế tiếp.",
        "Summary": "Dữ liệu lớn được hình thành dựa trên các lý thuyết thống kê, toán học và khoa học máy tính, cung cấp cái nhìn mới mẻ do không bị ảnh hưởng bởi những thành kiến cố hữu. Các lý thuyết định hình cách lựa chọn dữ liệu, công cụ phân tích và giải thích kết quả, dù là dựa trên sự tiện lợi hay kinh tế. Dữ liệu lớn không loại bỏ lý thuyết mà chuyển đổi cách chúng ta cảm nhận thế giới, đòi hỏi sự thích nghi và mang lại giá trị to lớn, một phần nhờ vào việc số hóa nhiều khía cạnh của thực tế.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy và xác minh trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng để đảm bảo rằng bản tóm tắt phản ánh chính xác nội dung quan trọng nhất của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và súc tích về văn bản gốc. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00046",
        "Article": "Câu hỏi ở đây là: Nhà có chứa một phòng bếp hay không (House HAS-A Kitchen)? Nếu câu trả lời là \"Có\", điều đó có nghĩa House có một biến thực thể kiểu Kitchen. Nói cách khác, House có một tham 108 chiếu tới một đối tượng Kitchen, chứ House không chuyên biệt hóa Kitchen hay ngược lại. Quan hệ HAS-A trong Java được cài đặt bằng tham chiếu đặt tại đối tượng chứa chiếu tới đối tượng thành phần. Quan hệ HAS-A giữa hai lớp thể hiện một trong ba quan hệ: kết hợp (association), tụ hợp (aggregation) và hợp thành (composition) mà các tài liệu về thiết kế hướng đối tượng thường nói đến. Giữa hai lớp có quan hệ kết hợp nếu như các đối tượng thuộc lớp này cần biết đến đối tượng thuộc lớp kia để có thể thực hiện được công việc của mình. Chẳng hạn, một người nhân viên chịu sự quản lý của một người quản lý, ta có quan hệ kết hợp nối từ Employee tới Manager, thể hiện ở việc mỗi đối tượng Employee có một tham chiếu boss kiểu Manager. Hợp thành và tụ hợp là các quan hệ giữa một đối tượng và thành phần của nó (cũng là đối tượng). Khác nhau ở chỗ, với quan hệ hợp thành, đối tượng thành phần là phần không thể thiếu được của đối tượng chứa nó, còn với quan hệ tụ hợp thì ngược lại. Ví dụ, một cuốn sách bao gồm nhiều trang sách và một cuốn sách không thể tồn tại nếu không có trang nào. Do đó giữa Book (sách) và Page (trang) có quan hệ hợp thành. Thư viện có nhiều sách, nhưng thư viện không có cuốn sách nào vẫn là một thư viện, nên quan hệ giữa Library (thư viện) và Book là quan hệ tụ hợp. Java không có cấu trúc nào dành riêng để cài đặt các quan hệ tụ hợp hay hợp thành. Ta chỉ cài đặt đơn giản bằng cách đặt vào đối tượng chủ các tham chiếu tới đối tượng thành phần, hay nói cách khác là phân rã thành các quan hệ HAS-A, chẳng hạn quan hệ hợp thành giữa Book và Page có thể được phân rã thành 'Book HAS-A ArrayList<Page>' và nhiều quan hệ 'ArrayList<Page> HAS-A Page'. Các ràng buộc khác được đảm bảo bởi các phương thức có nhiệm vụ khởi tạo hay sửa các tham chiếu đó.",
        "Summary": "Văn bản mô tả quan hệ HAS-A trong thiết kế hướng đối tượng, thể hiện bằng tham chiếu giữa các đối tượng trong Java. Ba loại quan hệ chính được đề cập là kết hợp, tụ hợp và hợp thành, phân biệt nhau bởi mức độ phụ thuộc giữa đối tượng chứa và đối tượng thành phần. Java không hỗ trợ trực tiếp các quan hệ tụ hợp và hợp thành, mà thực hiện thông qua các tham chiếu (ví dụ: `Book HAS-A ArrayList<Page>`), với các ràng buộc được đảm bảo bởi các phương thức quản lý tham chiếu. Bản chất của HAS-A là một đối tượng sở hữu tham chiếu tới đối tượng khác, chứ không phải là sự kế thừa.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy và kiểm chứng trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo rằng người đọc có thể hiểu được bản chất của quan hệ HAS-A và các loại quan hệ liên quan mà không bị lạc trong các chi tiết vụn vặt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất cao. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00047",
        "Article": "Các phân tích ở phần trên cho thấy, việc cấp phát khối liên tiếp có nhiều nhược điểm đáng kể và do vậy ít khi được sử dụng. Một phương pháp cho phép khắc phục những nhược điểm này là sử dụng danh sách kết nối (linked list). Trong phương pháp này, các khối thuộc về mỗi file được nối với nhau thành một danh sách móc nối. Trên hình 4.8 là ví dụ một file bắt đầu từ khối 1 và bao gồm các khối 1,3, 8,17,6. Mỗi khối chứa con trỏ tới khối tiếp theo. Để chứa con trỏ, hệ điều hành dành ra một số byte ở đầu mỗi khối. Chẳng hạn, với khối kích thước là 512 byte, ta có thể dành 508 byte chứa dữ liệu của file, còn 4 byte chứa con trỏ tới khối tiếp theo. Khác với cách cấp phát khối ở phần trước, các khối thuộc về một file có thể nằm bất cứ chỗ nào trên đĩa chứa không nhất thiết nằm liền kề nhau. Để xác định vị trí file trên đĩa, khoản mục của thư mục sẽ chứa con trỏ tới khối đầu tiên của file. Khi mới tạo file, con trỏ này có giá trị nil (dấu hiệu kết thúc file và có thể có các giá trị khác nhau tuỳ vào hệ thống cụ thể). Mỗi khi file được cấp thêm khối mới, khối vừa cấp được thêm vào cuối danh sách. Để truy cập file, hệ điều hành đọc lần lượt từng khối và sử dụng con trỏ để xác định khối tiếp theo. Do các khối thuộc về một file có thể nằm bất cứ chỗ nào trên đĩa, không nhất thiết phải nằm cạnh nhau nên phương pháp cấp phát này cho phép tránh được hiện tượng phân mảnh ngoài. Không có khối trống nào bị bỏ phí. Phương pháp cấp phát này cũng không yêu cầu biết trước kích thước khi tạo file. Kích thước file có thể tăng dễ dàng sau khi đã được tạo. Để tăng kích thước file, hệ điều hành chỉ việc thêm khối trống vào danh sách và sửa lại con trỏ ở khối cuối. Mặc dù giải khắc phục được các nhược điểm của phương pháp cấp khối liên tục, sử dụng danh sách kết nối cũng có một số nhược điểm. Nhược điểm lớn nhất là phương pháp này chỉ hỗ trợ truy cập tuần tự mà khôngcho phép truy cập file trực tiếp. Để đọc một khối nào đó ta phải theo tất cả các con trỏ từ khối đầu tiên cho tới khối cần đọc. Do con trỏ nằm ngay trong các khối và khối là đơn vị nhỏ nhất có thể tiến hành đọc nên để xác định con trỏ, ta phải đọc cả khối. Như vậy, Để đọc một khối, ta phải đọc lần lượt tất cả các khối nằm trước bắt đầu từ khối đầu tiên. Nhược điểm thứ hai liên quan tới tốc độ truy cập file. Do các khối thuộc về một file có thể nằm rải rác ở nhiều nơi trên đĩa nên đầu từ của đĩa phải thực hiện nhiều thao tác di chuyển mới truy cập được hết dữ liệu của file. Việc liên kết các khối thuộc về một file bằng con trỏ cũng làm giảm độ tin cậy và tính toàn vẹn của hệ thống file. Trong trường hợp giá trị các con trỏ bị thay đổi không đúng do lỗi việc xác định khối nào thuộc file nào sẽ không chính xác. Chi tiết về tính toàn vẹn của hệ thống file sẽ được trình bầy trong một phần sau.",
        "Summary": "\"Phương pháp cấp phát khối bằng danh sách liên kết khắc phục nhược điểm của cấp phát khối liên tiếp bằng cách cho phép các khối của file nằm rải rác trên đĩa và được liên kết bằng con trỏ. Điều này giúp tránh phân mảnh ngoài và không cần biết trước kích thước file. Tuy nhiên, phương pháp này chỉ hỗ trợ truy cập tuần tự, làm chậm tốc độ truy cập do đầu đọc phải di chuyển nhiều và làm giảm độ tin cậy do con trỏ có thể bị lỗi.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, tập trung vào ưu điểm và nhược điểm của phương pháp cấp phát khối bằng danh sách liên kết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt ngắn gọn, đầy đủ, trung thực, mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00048",
        "Article": "Phát triển phần mềm hướng đối tượng (Object-Oriented Software Development) là một phương pháp tiếp cận hiện đại và phổ biến trong việc thiết kế và xây dựng hệ thống phần mềm. Phương pháp này dựa trên nguyên lý mô hình hóa thế giới thực thông qua các đối tượng (objects), trong đó mỗi đối tượng là sự kết hợp giữa dữ liệu (thuộc tính) và hành vi (phương thức). Các đối tượng tương tác với nhau thông qua việc gửi và nhận thông điệp, tạo thành hệ thống phần mềm linh hoạt, dễ mở rộng và bảo trì. Các đặc điểm cốt lõi của phương pháp hướng đối tượng bao gồm: tính đóng gói (encapsulation), giúp che giấu chi tiết cài đặt và bảo vệ dữ liệu bên trong đối tượng; tính kế thừa (inheritance), cho phép lớp con kế thừa thuộc tính và hành vi từ lớp cha để tái sử dụng và mở rộng hệ thống; tính đa hình (polymorphism), giúp các đối tượng có thể xử lý các thông điệp theo cách riêng của mình tùy vào ngữ cảnh cụ thể. Việc phát triển phần mềm theo hướng đối tượng thường bắt đầu bằng phân tích hướng đối tượng, sử dụng các sơ đồ như Use Case, sơ đồ lớp, sơ đồ trình tự để xác định yêu cầu và mô hình hóa hệ thống. Sau đó, thiết kế hướng đối tượng được tiến hành để xác định cấu trúc lớp, quan hệ giữa các lớp, cách triển khai phương thức, từ đó chuyển sang lập trình bằng ngôn ngữ hướng đối tượng như Java, C++, C#, Python,... Hướng đối tượng giúp dễ quản lý hệ thống lớn, tái sử dụng mã nguồn và giảm chi phí bảo trì. Tuy nhiên, để áp dụng hiệu quả phương pháp này, lập trình viên cần có tư duy mô hình hóa tốt, nắm rõ nguyên lý thiết kế phần mềm và có khả năng tổ chức mã nguồn khoa học. Đây là lý do vì sao phương pháp hướng đối tượng được giảng dạy rộng rãi và trở thành nền tảng trong nhiều chương trình đào tạo công nghệ phần mềm.",
        "Summary": "Phát triển phần mềm hướng đối tượng là phương pháp tổ chức phần mềm theo các đối tượng mô phỏng thực tế, giúp tăng tính tái sử dụng và mở rộng hệ thống. Các đối tượng bao gồm dữ liệu và các phương thức xử lý, liên kết chặt chẽ với nhau. Phương pháp này giúp dễ bảo trì, dễ mở rộng và thích hợp với các hệ thống lớn, phức tạp. Hướng đối tượng thường đi kèm với các khái niệm như đóng gói, kế thừa và đa hình, tạo nên cấu trúc phần mềm linh hoạt, dễ thích ứng với thay đổi trong suốt vòng đời phát triển.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ thông điệp cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00049",
        "Article": "Thuật toán tìm kiếm tổng quát như vậy sinh ra một cây tìm kiếm, trong đó mỗi trạng thái tương ứng với một nút trên cây, mỗi nhánh tương ứng với một chuyển động tại nút đang xét. Trạng thái xuất phát tương ứng với gốc cây, những trạng thái được mở rộng tạo thành các nút thế hệ tiếp theo. Trên hình 2.4 là ví dụ một phần cây tìm kiếm sinh ra cho bài toán đố 8 ô. Sau đây là một số thuật ngữ sử dụng khi trình bày về thuật toán tìm kiếm: • Mở rộng nút là áp dụng các chuyển động lên trạng thái tương ứng để sinh ra các nút • Nút lá là các nút không có nút con tại thời điểm đang xét. • Các nút biên (còn gọi là nút mở): là tập các nút lá có thể mở rộng tiếp. • Tập các nút đã được mở rộng được gọi là tập các nút đóng, hay đơn giản là tập đóng. Hình 2.4. Cây tìm kiếm cho bài toán 8 ô Nguyên lý tìm kiếm vừa trình bầyđược thể hiện qua thuật toán tìm kiếm tổng quát trên hình 2.5. Thuật toán duy trì tập các nút biên O được khởi tạo bằng tập trạng thái xuất phát. Qua mỗi vòng lặp, thuật toán lấy ra một nút từ tập biện O, kiểm tra xem nút này có phải đích không. Nếu nút được lấy ra là đích, thuật toán trả về kết quả. Trong trường hợp ngược lại, nút này được mở rộng, tức là dùng hàm chuyển động để sinh ra các nút con. Các nút mới sinh ra lại được thêm vào tập O. Thuật toán kết thúc khi tìm thấy trạng thái đích hoặc khi O rỗng.",
        "Summary": "Sau đây là một số thuật ngữ sử dụng khi trình bày về thuật toán tìm kiếm Mở rộng nút là áp dụng các chuyển động lên trạng thái tương ứng để sinh ra các nút Nút lá là các nút không có nút con tại thời điểm đang xét.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt trích dẫn chính xác các định nghĩa về 'Mở rộng nút' và 'Nút lá' từ văn bản gốc. Không có thông tin nào bị thêm hoặc thay đổi."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liệt kê hai định nghĩa liên tiếp nhau, tạo ra một sự liên kết nhất định. Tuy nhiên, việc thiếu ngữ cảnh có thể làm giảm tính mạch lạc tổng thể. Cần thêm một câu dẫn nhập để tăng tính mạch lạc."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tập trung vào các định nghĩa, nhưng bỏ qua ý chính về thuật toán tìm kiếm tổng quát và cách nó sinh ra cây tìm kiếm. Điều này làm giảm tính liên quan của tóm tắt đến mục đích chính của văn bản gốc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt trung thực nhưng chưa đủ liên quan và mạch lạc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát và thêm một câu dẫn nhập để cải thiện tính mạch lạc. "
            }
        }
    },
    {
        "Index": "00050",
        "Article": "LẬP TRÌNH SOCKET Socket là một phương pháp để thiết lập kết nối truyền tin giữa một chương trình yêu cầu dịch vụ và một chương trình cung cấp dịch trên mạng và đôi khi trong máy tính. Theo định nghĩa các chức năng mỗi tầng trong mô hình OSI, tầng mạng đảm nhiệm liên kết giữa đầu cuối với đầu cuối thì tầng vận tải đảm nhiệm liên kết giữa hai tiến trình. Mỗi socket là một điểm cuối trong một kết nối và có thể được xem như kết hợp của tầng mạng và tầng vận tải, do đó nó phải bao gồm một cặp địa chỉ logic của tầng mạng và số hiệu cổng của tầng vận tải. Một socket trên máy yêu cầu dịch vụ có địa chỉ mạng được cấp sẵn để gọi một socket trên máy cung cấp dịch vụ. Một khi socket đã được thiết lập phù hợp, hai máy tính có thể trao đổi dịch vụ và dữ liệu. 5.1 Khái niệm về socket Khái niệm lập trình socket do trường đại học Berkeley để xuất vào những năm 1980, xuất hiện lần đầu tiên trong hệ điều hành Unix là Berkeley Sockets Interface, một chương trình thiết bị được thiết kế để giúp máy tính nối mạng có thể trao đổi thông tin với nhau. Giữa những năm 1990, Microsoft đã tạo riêng socket của họ là Windows Sockets (còn gọi là WinSock), nhờ vậy các ứng dụng Windows có thể trao đổi thông tin với nhau qua mạng máy tính. 5.1.1 Mô hình khách/chủ Mô hình khách/chủ cung cấp một cách tiếp cận tổng quát để chia sẻ tài nguyên trong các hệ thống phân tán, trong đó tiến trình cung cấp dịch vụ gọi là tiến trình chủ (server) và ngược lại tiến trình sử dụng dịch vụ gọi là tiến trình khách (client). Tài nguyên sẽ được quản lý bởi một tập các tiến trình gọi là các tiến trình server và mọi tiến trình client muốn thực hiện truy xuất tới tài nguyên thông qua tiến trình server đó. Bản thân các tiến trình server cũng cần phải truy xuất tới các tài nguyên dùng chung được quản lý bởi một tiến trình khác, vì vậy một số tiến trình có thể đóng cả hai vai trò client và server. Các tiến trình khách gửi yêu cầu tới tiến trình chủ, nếu yêu cầu hợp lệ thì tiến trình chủ sẽ thực hiện yêu cầu và trả về kết quả cho tiến trình trên máy khách.",
        "Summary": "Socket là phương pháp thiết lập kết nối truyền tin giữa chương trình yêu cầu và cung cấp dịch vụ trên mạng. Mỗi socket là một điểm cuối kết nối, bao gồm địa chỉ mạng và số hiệu cổng. Mô hình khách/chủ (client/server) là cách tiếp cận tổng quát để chia sẻ tài nguyên trong hệ thống phân tán, trong đó tiến trình chủ (server) cung cấp dịch vụ và tiến trình khách (client) sử dụng dịch vụ. Các tiến trình server quản lý tài nguyên và tiến trình client gửi yêu cầu đến server để truy xuất tài nguyên.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt trích dẫn chính xác các định nghĩa về 'Mở rộng nút' và 'Nút lá' từ văn bản gốc. Không có thông tin nào bị thêm hoặc thay đổi."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liệt kê hai định nghĩa liên tiếp nhau, tạo ra một sự liên kết nhất định. Tuy nhiên, việc thiếu ngữ cảnh có thể làm giảm tính mạch lạc tổng thể. Cần thêm một câu dẫn nhập để tăng tính mạch lạc."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tập trung vào các định nghĩa, nhưng bỏ qua ý chính về thuật toán tìm kiếm tổng quát và cách nó sinh ra cây tìm kiếm. Điều này làm giảm tính liên quan của tóm tắt đến mục đích chính của văn bản gốc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt trung thực nhưng chưa đủ liên quan và mạch lạc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát và thêm một câu dẫn nhập để cải thiện tính mạch lạc. "
            }
        }
    },
    {
        "Index": "00051",
        "Article": "Đơn vị mới thâm nhập thị trường Đổi mới kỹ thuật số đã giảm các rào cản chi phí, cho phép nhiều đơn vị mới tham gia. Những đơn vị mới tham gia thị trường không yêu cầu đầu tư vào các điểm truy cập vật lý như chi nhánh, máy ATM hoặc đại lý. Mặc dù sự kết hợp “phygital” giữa cơ sở hạ tầng kỹ thuật số và vật lý tiếp tục cần thiết để phục vụ khách hàng (ngay cả người dùng tài sản tiền điện tử cũng được cung cấp máy ATM bitcoin), khả năng tương tác ngày càng tăng và dễ dàng sắp xếp thuê ngoài được mô tả trước đó cho phép các nhà cung cấp không có mạng lưới vật lý hợp tác với những người khác để cung cấp các dịch vụ đó khi cần thiết. Mạng vật lý yêu cầu quy mô và mao dẫn, nhưng một vài mạng lưới đại lý, chi nhánh và ATM có thể phục vụ thị trường mà không cần mọi nhà cung cấp phải tạo và duy trì. Làn sóng đổi mới công nghệ tài chính hiện nay được đánh dấu bằng sự gia nhập của một bên là các công ty khởi nghiệp (công ty công nghệ tài chính) và mặt khác là các công ty công nghệ lớn (công ty công nghệ lớn). Những công ty thứ nhất thường có nguồn lực dồi dào nhờ lãi suất đầu tư mạo hiểm tích cực, nhưng không có lợi ích từ cơ sở khách hàng hiện tại và thường sử dụng các phương pháp tích cực để giành thị phần từ những công ty đương nhiệm trên các sản phẩm cụ thể. Loại thứ hai có lợi thế là có cơ sở khách hàng và dòng doanh thu hiện tại và có thể tận dụng những điều này để mở rộng quy mô nhanh chóng và tích hợp các dịch vụ tài chính vào các sản phẩm và dịch vụ hiện có của họ. Các loại đơn vị tham gia khác nhau có thể có những tác động rất khác nhau đối với cấu trúc thị trường và mang những tác động khác nhau đối với các chính sách điều tiết tài chính, cạnh tranh và bảo vệ người tiêu dùng. Các nhà cung cấp thích hợp có thể cung cấp các sản phẩm và dịch vụ phù hợp và tìm một cơ sở khách hàng quan tâm. Mặc dù họ vẫn phải phát triển danh tiếng đáng tin cậy, nhưng việc loại bỏ nhiều chi phí cố định và giảm chi phí biến đổi và chuyển đổi giúp nhà cung cấp chi phí thấp có thể tham gia thị trường từ quan điểm khả thi kinh tế. Tuy nhiên, rủi ro và các lực lượng kinh tế cứng đầu hơn chi phí. Rủi ro tín dụng, thanh khoản, thị trường và hoạt động có thể được giảm bớt hoặc chuyển giao, nhưng không được loại bỏ hoàn toàn. Quy mô tấn công của bọn tội phạm mạng đã trở nên lớn hơn, vì khả năng kết nối lẫn nhau và sự phân chia dịch vụ tạo ra nhiều liên kết hơn cho từng chuỗi sản phẩm và giao diện người dùng. Những người trả lời Khảo sát những người tham gia thị trường công nghệ tài chính đã được hỏi liệu họ mong muốn khách hàng bán lẻ và doanh nghiệp vừa và nhỏ có một mối quan hệ tài chính cốt lõi duy nhất hay sử dụng nhiều nhà cung cấp mà không có mối quan hệ cốt lõi nào. 36% số người được hỏi mong muốn khách hàng sử dụng nhiều nhà cung cấp mà không có mối quan hệ cốt lõi và 16% mong đợi rằng khách hàng sẽ có mối quan hệ cốt lõi với thị trường hoặc nhà cung cấp nền tảng.",
        "Summary": "Thị trường kỹ thuật số đã giảm rào cản gia nhập, cho phép nhiều đơn vị mới tham gia mà không cần đầu tư vào cơ sở hạ tầng vật lý. Các công ty khởi nghiệp công nghệ tài chính (Fintech) và các công ty công nghệ lớn (Big Tech) là những đối tượng tham gia chính, mang lại những tác động khác nhau đến cấu trúc thị trường. Fintech tận dụng vốn đầu tư mạo hiểm để cạnh tranh thị phần, trong khi Big Tech tận dụng cơ sở khách hàng hiện tại để mở rộng dịch vụ tài chính. Mặc dù chi phí giảm, rủi ro tín dụng, thanh khoản, thị trường và hoạt động vẫn tồn tại, đặc biệt là rủi ro từ tội phạm mạng. Phần lớn người tham gia thị trường dự đoán khách hàng sẽ sử dụng nhiều nhà cung cấp dịch vụ tài chính thay vì tập trung vào một mối quan hệ cốt lõi duy nhất.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00052",
        "Article": "3.1.2.2. Quy trình sử dụng chữ ký số để ký các thông điệp dữ liệu Để ký một chứng từ điện tử, người gửi sẽ sử dụng khóa bí mật và phần mềm ký điện tử để mã hóa chứng từ đó thành chữ ký số rồi gửi cho người nhận. Tuy nhiên, về nguyên tắc, để tạo điều kiện thuận lợi cho người nhận trong quá trình kiểm tra tính toàn vẹn của nội dung chứng từ và xác thực chữ ký, người gửi có thể gửi kèm theo thông điệp đã ký khóa công khai và chứng thư điện tử của mình hoặc địa chỉ để truy cập chứng thư điện tử của mình. Với khóa công khai và chứng thư điện tử, người nhận sẽ dễ dàng xác thực được chữ ký và nội dung thông điệp. H 2.6. Minh họa quy trình ký số và xác thực chữ ký số Quy trình tạo và chứng thực chữ ký số đem lại ba lợi thế cho chữ ký số: - Chữ ký số là duy nhất đối với từng văn bản được ký vì yếu tố đầu vào thứ nhất là bản thân chính văn bản đó; B1. Rút gọn văn bản cần ký bằng phần mềm rút gọn (hash function) B2. Tạo chữ ký số bằng khóa bí mật & văn bản đã rút gọn B3. Gửi văn bản gốc, chữ ký số, khóa công khai, chứng chỉ số cho người nhận B4. Giải mã chữ ký số của người gửi bằng khóa công khai được văn bản rút gọn 1 B5. Rút gọn văn bản gốc nhận được để có văn bản rút gọn 2 B6. So sánh hai văn bản rút gọn thu được để kiểm tra tính toàn vẹn của nội dung - Chữ ký số là duy nhất đối với chủ thể ký vì yếu tố đầu vào thứ hai là khóa bí mật gắn với chủ thể đó; - Trong trường hợp cần xác thực thông tin người đã ký có thể sử dụng chứng chỉ số và khóa công khai của cơ quan chứng thực để kiểm tra Quy trình thực hiện ký số cũng tạo điều kiện để xác thực chữ ký số dễ dàng hơn so với chữ ký tay trên giấy. Việc xác thực chữ ký được thực hiện căn cứ vào ba yếu tố đầu vào gồm: (i) văn bản được ký; (ii) chữ ký số và (iii) khóa công khai. Quy trình kiểm tra chữ ký số được phần mềm thực hiện và cho kết quả đúng và sai. Nếu đúng có nghĩa văn bản và chữ ký số là xác thực nếu sai có nghĩa một trong hai yếu tố xác thực đã bị thay đổi hoặc sai lệch. Việc tạo ra chữ ký số có thể do máy tính hoặc các thiết bị điện tử cầm tay thực hiện, các thiết bị này có thể truy cập đến khóa bí mật được lưu tại một vị trí bí mật trong hoặc ngoài thiết bị đó. Có nhiều loại chữ ký điện tử khác được sử dụng hỗ trợ chữ ký số như thẻ thông minh (smartcard), dấu hiệu sinh học (biometrics) và mật khẩu (passwords). Lợi ích nổi bật nhất của chữ ký số là giải quyết được việc ràng buộc trách nhiệm của các bên trong giao dịch điện tử. Thông thường, khi một bên xác nhận sự đồng ý với nội dung giao dịch thông qua việc kích chuột vào nút “I agree” hoặc “Confirm” trên website nếu xảy ra tranh chấp sẽ rất khó để xác minh hoặc tìm lại vị trí của các nút trên. Đồng thời cũng rất khó xác định xem đó có phải là nút “I agree” đã được sử dụng cho giao dịch hay không, đặc biệt khi các website luôn thay đổi về nội dung và hình thức. Trong các giao dịch điện tử với giá trị nhỏ được thực hiện tự động chữ ký số được gắn vào các hóa đơn điện tử sẽ ràng buộc trách nhiệm của người bán và tạo được sự tin tưởng của người mua tốt hơn.",
        "Summary": "Để ký một chứng từ điện tử, người gửi mã hóa chứng từ bằng khóa bí mật và phần mềm ký điện tử để tạo chữ ký số, sau đó gửi kèm khóa công khai và chứng thư điện tử cho người nhận để xác thực. Quy trình này đảm bảo tính duy nhất của chữ ký đối với văn bản và chủ thể ký, đồng thời tạo điều kiện xác thực dễ dàng hơn thông qua văn bản, chữ ký số và khóa công khai. Chữ ký số ràng buộc trách nhiệm của các bên trong giao dịch điện tử, đặc biệt quan trọng trong các giao dịch tự động và hóa đơn điện tử, tạo sự tin tưởng giữa người mua và người bán.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ nguyên và trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được sắp xếp hợp lý, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa hoặc không cần thiết. Bản tóm tắt tập trung vào quy trình ký số, lợi ích và ứng dụng của nó trong giao dịch điện tử."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00053",
        "Article": "Mô hình quan hệ ra đời từ nhu cầu cấp thiết về một phương pháp quản lý dữ liệu hiệu quả hơn trong thời kỳ công nghệ thông tin phát triển mạnh mẽ. Trước thập niên 1970, dữ liệu chủ yếu được lưu trữ và xử lý qua hệ tập tin truyền thống, nơi mỗi ứng dụng phải tự định nghĩa cách tổ chức tệp, dẫn đến sự phụ thuộc chặt chẽ giữa phần mềm và phần cứng. Ví dụ, để quản lý sinh viên, một tệp có thể chứa tất cả thông tin như mã sinh viên, họ tên, điểm thi, nhưng nếu muốn thêm môn học mới, phải viết lại chương trình, gây tốn kém và dễ lỗi. Các mô hình sớm như phân cấp (Hierarchical Model) và mạng (Network Model) cải tiến bằng cách tổ chức dữ liệu theo cây hoặc đồ thị, nhưng vẫn phức tạp và thiếu linh hoạt khi truy vấn dữ liệu không theo cấu trúc cố định. Năm 1970, E.F. Codd, nhà khoa học tại IBM, giới thiệu mô hình quan hệ trong bài báo “A Relational Model of Data for Large Shared Data Banks”, đề xuất dùng bảng (table) để biểu diễn dữ liệu và các phép toán đại số để truy vấn. Ông nhấn mạnh tính độc lập dữ liệu, tách logic (cách người dùng nhìn bảng) khỏi vật lý (cách lưu trên đĩa), giúp thay đổi phần cứng mà không cần sửa ứng dụng. Ý nghĩa của mô hình quan hệ nằm ở sự đơn giản và mạnh mẽ: dữ liệu được chia thành các bảng như Sinh viên (MASV, HOTEN), Môn học (MAMH, TENMH), Kết quả (MASV, MAMH, DIEMTHI), liên kết qua khóa, giảm dư thừa và tăng hiệu quả. Ví dụ, thay vì lặp lại họ tên trong mọi dòng điểm thi, ta chỉ lưu một lần ở Sinh viên, dùng MASV để tham chiếu. Công trình của Codd đặt nền móng cho ngôn ngữ SQL và các hệ quản trị như Oracle, MySQL, thay đổi cách quản lý dữ liệu từ giáo dục, ngân hàng đến thương mại điện tử, trở thành tiêu chuẩn vàng trong ngành công nghệ thông tin hiện đại.",
        "Summary": "Mô hình quan hệ ra đời từ nhu cầu tổ chức dữ liệu một cách khoa học, dễ truy xuất và phù hợp với công nghệ máy tính hiện đại. Dữ liệu được biểu diễn dưới dạng bảng, mỗi bảng gồm các dòng (bản ghi) và cột (thuộc tính). Mô hình này hỗ trợ các phép toán đại số quan hệ và ngôn ngữ truy vấn SQL, cho phép xử lý dữ liệu hiệu quả. Sự đơn giản và rõ ràng của mô hình quan hệ khiến nó trở thành chuẩn mực trong nhiều hệ thống thông tin.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu văn liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào những ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ thông điệp quan trọng nhất của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng cô đọng thông tin một cách hiệu quả, giúp người đọc nhanh chóng nắm bắt được nội dung cốt lõi của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00054",
        "Article": "8.2. CÁC PHƯƠNG PHÁP ĐẶC TẢMÔ HÌNH Hình 8.1: Quy trình kiểm thửdựa trên mô hình [KJ02]. Định nghĩa 8.1. Máy trạng thái hữu hạn là một bộbốn (S, Act, T, q0), trong đó S là tập hữu hạn các trạng thái, T là tập các chuyển trạng thái, Act là các tập các sựkiện (còn có tên khác là bảng ký hiệu) và q0 là trạng Hình 8.2 mô tảmột ví dụvềmột máy hữu hạn trạng thái đặc tảhành vi của một hệthống chuyển công tắc đèn [KJ02]. Trong hình này, off là trạng thái khởi đầu của hệthống. Ởtrạng thái này, đèn đang bịtắt. Với đầu vào là turn on, hệthống sẽchuyển đến trạng thái normal với đèn có độsáng bình thường. Tại trạng thái này, chúng ta có thểtắt đèn (ứng với đầu vào turn off và hệthống sẽchuyển vềtrạng thái off ), tăng độsáng của đèn (ứng với đầu vào increase intensity và hệthống sẽchuyển vềtrạng thái bright) và giảm độsáng của đèn (ứng với đầu vào decrease intensity và hệthống sẽchuyển vềtrạng thái dim). Tại các trạng thái dim và bright, chúng ta có thểtắt đèn, tăng và giảm độsáng tương ứng. Bảng 8.1 là một dạng đặc tảkhác của máy hữu hạn trạng thái trên dưới dạng bảng chuyển. Chúng ta sẽdùng cấu trúc dữliệu này làm đầu vào cho các công cụkiểm thửtựđộng. Hình 8.2: Một ví dụvềmáy hữu hạn trạng thái. Bảng 8.1: Bảng chuyển của máy hữu hạn trạng thái trong hình 8.2 Ôtômat đơn định hữu hạn trạng thái Tương tựnhư FSM, ôtômat đơn định hữu hạn trạng thái (Deterministic Finite state Automaton - DFA) cũng rất hiệu quảtrong việc đặc tảhành vi dựa trên việc chuyển trạng thái của các hệthống. Một cách hình thức, DFA được định nghĩa như sau.",
        "Summary": "CÁC PHƯƠNG PHÁP ĐẶC TẢMÔ HÌNH Hình 8. 1 Quy trình kiểm thửdựa trên mô hình KJ02. Chúng ta sẽdùng cấu trúc dữliệu này làm đầu vào cho các công cụkiểm thửtựđộng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt trung thực, tuy nhiên, việc trích dẫn mỗi hai câu từ văn bản gốc mà không có sự liên kết rõ ràng có thể gây khó hiểu cho người đọc."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc. Hai câu trích dẫn không liên kết với nhau về mặt ý nghĩa, tạo cảm giác rời rạc và khó hiểu."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chỉ chọn lọc một vài chi tiết nhỏ từ văn bản gốc, bỏ qua các ý chính quan trọng như định nghĩa về máy trạng thái hữu hạn (FSM) và ôtômat đơn định hữu hạn trạng thái (DFA). Do đó, tính liên quan của bản tóm tắt rất thấp."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt hiện tại có chất lượng rất kém. Nó thiếu tính mạch lạc, tính liên quan và không truyền tải được thông tin chính của văn bản gốc. Cần cải thiện bằng cách xác định rõ các ý chính của văn bản gốc, tóm tắt chúng một cách ngắn gọn và liên kết các ý này một cách logic."
            }
        }
    },
    {
        "Index": "00055",
        "Article": "Đóng gói sản phẩm bao gồm các công việc sau: + Xây dựng tài liệu, gồm: • Tài liệu hướng dẫn sử dụng • Tài liệu kỹ thuật (tài liệu hướng dẫn cấu hình hệ thống) + Cài đặt với dữ liệu thực của khách hàng: • Cài đặt trên một hệ quản trị cơ sở dữ liệu cụ thể • Nhập dữ liệu thực tiễn để thực thi và đánh giá … + Đóng gói chương trình: Có các tiện tích để đóng gói chương trình thành các gói để dễ dàng cài đặt chương trình lên hệ thống như Install Anywhere, InstallShield… Thường thì các bước đóng gói sản phẩm phần mềm sẽ bao gồm: • Bước 1: Tổ chức các thư mục • Bước 2: Tổ chức các thành phần cho người dùng chọn khi cài đặt. • Bước 3: Liệt kê danh sách các tập tin DLL cần dùng • Bước 4: Liệt kê danh sách các tập tin OCX cần dùng • Bước 5: Liệt kê danh sách các Dabatase Drivers cần cài đặt • Bước 6: Liệt kê danh sách các Printer Drivers • Bước 7: Liệt kê danh sách các FONT cần cài đặt • Bước 8: Soạn thảo các tập tin : Readme, INI • Bước 9: Liệt kê danh sách các Utilities Software cài thêm • Bước 10: Liệt kê danh sách các logo, hình ảnh giới thiệu trong quá trình cài đặt. • Bước 11: Tạo file Script • Bước 12: Tạo License Key • Bước 13: Tạo Demo cho sản phẩm • Bước 14: Tạo File Help • Bước 15 : Thực hiện đóng gói. • Bước 16 : Viết tài liệu đóng gói. Các thành phần cơ bản trong bản đóng gói • Thông tin về sản phẩm (Add/Remove program) • Tổ chức thư mục lưu trữ (Program Files,…) • Components: DLL và ActiveX Control (OCX) • Shortcut • Database file DB Script file DB Sample • Registry • INI file • Web server (IIS) • Windows Service • Tài liệu hướng dẫn (User guide, Admin guide,…) • Bản cài đặt (Setup.exe…)",
        "Summary": "\"Đóng gói sản phẩm bao gồm xây dựng tài liệu hướng dẫn sử dụng và kỹ thuật, cài đặt với dữ liệu thực của khách hàng, và đóng gói chương trình bằng các tiện ích như Install Anywhere, InstallShield. Quá trình đóng gói thường bao gồm tổ chức thư mục, chọn thành phần cài đặt, liệt kê các tập tin DLL, OCX, Database Drivers, Printer Drivers, FONT cần thiết, soạn thảo Readme, INI, liệt kê Utilities Software, logo, tạo file Script, License Key, Demo, File Help, thực hiện đóng gói và viết tài liệu. Bản đóng gói cơ bản chứa thông tin sản phẩm, tổ chức thư mục, các components (DLL, OCX), shortcut, database file, DB script, registry, INI file, web server, Windows Service, tài liệu hướng dẫn và bản cài đặt (Setup.exe).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các ý được trình bày theo một trình tự nhất định, tuy nhiên, việc liệt kê quá nhiều thành phần trong một câu có thể làm giảm tính trôi chảy và gây khó khăn cho người đọc trong việc nắm bắt thông tin một cách nhanh chóng. Ví dụ, câu 'Quá trình đóng gói thường bao gồm tổ chức thư mục, chọn thành phần cài đặt, liệt kê các tập tin DLL, OCX, Database Drivers, Printer Drivers, FONT cần thiết, soạn thảo Readme, INI, liệt kê Utilities Software, logo, tạo file Script, License Key, Demo, File Help, thực hiện đóng gói và viết tài liệu' có thể được chia thành nhiều câu nhỏ để tăng tính mạch lạc."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt có tính liên quan cao, tập trung vào các ý chính của văn bản gốc về quy trình và các thành phần của việc đóng gói sản phẩm. Tuy nhiên, có một số chi tiết nhỏ có thể được lược bỏ để bản tóm tắt trở nên súc tích hơn, ví dụ như việc liệt kê quá chi tiết các loại file (DLL, OCX, Database Drivers, Printer Drivers, FONT)."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và liên quan. Tuy nhiên, để cải thiện hơn nữa, nên tập trung vào việc tăng tính mạch lạc bằng cách chia các câu dài thành các câu ngắn hơn và lược bỏ một số chi tiết không quá quan trọng để bản tóm tắt trở nên súc tích và dễ đọc hơn."
            }
        }
    },
    {
        "Index": "00056",
        "Article": "Trong trường hợp thư mục có chứa thư mục mức dưới hoặc file, việc xoá thư mục sẽ ảnh hưởng tới các thư mục mức dưới và file đó. Nói chung có hai cách giải quyết trong trường hợp này. Một số hệ điều hành như MS-DOS không cho phép xoá thư mục khi thư mục không rỗng. Người dùng phải xoá hết các file và thư mục mức dưới của một thư mục trước khi xoá thư mục đó. Ngược lại, một số hệ điều hành như UNIX, Linux cho phép xoá các thư mục không rỗng. Khi một thư mục bị xoá (bằng lệnh rm), tất cả các các file và thư mục mức dưới chứa trong đó cũng bị xoá theo. Cách này rất tiện lợi, cho phép tiết kiệm thời gian và công sức khi cần xoá số lượng thư mục. Tuy nhiên việc cho phép xoá thư mục không rỗng có thể gây mất mát nhiều file và thư mục con do một lệnh xoá vô ý có thể xoá cả một nhánh lớn của cây thư mục. Người dùng phải hết sức cẩn thận khi sử dụng nhãng lệnh xoá như vậy. Tại mỗi thời điểm, người dùng làm việc với một thư mục gọi là thư mục hiện thời hay thư mục làm việc. Trong quá trình làm việc, người dùng có thể di chuyển sang thư mục khác tức là thay đổi thư mục hiện thời. Việc thay đổi thư mục được thực hiện bằng lời gọi hệ thống tương ứng. Nếu người dùng gõ lệnh đổi thư mục từ bộ dịch lệnh (shell) thì bộ dịch lệnh sẽ gọi lời gọi hệ thống này. Trong trường hợp người dùng truy cập một file mà không thông báo cụ thể thư mục chứa file đó thì file được tìm kiếm trước tiên trong thư mục hiện thời sau đó mở rộng sang các thư mục được quy định trong đường tìm kiếm (search path) như mô tả trong phần thư mục hai mức.",
        "Summary": "Khi xoá thư mục có chứa thư mục con hoặc file, có hai cách giải quyết: một số hệ điều hành như MS-DOS yêu cầu người dùng phải xoá hết các file và thư mục con trước khi xoá thư mục, trong khi UNIX và Linux cho phép xoá thư mục không rỗng và tự động xoá tất cả các thư mục và file bên trong. Tuy nhiên, cách sau có thể gây mất mát dữ liệu nếu lệnh xoá không được sử dụng cẩn thận. Người dùng có thể thay đổi thư mục hiện thời trong quá trình làm việc, và nếu không chỉ định rõ thư mục chứa file, hệ thống sẽ tìm kiếm file trong thư mục hiện thời và các thư mục theo đường tìm kiếm.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các phương pháp xóa thư mục và cách hệ thống tìm kiếm file."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Các ý chính được trình bày rõ ràng và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00057",
        "Article": "Các tham số và giá trị trả về được sử dụng đắc lực nhất trong các phương thức có nhiệm vụ truy nhập dữ liệu của đối tượng. Có hai loại phương thức truy nhập: • Các phương thức đọc dữ liệu của đối tượng và trả về dữ liệu đọc được. Chúng thường được đặt tên là getDữLiệuGìĐó, nên còn được gọi là các phương thức get. • Các phương thức ghi dữ liệu vào các biến thực thể của đối tượng, chúng nhận dữ liệu mới qua các tham số rồi ghi vào các biến liên quan. Chúng thường được đặt tên là setDữLiệuGìĐó, nên còn được gọi là các phương thức set. Ví dụ như trong Hình 5.6 class Cow à Cow String name; int age; name age void setName(String aName) à getName() name = aName; setName() â getAge() String getName() à setAge() return name; â void setAge(int anAge) à age = anAge; â int getAge() à return age; â â Hình 5.6: Lớp Cow với các hàm đọc/ghi Cho đến nay, ta đã lờ đi một trong những nguyên tắc quan trọng nhất của lập trình hướng đối tượng, đó là đóng gói và che giấu thông tin. Nguyên tắc này nói rằng \"Đừng để lộ cấu trúc dữ liệu bên trong\". Trong tất cả các ví dụ từ đầu cuốn sách đến giờ, ta đã để lộ tất cả dữ liệu. 'Để lộ' ở đây có nghĩa là từ bên ngoài lớp có thể dùng một tham chiếu tới đối tượng kèm theo toán tử dấu chấm (.) để truy nhập biến thực thể của đối tượng đó. Ví dụ: theCow.age = 2; Nói cách khác là ta đang cho phép dùng tham chiếu để trực tiếp sửa biến thực thể của đối tượng. Đây là công cụ nguy hiểm nếu đặt trong tay những ai muốn phá hoại hoặc không biết dùng đúng cách. Nó cho phép người ta làm những việc chẳng hạn như cho một đối tượng Cow có tuổi là số âm: 75 theCow.age = -2; Để ngăn chặn nguy cơ này, ta cần cài các phương thức set cho các biến thực thể và tìm cách buộc các đoạn mã khác phải gọi các phương thức set thay vì truy nhập trực tiếp đến dữ liệu. Khi đã đảm bảo được rằng gọi một phương thức set là cách duy nhất để sửa một biến thực thể, ta có thể kiểm tra tính hợp lệ của dữ liệu mới và bảo vệ không cho phép bất cứ ai gán một giá trị không hợp lệ cho biến thực thể đó.",
        "Summary": "Văn bản mô tả cách sử dụng phương thức `get` và `set` trong lập trình hướng đối tượng để truy cập và thao tác dữ liệu của đối tượng, nhấn mạnh tầm quan trọng của đóng gói và che giấu thông tin. Các phương thức `get` trả về giá trị của biến thực thể, trong khi `set` cập nhật giá trị này, cho phép kiểm soát và xác thực dữ liệu trước khi ghi. Việc truy cập trực tiếp vào biến thực thể bị coi là nguy hiểm vì có thể dẫn đến việc gán giá trị không hợp lệ. Do đó, sử dụng phương thức `set` là cách thức an toàn và hiệu quả để bảo vệ tính toàn vẹn dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào mục đích sử dụng của phương thức get/set và tầm quan trọng của việc đóng gói thông tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Tóm tắt đã làm nổi bật được các ý chính và trình bày chúng một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00058",
        "Article": "Cấu trúc bề mặt đĩa : z Ổ đĩa cứng gồm nhiều đĩa quay với vận tốc 5400 đến 7200vòng / phút , trên các bề mặt đĩa là các đầu từ di chuyển để đọc và ghi dữ liệu. https://thuviensach.vn Các đĩa ghi dữ liệu và đầu từ ghi - đọc z Dữ liệu được ghi trên các đường tròn đồng tâm gọi là Track hoặc Cylinder, mỗi Track lại chia thành nhiều cung - gọi là Sector và mỗi cung ghi được 512 Byte dữ liệu . + Track và Sector có được là do các nhà sản xuất đĩa cứng sử dụng một chương trình đặc biệt để định dạng vật lý hay định dạng cấp thấp cho đĩa. Bề mặt của đĩa cứng, tín hiệu ghi trên các đường tròn đồng tâm gọi là Track, mỗi Track được chia làm nhiều Sector z Với đĩa cứng khoảng 10G => có khoảng gần 7000 đường Track trên mỗi bề mặt đĩa và mỗi Track được chia thành khoảng 200 Sector . z Để tăng dung lượng của đĩa thì trong các đĩa cứng ngày nay, các Track ở ngoài được chia thành nhiều Sector hơn và mỗi mặt đĩa cũng được chia thành nhiều Track hơn và như vậy đòi hỏi thiết bị phải có độ chính xác rất cao . 4. Nguyên tắc lưu trữ từ trên đĩa cứng https://thuviensach.vn z Trên bề mặt đĩa người ta phủ một lớp mỏng chất có từ tính, ban đầu các hạt từ tính không có hướng , khi chúng bị ảnh hưởng bởi từ trường của đầu từ lướt qua , các hạt có từ tính được sắp xếp thành các hạt có hướng. z Đầu từ ghi - đọc được cấu tạo bởi một lõi thép nhỏ hình chữ U, một cuộn dây quấn trên lõi thép để đưa dòng điện vào (khi ghi) hay lấy ra (khi đọc), khe hở gọi là khe từ lướt trên bề mặt đĩa với khoảng cách rất gần, bằng 1/10 sợi tóc . Đầu từ ghi - đọc và lớp từ tính trên đĩa z Trong quá trình ghi, tín hiệu điện ở dạng tín hiệu số 0,1 được đưa vào đầu từ ghi lên bề mặt đĩa thành các nam châm rất nhỏ và đảo chiều tuỳ theo tín hiệu đưa vào là 0 hay 1 . z Trong quá trình phát, đầu từ đọc lướt qua bề mặt đĩa dọc theo các đường Track đã được ghi tín hiệu, tại điểm giao nhau của các nam châm có từ trường biến đổi và cảm ứng lên cuộn dây tạo thành một xung điện, xung điện này rất yếu được đưa vào khuếch đại để lấy ra tín hiệu 0,1 ban đầu . Ghi chú : Tín hiệu 0 , 1 là tín hiệu số ( Digital ) - Xem phần Tín hiệu số . Chú ý : z Đĩa cứng được ghi theo nguyên tắc cảm ứng từ , vì vậy nếu ta để các đĩa cứng gần các vật có từ tính mạnh như Nam châm thì có thể dữ liệu trong đĩa cứng sẽ bị hỏng !",
        "Summary": "\"Đĩa cứng gồm nhiều đĩa quay tốc độ cao, dữ liệu được ghi trên các đường tròn đồng tâm (Track/Cylinder) chia thành các cung (Sector), mỗi Sector chứa 512 Byte. Các Track ở ngoài có thể được chia thành nhiều Sector hơn để tăng dung lượng. Dữ liệu được lưu trữ bằng cách từ hóa lớp vật liệu từ tính trên đĩa thông qua đầu từ, tạo ra các nam châm nhỏ biểu diễn bit 0 và 1. Khi đọc, đầu từ cảm nhận sự thay đổi từ trường và tạo ra xung điện để khôi phục dữ liệu ban đầu. Đĩa cứng nhạy cảm với từ trường mạnh bên ngoài, có thể gây mất dữ liệu.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, giúp người đọc dễ dàng nắm bắt thông tin. Các câu liên kết với nhau một cách trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào cấu trúc, nguyên tắc lưu trữ và tính nhạy cảm của đĩa cứng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00059",
        "Article": "Một cách phòng ngừa deadlock là sử dụng thứ tự ưu tiên và cuộn lại quá trình. Với thứ tự ưu tiên, một giao dịch T2 yêu cầu một khóa bị giữ bởi giao dịch T1 , khóa đã cấp cho T1 có thể bị lấy lại và cấp cho T2 , T1 bị cuộn lại. Để điều khiển ưu tiên, ta gán một nhãn thời gian duy nhất cho mỗi giao dịch. Hệ thống sử dụng các nhãn thời gian này để quyết định một giao dịch phải chờ hay cuộn lại. Khóa vẫn được sử dụng để điều khiển tương tranh. Nếu một giao dịch bị cuộn lại, nó vẫn giữ nhãn thời gian cũ của nó khi tái khởi động. Hai sơ đồ phòng ngừa deadlock sử dụng nhãn thời gian khác nhau được đề nghị: \n 1. Sơ đồ Wait-Die dựa trên kỹ thuật không ưu tiên. Khi giao dịch Ti yêu cầu một mục dữ liệu bị chiếm bởi Tj , Ti được phép chờ chỉ nếu nó có nhãn thời gian nhỏ hơn của Tj nếu không Ti bị cuộn lại (die). \n 2. Sơ đồ Wound-Wait dựa trên kỹ thuật ưu tiên. Khi giao dịch Ti yêu cầu một mục dữ liệu hiện đang bị giữ bởi Tj , Ti được phép chờ chỉ nếu nó có nhãn thời gian lớn hơn của Tj , nếu không Tj bị cuộn lại (Wounded). \n Một điều quan trọng là phải đảm bảo rằng, mỗi khi giao dịch bị cuộn lại, nó không bị “chết đói” (starvation) có nghĩa là nó sẽ không bị cuộn lại lần nữa và được phép tiến triển. \n Cả hai sơ đồ Wound-Wait và Wait-Die đều tránh được sự chết đói: tại một thời điểm, có một giao dịch với nhãn thời gian nhỏ nhất. Giao dịch này không thể bị yêu cầu cuộn lại trong cả hai sơ đồ. Do nhãn thời gian luôn tăng và do các giao dịch không được gán nhãn thời gian mới khi chúng bị cuộn lại, một giao dịch bị cuộn lại sẽ có nhãn thời gian nhỏ nhất (vào thời gian sau) và sẽ không bị cuộn lại lần nữa. \n Tuy nhiên, có những khác nhau lớn trong cách thức hoạt động của hai sơ đồ: \n • Trong sơ đồ Wait-Die, một giao dịch già hơn phải chờ một giao dịch trẻ hơn giải phóng mục dữ liệu. Như vậy, giao dịch già hơn có xu hướng bị chờ nhiều hơn. Ngược lại, trong sơ đồ Wound-Wait, một giao dịch già hơn không bao giờ phải chờ một giao dịch trẻ hơn. \n • Trong sơ đồ Wait-Die, nếu một giao dịch Ti chết và bị cuộn lại vì nó đòi hỏi một mục dữ liệu bị giữ bởi giao dịch Tj , khi đó Ti có thể phải tái phát ra cùng dãy các yêu cầu khi nó khởi động lại. Nếu mục dữ liệu vẫn bị chiếm bởi Tj , Ti bị chết lần nữa. Như vậy, Ti có thể bị chết vài lần trước khi nhận được mục dữ liệu cần thiết. Trong sơ đồ Wound-Wait, giao dịch Ti bị thương và bị cuộn lại do Tj yêu cầu mục dữ liệu nó chiếm giữ. Khi Ti khởi động lại, và yêu cầu mục dữ liệu, bây giờ, đang bị Tj giữ, Ti chờ. Như vậy, có ít cuộn lại hơn trong sơ đồ Wound-Wait. \n Một vấn đề nổi trội đối với cả hai sơ đồ là có những cuộn lại không cần thiết vẫn xảy ra.",
        "Summary": "Để phòng ngừa deadlock, một phương pháp là sử dụng thứ tự ưu tiên dựa trên nhãn thời gian duy nhất cho mỗi giao dịch. Hệ thống sử dụng nhãn thời gian này để quyết định giao dịch nào phải chờ hoặc cuộn lại. Có hai sơ đồ chính: Wait-Die (giao dịch trẻ hơn chờ giao dịch già hơn, ngược lại thì cuộn lại) và Wound-Wait (giao dịch già hơn chờ giao dịch trẻ hơn, ngược lại thì cuộn lại). Cả hai sơ đồ đều tránh \"chết đói\" vì giao dịch có nhãn thời gian nhỏ nhất sẽ không bị cuộn lại. Tuy nhiên, Wait-Die khiến giao dịch già hơn chờ nhiều hơn, và có thể bị \"chết\" nhiều lần trước khi nhận được mục dữ liệu. Wound-Wait ít cuộn lại hơn nhưng cả hai sơ đồ đều có thể gây ra cuộn lại không cần thiết.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt được trình bày một cách mạch lạc và logic. Các ý được liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin dễ hiểu. Cách diễn đạt rõ ràng, không gây khó khăn cho người đọc trong việc nắm bắt nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Chỉ những ý chính và quan trọng nhất được giữ lại, trong khi các chi tiết không cần thiết đã được loại bỏ. Bản tóm tắt tập trung vào các khái niệm cốt lõi và so sánh giữa hai sơ đồ phòng ngừa deadlock."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Điểm mạnh của bản tóm tắt là khả năng cô đọng thông tin một cách hiệu quả, đồng thời vẫn giữ được ý nghĩa chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00060",
        "Article": "Bài tập cơ bản Biến, biểu thức và toán tử Bài 1: Chuỗi ký tự nào sau đây không thể là tên biến được? BASICSALARY _basic basic-hra #MEAN group. 422 population in 2006 over time mindovermatter FLOAT hELLO queue. team’svictory Plot # 3 2015_DDay nhiệt van_toc lai suat Bài 2: Chỉ ra biểu thức C/C++ lỗi (nếu có) a) int = 314.562 * 150; b) name = 'Ajay'; c) varchar = '3'; d) 3.14 * r * r * h = vol_of_cyl; e) k = ( a * b ) ( c + ( 2.5a + b ) ( d + e ); f) m_inst = rate of interest * amount in rs; g) si = principal * rateofinterest * numberofyears / 100; h) area = 3.14 * r ** 2; i) volume = 3.14 * r ^ 2 * h; j) k = ( (a * b ) + c ) ( 2.5 * a + b ); k) a = b = 3 = 4; l) count = count + 1; m) date = '2 Mar 04'; Bài 3: Xác định thứ tự thực hiện các phép toán và tính giá trị của biểu thức 27 Chương 3 KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN a) g = big / 2 + big * 4 / big - big + abc / 3; (abc = 2.5, big = 2, giả sử g có kiểu float) b) on = ink * act / 2 + 3 / 2 * act + 2 + tig;(ink = 4,act = 1,tig = 3.2, giả sử on có kiểu int) c) s = qui * add / 4 - 6 / 2 + 2 / 3 * 6 / god;(qui = 4,add = 2,god = 2, giả sử s có kiểu int) d) s = 1 / 3 * a / 4 - 6 / 2 + 2 / 3 * 6 / g; (a = 4, g = 3, giả sử s có kiểu int) Bài 4: Xác định toán hạng cho các phép toán trong biểu thức a) g = 10 / 5 / 2 / 1; b) b = 3 / 2 + 5 * 4 / 3; c) a = b = c = 3 + 4;",
        "Summary": "Bài tập bao gồm các vấn đề về đặt tên biến trong C/C++, xác định lỗi cú pháp trong các biểu thức, tính toán giá trị biểu thức theo thứ tự ưu tiên toán tử và xác định toán hạng. Bài 1 kiểm tra hiểu biết về quy tắc đặt tên biến hợp lệ. Bài 2 tập trung vào việc nhận biết lỗi cú pháp trong các biểu thức C/C++. Bài 3 và 4 yêu cầu tính toán giá trị của các biểu thức số học, bao gồm cả việc áp dụng quy tắc ưu tiên toán tử và hiểu rõ về kiểu dữ liệu số nguyên và số thực.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, giúp người đọc dễ dàng nắm bắt được nội dung chính của bài tập."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của bài tập, bao gồm các vấn đề về tên biến, lỗi cú pháp, tính toán biểu thức và xác định toán hạng, mà không đi vào các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về nội dung của bài tập. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00061",
        "Article": "Hình 4.14. Ví dụ minh hoạ cách loại trừ biến cho trường hợp đơn giản. b) Thuật toán loại trừ biến Ví dụ trên cho thấy nguyên tắc cơ bản của phương pháp loại trừ biến trên một mạng Bayes đơn giản. Ý tưởng là tính toán sẵn và lưu các thành phần lặp lại, sau đó sử dụng các giá trị đã lưu để tiết kiệm số phép tính cần thực hiện theo nguyên tắc quy hoạch động. Tiếp theo, ta sẽ xem xét thuật toán loại trừ biến cho trường hợp tổng quát. Để trình bầy thuật toán, trước hết cần biết khái niệm thừa số và thừa số hoá. Thừa số hoá một phân phối xác suất đồng thời là phân tích xác suất đó thành các thành phần, mỗi thành phần phụ thuộc vào một hoặc một số biến ngẫu nhiên, sao cho tích các thành phần đó là giá trị xác suất đồng thời. Có nhiều cách để thừa số hoá một phân bố xác suất. Như trong ví dụ ở trên, một trong các cách thừa số hoá cho ta các thành phần sau F = {P(A), P(B | A), P(C | B), P(D |C)} Mỗi thành phần sau khi thừa số hoá gọi là một thừa số. Như trong ví dụ trên, ta có P(A), P(B | A) ... P(D | C) là các thừa số. Lưu ý rằng, mỗi thừa số là hàm của một số biến ngẫu nhiên, chẳng hạn P(A) là hàm phụ thuộc vào A, P(D | C) là hàm và phụ thuộc vào D, C. Giá trị của mỗi thừa số là một ma trận, chẳng hạn nếu các biến là nhị phân thì P(A) là ma trận kích thước 2x1, trong khi P(D | C) là ma trận kích thước 2x2 do mỗi biến D và C có thể nhận 2 giá Thuật toán loại trừ biến được thực hiện bằng cách loại trừ dần các biến khỏi biểu thức tính phân bố xác suất đồng thời (từ đây mà có tên gọi của phương pháp là “loại trừ biến”). Việc loại trừ một biến khỏi biểu thức tính xác suất đồng thời được thực hiện bằng cách loại trừ các thừa số chứa biến đó khỏi biểu thức như đã thấy trong ví dụ ở phần trên. Lưu ý rằng, (a)1 1 0 1 0 1 0 0 0 1 1 0 sau khi loại từ một biến, ta được một danh sách các thừa số khác sao cho tích các thừa số đó bằng giá trị xác suất đồng thời nhưng chứa ít biến ngẫu nhiên hơn.",
        "Summary": "b Thuật toán loại trừ biến Ví dụ trên cho thấy nguyên tắc cơ bản của phương pháp loại trừ biến trên một mạng Bayes đơn giản. Giá trị của mỗi thừa số là một ma trận, chẳng hạn nếu các biến là nhị phân thì PA là ma trận kích thước 2x1, trong khi PD C là ma trận kích thước 2x2 do mỗi biến D và C có thể nhận 2 giá Thuật toán loại trừ biến được thực hiện bằng cách loại trừ dần các biến khỏi biểu thức tính phân bố xác suất đồng thời từ đây mà có tên gọi của phương pháp là loại trừ biến.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu có liên kết với nhau, tuy nhiên, việc trích dẫn các câu từ văn bản gốc một cách rời rạc khiến cho tính mạch lạc chưa được tối ưu. Cần có sự chỉnh sửa để các câu văn liên kết chặt chẽ hơn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính liên quan đến thuật toán loại trừ biến. Tuy nhiên, một vài chi tiết như kích thước ma trận có thể được lược bỏ để tăng tính cô đọng cho bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, đảm bảo tính trung thực và liên quan. Tuy nhiên, cần cải thiện tính mạch lạc bằng cách diễn đạt lại các ý chính thay vì chỉ trích dẫn nguyên văn. Ngoài ra, nên lược bỏ một số chi tiết không quá quan trọng để bản tóm tắt ngắn gọn và tập trung hơn."
            }
        }
    },
    {
        "Index": "00062",
        "Article": "Chiều dài gói dữ liệu (datagram length): đây là tổng độ dài tính theo byte của gói dữ liệu IP kể cả phần tiêu đề lẫn phần dữ liệu. Độ dài trường này là 16 bit nên về lý thuyết kích thước tối đa của gói dữ liệu IP là 65.535 byte. Tuy nhiên, hiếm khi kích thước gói dữ liệu vượt quá 1500 bytes và thường giới hạn là 576 bytes. - Định danh, cờ và vị trí phân đoạn (Identifer, Flags, Fragmention Offset): 3 trường này được sử dụng khi phân mảnh gói dữ liệu IP, phiên bản mới IPv6 không cho phép phân mảnh gói dữ liệu tại các thiết bị định tuyến. - Thời gian sống (Time-To-live-TTL): Trường thời gian tồn tại TTL được sử dụng để bảo đảm gói dữ liệu không được lưu chuyển mãi mãi để tránh trường hợp một gói tin có thể lặp theo vòng trong mạng. Mỗi lần gói tin đi qua một Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 148 thiết bị định tuyến sẽ bị giảm đi một (- 1), nếu trường TTL bằng 0 thì thiết bị định tuyến sẽ loại bỏ gói tin. - Giao thức tầng trên (Upper Protocol): Trường này chỉ được sử dụng khi gói dữ liệu IP đến được máy tính đích, giá trị của trường này xác định giao thức tầng vận tải ở máy tính đích sẽ nhận được phần dữ liệu trong gói dữ liệu IP. Ví dụ giá trị 6 có ý nghĩa phần dữ liệu cần chuyển tới thực thể TCP, giá trị 17 có ý nghĩa phần dữ liệu phải chuyển đến thực thể UDP, RFC 1700 liệt kê các giá trị này. Vai trò của trường giao thức trong gói dữ liệu IP tương tự vai trò trường số hiệu cổng trong đoạn tin của tầng vận tải. Trường giao thức được xem là điểm nối giữa tầng mạng và tầng vận tải cũng như trường số hiệu cổng là điểm nối giữa tầng vận tải với ứng dụng cụ thể.",
        "Summary": "\"Gói dữ liệu IP bao gồm các trường quan trọng sau: **Chiều dài gói dữ liệu** (tối đa 65.535 byte, thường dưới 1500 byte); **Định danh, cờ và vị trí phân đoạn** (dùng khi phân mảnh, không còn được dùng trong IPv6); **Thời gian sống - TTL** (giảm mỗi khi qua router, tránh lặp vô hạn); **Giao thức tầng trên** (xác định giao thức tầng vận tải đích nhận dữ liệu, tương tự vai trò số hiệu cổng).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và logic, có sự liên kết chặt chẽ giữa các phần. Cách diễn đạt dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các trường quan trọng trong gói dữ liệu IP và chức năng của chúng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Đã làm nổi bật được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm cần cải thiện."
            }
        }
    },
    {
        "Index": "00063",
        "Article": "Bài tập 1.1: Nêu các đặc điểm của ngôn ngữ lập trình Java?Java là một ngôn ngữ lập trình hướng đối tượng, được phát triển bởi Sun Microsystems (nay thuộc Oracle). Một số đặc điểm nổi bật của Java bao gồm:Độc lập nền tảng: Java biên dịch mã nguồn thành bytecode, chạy trên mọi hệ điều hành có Java Virtual Machine (JVM).Hướng đối tượng: Java hỗ trợ lập trình theo mô hình đối tượng (OOP), giúp quản lý và tái sử dụng mã hiệu quả hơn.Bảo mật cao: Nhờ kiến trúc bảo vệ bằng JVM, Java cung cấp môi trường an toàn cho chạy các chương trình, đặc biệt là các ứng dụng mạng.Tự động quản lý bộ nhớ: Java có cơ chế Garbage Collector giúp giải phóng bộ nhớ không còn được sử dụng.Thư viện phong phú: Java cung cấp nhiều thư viện dựng sẵn phục vụ cho các tác vụ phổ biến như xử lý chuỗi, mạng, cơ sở dữ liệu, GUI, v.v.Bài tập 1.2: Nêu vai trò của cấu trúc dữ liệu và giải thuật?Cấu trúc dữ liệu và giải thuật đóng vai trò then chốt trong lập trình và phát triển phần mềm.Cấu trúc dữ liệu giúp tổ chức và lưu trữ dữ liệu một cách hiệu quả, đảm bảo truy xuất và xử lý dữ liệu nhanh chóng. Ví dụ như mảng, danh sách liên kết, ngăn xếp (stack), hàng đợi (queue), cây (tree), đồ thị (graph), v.v.Giải thuật là tập hợp các bước rõ ràng để giải quyết một bài toán cụ thể. Việc lựa chọn giải thuật phù hợp giúp cải thiện hiệu suất chương trình. Các giải thuật như sắp xếp, tìm kiếm, duyệt đồ thị, quy hoạch động… là nền tảng cho nhiều ứng dụng phức tạp.Bài tập 1.3: Vẽ lưu đồ thuật toán nhập vào số nguyên n, xuất ra màn hình từ 1 đến n.Phân tích:Nhập số nguyên nKhởi tạo biến đếm i = 1Lặp: nếu i <= n thì in i, tăng i lên 1 và lặp lạiKết thúc khi i > nBài tập 1.4: Vẽ lưu đồ thuật toán giải phương trình bậc 2?Phân tích:Nhập a, b, cNếu a == 0, chuyển về phương trình bậc nhất bx + c = 0Nếu a ≠ 0:• Tính Δ = b² - 4ac• Nếu Δ < 0 → vô nghiệm• Nếu Δ = 0 → nghiệm kép x = -b/2a• Nếu Δ > 0 → hai nghiệm phân biệt x1, x2Xuất nghiệmBài tập 1.5: Vẽ lưu đồ thuật toán tính tổng:Phân tích:Nhập vào một số nguyên nKhởi tạo tong = 0, i = 1Lặp: cộng i vào tong, tăng i lên 1Khi i > n thì dừngIn ra tổng",
        "Summary": "Bài viết trình bày các đặc điểm chính của Java: hướng đối tượng, độc lập nền tảng nhờ JVM, bảo mật cao, tự động quản lý bộ nhớ và thư viện phong phú. Ngoài ra, bài viết nhấn mạnh vai trò quan trọng của cấu trúc dữ liệu (mảng, danh sách liên kết, cây, đồ thị,...) và giải thuật (sắp xếp, tìm kiếm,...) trong lập trình. Cuối cùng, bài viết đề cập đến việc thiết kế lưu đồ thuật toán cho các bài toán cơ bản như in số từ 1 đến n, giải phương trình bậc hai và tính tổng dãy số.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các đặc điểm của Java, vai trò của cấu trúc dữ liệu và giải thuật, cũng như việc thiết kế lưu đồ thuật toán, đúng như nội dung chính của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00064",
        "Article": "Hướng dẫn cách đăng ký domain Khi bạn muốn đăng ký domain là bạn sẽ đăng ký tên miền bạn muốn sử dụng với một tổ chức được gọi là InterNIC thông qua một nhà đại lý thường được gọi là Registrar. Ví dụ bạn muốn trang web của bạn tên là “www.trangweb.com” thì bạn sẽ phải đến một đại lý, trả chi phí đăng ký và dịch vụ thường thì nằm trong khoảng $10 – $35 tuỳ theo domain mà bạn sẽ đăng ký. Sau khi trả tiền xong xuôi, người ta sẽ cho phép bạn sở hữu tên miền đó trong thời hạn một năm và bạn cần phải gia hạn cho domain này hàng năm. Bạn có thể chọn mua domain đến tận 5 năm nếu bạn muốn. Hiện nay rất nhiều dịch vụ cung cấp host đều khuyến mãi domain free trong vòng từ 1 đến 2 năm, từ những năm sau là bạn phải trả tiền. Tuy nhiên, theo kinh nghiệm của tôi, bạn nên tự đăng ký domain riêng cho mình và không nên đi chung với nơi cung cấp dịch vụ host cho bạn. Bằng cách tự đăng ký, bạn sẽ được là chủ sở hữu, người quản lý và hỗ trợ ký thuật cho domain đó. Khi đã là chủ sở hữu duy nhất của domain đó, bạn được toàn quyền quyết định về “vận mạng” của domain này mà không sợ bị ai chi phối. Trước đây khi chưa biết nhiều về web, lần đầu tiên tôi đi đăng ký domain với một nhà cung cấp của Việt Nam. Tôi mua cả host và domain của họ. Sau này mới biết rằng vì họ sợ mình chuyển domain đó sang đại lý khác, nên họ lock domain đó lại. Muốn thay đổi gì phải email cho họ, rất mất thời gian và không tiện lợi. Quay lại vấn đề ở trên, nếu vì bạn muốn tiết kiệm chút tiền ban đầu và để dịch vụ host mua domain cho bạn. Và nếu dịch vụ host đó lại để tên chủ sở hữu chính là họ thì sau này bạn có thể gặp rắc rối nếu trang web của bạn ăn lên làm ra. Lúc đó người ta sẽ bắt bạn trả tiền để được phép “thuê” domain của họ. Tiếp theo là những thông tin khác như Administrative và Technical contact. Tuy nó không thực sự quan trọng như là Owner, nhưng nếu bạn muốn chuyển domain ra khỏi host, bạn cần sự đồng ý của Administrative Contact. Nếu người này không liên lạc được thì Technical Contact sẽ được sử dụng. Domain luôn được đăng ký với tốc độ chóng mặt, do vậy bạn cần lẹ tay khi đăng ký domain. Nếu bạn nghĩ ra một tên nào đó phù hợp và hay, bạn nên đăng ký ngay trước khi bị người khác đăng ký mất. Tôi cũng có một kinh nghiệm để đời về việc này khi chỉ do dự có mấy phút mà tôi bị mất một cái domain .com và cuối cùng phải xài .net.",
        "Summary": "Để đăng ký domain, bạn cần liên hệ với Registrar (đại lý) và trả phí đăng ký (thường từ $10-$35/năm). Bạn nên tự đăng ký domain để làm chủ sở hữu, tránh rắc rối về sau nếu website phát triển. Cần chú ý đến thông tin Owner (chủ sở hữu), Administrative và Technical contact. Domain được đăng ký rất nhanh, nên đăng ký ngay khi tìm được tên phù hợp.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và dễ hiểu, tạo thành một dòng chảy thông tin liên tục và có ý nghĩa."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và súc tích về văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00065",
        "Article": "Mô hình OSI là mô hình tham chiếu được ISO xây dựng nhằm tạo một chuẩn phục vụ việc nối kết các hệ thống mở. Tuy nhiên mô hình OSI chỉ dừng lại ở mức độ lý thuyết, trong thực tế mô hình TCP/IP đang được sử dụng rộng rãi nhất hiện nay và còn gọi là mô hình Internet, hầu hết tất cả các hệ điều hành đều có cài đặt bộ giao thức TCP/IP. Bộ giao thức này được đặt tên theo hai giao Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 27 thức chính của nó là giao thức điều khiển truyền (TCP - Transmission Control Protocol) và giao thức liên mạng (IP - Internet protocol). Về mặt lịch sử, mô hình TCP/IP ra đời trước khi có mô hình OSI. Giống như mô hình OSI, mô hình cũng được phân thành bốn tầng, mỗi tầng gồm bộ giao thức đảm nhiệm các chức năng riêng biệt. Tuy số lượng tầng ít hơn, nhưng mô hình TCP/IP vẫn phải đảm nhiệm đầy đủ các chức năng đã nêu trong mô hình OSI. Mô hình TCP/IP chia theo 4 tầng: truy nhập mạng, mạng, vận tải và ứng dụng. Mô hình OSI Mô hình TCP/IP Tầng ứng dụng Tầng trình diễn Tầng phiên Tầng ứng dụng Tầng vận tải Tầng vận tải Tầng mạng Tầng Internet Tầng liên kết dữ liệu Tầng vật lý Tầng truy nhập mạng Hình 2.7 Các tầng trong bộ giao thức TCP/IP Mô hình TCP/IP là mô hình giao thức cới các tiêu chuẩn mở, các qui định chuẩn và các giao thức trên diễn đàn công khai và tài liệu của chúng được ghi trong các văn bản gọi là yêu cầu dẫn giải RFC (Requests for Comments). Các RFC bao gồm các đặc tả chính thức về các giao thức truyền dữ liệu và các nguồn mô tả việc sử dụng các giao thức. Các văn bản này cũng chứa các tài liệu kỹ thuật và tổ chức mạng Internet, bao gồm các đặc tả kỹ thuật và chính sách do ủy ban công nghệ Internet (IETF - Internet Engineering Task Force ) soạn thảo. Mô hình TCP/IP mô tả tính năng của các giao thức được cài đặt trên bên máy gửi lẫn máy nhận, chúng tương tác với nhau để phân phát thông tin của các ứng dụng đầu cuối đến đầu cuối, quá trình được thực hiện qua bảy bước: - Tạo dữ liệu ở tầng ứng dụng bên gửi. - Phân đoạn và đóng gói dữ liệu lớp ứng dụng sau đó chuyển xuống tầng dưới. - Chuyển đổi dữ liệu và đưa tới môi trường truyền dẫn. - Vận chuyển dữ liệu qua các mạng, đó là môi trường truyền dẫn và các thiết bị trung chuyển. - Nhận dữ liệu từ mạng - Bóc tách và tập hợp dữ liệu - Chuyển dữ liệu lên tầng ứng dụng của bên nhận. Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 28 Khuôn dạng dữ liệu trên mỗi tầng gọi là đơn vị dữ liệu của giao thức (PDU - Protocol Data Unit). Khi dữ liệu của ứng dụng được chuyển xuống ngăn xếp giao thức để truyền qua môi trường mạng, tại mỗi tầng thông tin điều khiển sẽ được thêm vào dữ liệu của tầng trên, quá trình này gọi là đóng gói dữ liệu. Đơn vị dữ liệu PDU trên mỗi tầng có tên gọi khác nhau: tầng ứng dụng gọi chung là dữ liệu, tầng vận tải gọi là đoạn (Segment), tầng Intetnet gọi là gói (Packet) và tầng truy nhập mạng gọi là khung (Frame).",
        "Summary": "Mô hình OSI là một chuẩn lý thuyết cho việc kết nối các hệ thống, nhưng mô hình TCP/IP (mô hình Internet) mới là mô hình được sử dụng rộng rãi, với bộ giao thức TCP/IP được cài đặt trên hầu hết các hệ điều hành. Mô hình TCP/IP, ra đời trước OSI, gồm bốn tầng: truy nhập mạng, mạng (Internet), vận tải và ứng dụng, đảm nhiệm đầy đủ các chức năng của mô hình OSI. Các tiêu chuẩn và giao thức của TCP/IP được công bố công khai trong các RFC. Quá trình truyền dữ liệu sử dụng TCP/IP bao gồm tạo dữ liệu, phân đoạn và đóng gói, chuyển đổi và vận chuyển dữ liệu qua mạng, sau đó nhận, bóc tách và chuyển dữ liệu lên tầng ứng dụng ở bên nhận. Dữ liệu trên mỗi tầng được gọi là đơn vị dữ liệu giao thức (PDU), với tên gọi khác nhau tùy theo tầng: dữ liệu (ứng dụng), đoạn (vận tải), gói (Internet) và khung (truy nhập mạng). Quá trình thêm thông tin điều khiển vào dữ liệu khi truyền qua các tầng được gọi là đóng gói dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực, mọi thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc, các ý được trình bày một cách rõ ràng và logic. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan, chỉ tập trung vào các ý chính và quan trọng của văn bản gốc. Không có chi tiết nào thừa hoặc không liên quan được đưa vào."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00066",
        "Article": "Có thể nói mật mã là con đẻ của toán học nên sự phát triển của mật mã đi liền với sự phát triển của toán học. Tuy nhiên, do nhiều giải thuật mật mã đòi hỏi khối lượng tính toán lớn nên mật mã chỉ thực sự phát triển mạnh cùng với sự ra đời và phát triển của máy tính điện tử. Sau đây là một số mốc trong sự phát triển của mật mã và ứng dụng mật mã: - Các kỹ thuật mã hoá thô sơ đã được người cổ Ai cập sử dụng cách đây 4000 năm. - Người cổ Hy lạp, Ấn độ cũng đã sử dụng mã hoá cách đây hàng ngàn năm. - Các kỹ thuật mã hoá chỉ thực sự phát triển mạnh từ thế kỷ 1800 nhờ công cụ toán học, và phát triển vượt bậc trong thế kỷ 20 nhờ sự phát triển của máy tính và ngành công nghệ thông tin. - Trong chiến tranh thế giới thứ I và II, các kỹ thuật mã hóa được sử dụng rộng rãi trong liên lạc quân sự sử dụng sóng vô tuyến. Quân đội các nước đã sử dụng các công cụ phá mã, thám mã để giải mã các thông điệp của quân địch. - Năm 1976 chuẩn mã hóa DES (Data Encryption Standard) được Cơ quan mật vụ Hoa Kỳ (NSA – National Security Agency) thừa nhận và sử dụng rộng rãi. - Năm 1976, hai nhà khoa học Whitman Diffie và Martin Hellman đã đưa ra khái niệm mã hóa khóa bất đối xứng (Asymmetric key cryptography), hay mã hóa khóa công khai (Public key cryptography). Điều này đã đem đến những thay đổi lớn trong kỹ thuật mật mã. Theo đó, các hệ mã hóa khóa công khai bắt đầu được sử dụng rộng rãi nhờ khả năng hỗ trợ trao đổi khóa dễ dàng hơn trong khi các hệ mã hóa khóa bí mật gặp khó khăn trong quản lý và trao đổi khóa, đặc biệt khi số lượng người dùng lớn. - Năm 1977, ba nhà khoa học Ronald Rivest, Adi Shamir, và Leonard Adleman giới thiệu giải thuật mã hóa khóa công khai RSA. Từ đó, RSA trở thành giải thuật mã hóa khóa công khai được sử dụng rộng rãi nhất do RSA có thể vừa được sử dụng để mã hóa thông tin và sử dụng trong chữ ký số. - Năm 1991, phiên bản đầu tiên của chuẩn PGP (Pretty Good Privacy) ra đời. - Năm 2001, chuẩn mã hóa AES (Advanced Encryption Standard) được thừa nhận và ứng dụng rộng rãi.",
        "Summary": "Mật mã phát triển cùng với toán học và bùng nổ nhờ sự ra đời của máy tính. Các mốc quan trọng gồm: kỹ thuật mã hóa thô sơ từ 4000 năm trước, sự phát triển mạnh trong thế kỷ 20 nhờ công nghệ thông tin, chuẩn mã hóa DES năm 1976, khái niệm mã hóa khóa công khai của Diffie-Hellman năm 1976, giải thuật RSA năm 1977, chuẩn PGP năm 1991 và chuẩn AES năm 2001.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, theo trình tự thời gian phát triển của mật mã. Câu mở đầu tóm tắt ý chính, sau đó liệt kê các mốc quan trọng một cách có hệ thống."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và các mốc thời gian quan trọng trong sự phát triển của mật mã, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về sự phát triển của mật mã một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00067",
        "Article": "Ví dụ 7-1. Viết chương trình liệt kê các số nguyên tố từ 1 tới N, với N là một số nguyên dương, sử dụng kỹ thuật lập trình RMI. Phương thức kiểm tra số nguyên tố được triệu gọi từ xa. Bước 1: Tạo 2 project RMI_Prime_Client và RMI_Prime_Server. 93 Bước 2: Trong project RMI_Prime_Server tạo một package đặt tên là Core. Trong package này tạo một interface đặt tên là PrimeInterface như sau: public interface PrimeInterface extends Remoteà public boolean isPrime(int x) throws RemoteException; â Chú ý rằng trong kỹ thuật lập trình RMI các Interface phải kế thừa lớp Remote, các phương thức của nó phải throws RemoteException. Phương thức isPrime(int x) dùng để kiểm tra một số x có phải là số nguyên tố hay không. Phương thức này chưa được hiện thực mà mới chỉ khai báo. Sao chép package Core sang project RMI_Prime_Client (bao gồm cả PrimeInterface). Bước 3: Hiện thực PrimeInterface phía Server. Trong project RMI_Prime_Server tạo một package mới đặt tên là RMI. Trong package này tạo một lớp mới đặt tên là Prime. Hiện thực hóa interface trong lớp này như sau: public class Prime extends UnicastRemoteObject implements PrimeInterfaceà //Constructor public Prime() throws RemoteException à â @Override public boolean isPrime(int x) throws RemoteException à for (int i = 2; i <= Math.sqrt(x); i++) à if (x%i == 0) à return false; â â return true; â â Bước 4: Lập trình cho Server. Trong package RMI tạo class đặt tên là Server. Chúng ta tạo một Registry trên cổng bất kỳ (chẳng hạn 3210) rồi ràng buộc (bind) một PrimeService cho một đối tượng thuộc lớp Prime trên đó. public class Server à private final int PORT = 3210; public static void main(String[] args) à new Server().run(); â public void run() à try à Registry reg = LocateRegistry.createRegistry(PORT); reg.rebind(\"PrimeService\", new Prime()); System.out.println(\"Máy chủ đang chạy...\"); â catch (RemoteException ex) à 94 System.out.println(\"Không thể khởi chạy máy chủ!!!\"); â â â Bước 5: Lập trình cho Client. Trong project RMI_Prime_Client tạo một package đặt tên là RMI. Trong package này tạo một JFrame Form đặt tên là Client. Thiết kế giao diện cho Client như sau: Hình 7.4: Thiết kế giao diện liệt kê số nguyên tố Lập trình cho sự kiện người dùng nhấp chuột vào nút Lấy kết quả như sau: private void btGetActionPerformed(java.awt.event.ActionEvent evt) à try à String host = tfHost.getText(); int port = Integer.parseInt(tfPort.getText()); int max = Integer.parseInt(tfMax.getText()); taResults.setText(\"\"); Registry reg = LocateRegistry.getRegistry(host, port); NumberInterface prime = (NumberInterface)reg.lookup(\"PrimeService\"); int count = 0; for (int i = 2; i <= max; i++) à if (prime.isPrime(i)) à taResults.append(i + \" \"); count++; â if (count == 10) à taResults.append(\"\\n\"); count = 0; â â â catch (RemoteException ex) à JOptionPane.showMessageDialog(null, \"Không kết nối được tới máy chủ!!!\", \"Lỗi\", 0); 95 â catch (NumberFormatException ex) à JOptionPane.showMessageDialog(null, \"Giá trị lớn nhất phải là số nguyên!!!\", \"Lỗi\", 0); â catch (NotBoundException ex) à JOptionPane.showMessageDialog(null, \"Không tìm thấy dịch vụ!!!\", \"Lỗi\", 0); â â Chạy Server trước, sau đó chạy Client. Trong form xuất hiện, nhập giá trị lớn nhất bất kỳ, giả sử là 500. Nhấn nút Lấy kết quả, chúng ta nhận được như hình bên dưới: Hình 7.5: Kết quả liệt kê số nguyên tố với máy chủ RMI",
        "Summary": "Ví dụ này minh họa việc sử dụng RMI (Remote Method Invocation) trong Java để liệt kê số nguyên tố. Ứng dụng bao gồm một server cung cấp phương thức `isPrime()` để kiểm tra số nguyên tố thông qua giao diện `PrimeInterface`, và một client yêu cầu server kiểm tra các số từ 1 đến N, hiển thị kết quả lên giao diện người dùng. Server sử dụng `LocateRegistry` để tạo registry và ràng buộc đối tượng `Prime` thực hiện `PrimeInterface`. Client kết nối đến server thông qua registry, gọi phương thức `isPrime()` từ xa và hiển thị danh sách số nguyên tố. Quá trình xử lý bao gồm việc tạo hai project, hiện thực giao diện và lớp, và thiết lập kết nối client-server thông qua RMI.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất để người đọc có thể hiểu được mục đích và cách thức hoạt động của chương trình RMI liệt kê số nguyên tố."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về ví dụ RMI liệt kê số nguyên tố. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00068",
        "Article": "Thành phần này được gọi bằng nhiều tên khác nhau như bộ dịch lệnh (command interpreter) hoặc vỏ (shell). Thực chất, đây là giao diện giữa người dùng với hệ điều hành và cần phân biệt với các lời gọi hệ thống (system calls), vốn là giao diện giữa các chương trình và hệ điều hành. Bộ dịch lệnh hay vỏ có nhiệm vụ nhận lệnh từ người dùng và thực hiện các lệnh này, có thể bằng cách sử dụng dịch vụ do các phần khác của hệ điều hành cung cấp. Một số bộ dịch lệnh phổ biến có thể kể đến như cmd.exe của Windows và bash của Linux. Người dùng nhập các lệnh trực tiếp dưới dạng văn bản, với số lượng lệnh có thể từ vài chục đến hàng trăm, bao gồm cả các lệnh thông dụng như liệt kê thư mục (dir, ls), sao chép tệp tin (copy), cũng như các lệnh nâng cao để thiết lập cấu hình mạng hoặc quản lý hệ thống. Trong các hệ điều hành hiện đại, bộ dịch lệnh truyền thống thường được thay thế bằng các hệ giao diện đồ họa. Thay vì nhập lệnh dưới dạng văn bản, người dùng có thể thao tác trực quan với các đối tượng đồ họa như cửa sổ, biểu tượng và menu. Điều này giúp cải thiện trải nghiệm người dùng, giảm bớt yêu cầu về kiến thức kỹ thuật và giúp hệ thống trở nên dễ sử dụng hơn. Một số giao diện đồ họa phổ biến có thể kể đến như Windows Explorer của Windows hoặc X Windows của Linux. Các giao diện đồ họa không chỉ cung cấp cách thức tương tác tiện lợi mà còn tích hợp nhiều tính năng mở rộng như kéo thả tệp tin, hiển thị biểu đồ hệ thống và tùy chỉnh môi trường làm việc. Bên cạnh đó, một số hệ điều hành vẫn duy trì cả hai dạng giao diện: giao diện dòng lệnh dành cho những người dùng có kinh nghiệm và giao diện đồ họa cho người dùng phổ thông. Ví dụ, trên hệ điều hành Linux, người dùng có thể sử dụng giao diện đồ họa như GNOME hoặc KDE, nhưng vẫn có thể truy cập terminal để sử dụng bash hoặc zsh. Tương tự, Windows cung cấp giao diện đồ họa Windows Explorer nhưng cũng hỗ trợ PowerShell và Command Prompt để thực hiện các tác vụ hệ thống một cách linh hoạt. Nhờ đó, hệ điều hành có thể phục vụ nhiều nhóm người dùng với nhu cầu và trình độ khác nhau.",
        "Summary": "Bộ dịch lệnh (shell) là giao diện giữa người dùng và hệ điều hành, nhận và thực thi lệnh, với các ví dụ như cmd.exe trên Windows và bash trên Linux. Trong các hệ điều hành hiện đại, giao diện đồ họa như Windows Explorer hoặc GNOME thay thế giao diện dòng lệnh truyền thống, nhưng vẫn duy trì cả hai dạng giao diện để phục vụ người dùng phổ thông và người dùng có kinh nghiệm.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic. Câu mở đầu giới thiệu khái niệm, tiếp theo là ví dụ và cuối cùng là sự thay đổi trong hệ điều hành hiện đại, tạo thành một dòng chảy thông tin dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, ví dụ và sự thay đổi của giao diện người dùng trong hệ điều hành."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Bản tóm tắt đã làm nổi bật được các ý chính của văn bản gốc một cách hiệu quả. Không có đề xuất cải thiện nào."
            }
        }
    },
    {
        "Index": "00069",
        "Article": "Dò tìm điểm bất thường Ngoài các ứng dụng về nén và phân loại, PCA còn được sử dụng trong nhiều lĩnh vực khác. Dò tìm điểm bất thường (abnormal detection hoặc outlier detection) là một trong số đó [SCSC03, LCD04]. 286 Machine Learning cơ bản https://thuviensach.vn Chương 21. Phân tích thành phần chính u2 u1 Hình 21.8. PCA cho bài toán dò tìm điểm bất thường. Giả sử các sự kiện bình thường chiếm đa số và nằm gần một không gian con nào đó. Khi đó, nếu làm PCA trên toàn bộ dữ liệu, không gian con thu được gần với không gian con của tập các sự kiện bình thường. Lúc này, các điểm hình tròn to đậm hơn có thể được coi là các sự kiện bất thường vì chúng nằm xa không gian con chính. Ý tưởng cơ bản là giả sử tồn tại một không gian con mà các sự kiện bình thường nằm gần trong khi các sự kiện bất thường nằm xa không gian con đó. Hơn nữa, số sự kiện bất thường có một tỉ lệ nhỏ. Như vậy, PCA có thể được sử dụng trên toàn bộ dữ liệu để tìm ra các thành phần chính, từ đó suy ra không gian con mà các điểm bình thường nằm gần. Việc xác định một điểm là bình thường hay bất thường được xác định bằng cách đo khoảng cách từ điểm đó tới không gian con tìm được. Hình 21.8 minh hoạ cho việc xác định các sự kiện bất thường bằng PCA. 21.7. Thảo luận • PCA là phương pháp giảm chiều dữ liệu dựa trên việc tối đa lượng thông tin được giữ lại. Lượng thông tin được giữ lại được đo bằng tổng các phương sai trên mỗi thành phần của dữ liệu. Lượng dữ liệu sẽ được giữ lại nhiều nhất khi các chiều dữ liệu còn lại tương ứng với các vector riêng của trị riêng lớn nhất của ma trận hiệp phương sai. • Với các bài toán quy mô lớn, đôi khi việc tính toán trên toàn bộ dữ liệu là không khả thi vì vấn đề bộ nhớ. Giải pháp là thực hiện PCA lần đầu trên một tập con dữ liệu vừa với bộ nhớ, sau đó lấy một tập con khác để từ từ (incrementally) cập nhật nghiệm của PCA tới khi hội tụ. Ý tưởng này khá giống với mini-batch gradient descent, và được gọi là incremental PCA [ZYK06]. • Ngoài ra, còn rất nhiều hướng mở rộng của PCA, bạn đọc có thể tìm kiếm theo từ khoá: Sparse PCA [dGJL05], Kernel PCA [MSS+99], Robust PCA [CLMW11].",
        "Summary": "\"PCA được ứng dụng trong dò tìm điểm bất thường, dựa trên giả định rằng các sự kiện bình thường chiếm đa số và nằm gần một không gian con. PCA được thực hiện trên toàn bộ dữ liệu để tìm các thành phần chính, từ đó xác định không gian con chứa các điểm bình thường. Điểm bất thường được xác định bằng cách đo khoảng cách từ điểm đó đến không gian con này. Với dữ liệu lớn, có thể sử dụng incremental PCA để cập nhật nghiệm PCA một cách tuần tự. Ngoài ra, còn có các mở rộng khác của PCA như Sparse PCA, Kernel PCA và Robust PCA.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về ứng dụng của PCA trong dò tìm điểm bất thường và các phương pháp liên quan. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00070",
        "Article": "Các thông số RAM Giải thích DDR 512MB bus 400 Kingston Thanh DDRam dung lượng 512MB / tốc độ Bus 400MHz / hãng Kingston DDR II 256MB bus 533 SamSung, KingMax DDRII 256MB / tốc độ Bus 533MHz / hãng Samsung DDRII có tốc độ từ 533 MHz trở lên và chúng không thay thế cho DDR được vì có điện áp khác nhau 4. Chuẩn bị thiết bị cho một bộ máy tính Một bộ máy tính tối thiểu cần những thiết bị sau 1. Case ( Hộp máy ) Case là vỏ máy, hãy chọn case sao cho đảm bảo được độ thoáng mát cho máy, bộ nguồn thường đi theo case hoặc bán rời, hiện nay ta nên dùng nguồn có công suất > = 350W https://thuviensach.vn 2. Mainboard Mainboard là thiết bị quan trọng nhất mà bạn cần quan tâm, Mainboard nó quyết định trực tiếp đến tốc độ và độ bền của máy, nên chọn mainboard của các hãng uy tín như Intel, Gigaby, Asus, và một số hãng khác và có sử dụng chipset của Intel Khi chọn Mainboard cần quan tâm đến Socket và FSB của CPU và Bus của RAM 3. CPU Phải chọn CPU thích hợp với Mainboard mà bạn đã chọn và CPU đó phải có tốc độ đảm bảo với yêu cầu công việc của khách hàng . https://thuviensach.vn 4. RAM Bạn phải chọ RAM có dung lượng đảm bảo cho yêu cầu công việc của khách hàng, còn tốc độ Bus thì phụ thuộc vào Bus của CPU 5. Card Video ( Nếu Mainboard chưa có ) Nếu như Mainboard chưa có Card Video on board thì bạn cần phải lắp thêm Card Video rời, dung lượng RAM trên Card video càng lớn thì cho phép bạn xử lý được các bức ảnh đẹp hơn và khi chơi Game ảnh không bị giật , còn tốc độ bao nhiêu \"x\" của Card phải phụ thuộc vào Mainboard 6. Ổ cứng HDD Bạn có thể mua ổ cứng từ 10GB trở lên là máy đã có thể chạy bình thường với Win XP, tuy nhiên bạn nên chọn dung lượng ổ gấp 2 lần dung lượng bạn sẽ sử dụng là tốt nhất, không nên dùng ổ quá lớn trong khi dung lượng sử dụng quá ít .",
        "Summary": "Bản tóm tắt:\n  \n  Bài viết liệt kê các thông số và thiết bị cần thiết cho một bộ máy tính. Về RAM, các thông số quan trọng là loại (DDR, DDRII), dung lượng (ví dụ: 512MB, 256MB), tốc độ Bus (ví dụ: 400MHz, 533MHz) và hãng sản xuất (ví dụ: Kingston, Samsung). Các thiết bị tối thiểu cho máy tính bao gồm: Case (chọn loại thoáng mát, nguồn >= 350W), Mainboard (chọn hãng uy tín như Intel, Gigabyte, Asus, chú ý Socket, FSB của CPU và Bus của RAM), CPU (phù hợp với Mainboard và đáp ứng yêu cầu công việc), RAM (dung lượng và Bus phù hợp), Card Video (nếu Mainboard không có card onboard, chọn dung lượng phù hợp) và Ổ cứng HDD (dung lượng từ 10GB trở lên, nên gấp đôi dung lượng dự kiến sử dụng).",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến nội dung chính của văn bản gốc. Các chi tiết được chọn lọc kỹ càng, tập trung vào những thông tin quan trọng nhất về thông số RAM và các thiết bị cần thiết cho một bộ máy tính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ về nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00071",
        "Article": "6.2.5. Khung pháp lý về thương mại điện tử của APEC Đứng trước sự phát triển không ngừng của thương mại điện tử, APEC cũng đang từng bước tiến hành ứng dụng thương mại điện tử. Tháng 11/1997, tại cuộc họp ở Vancouver, APEC đã vạch ra chương trình công tác về thương mại điện tử cho khu vực và thành lập “nhóm công tác chuyên trách về thương mại điện tử” do Singapore và Australia đồng chủ tịch. Mục tiêu là làm cho các nước thành viên hiểu rõ về thương mại điện tử, các hoạt động của nó, triển khai dần vào việc ứng dụng trong từng nước và giữa các nước thành viên trong khu vực. Tháng 11/1998, APEC tiến hành “chương trình hành động về thương mại điện tử” với các nội dung chủ yếu sau: - Tập trung nỗ lực phát triển thương mại điện tử ở các doanh nghiệp có điều kiện, có hiểu biết về thương mại điện tử. - Nâng cao vai trò của chính phủ trong việc tạo môi trường pháp lý. Hiện nay, APEC đã xây dựng xong chương trình hoạt động chung để thực hiện thương mại điện tử vào năm 2005 đối với các nước phát triển và năm 2010 đối với các nước đang phát triển. Trong khu vực Châu Á - Thái Bình Dương, Nhật là nước đi đầu trong lĩnh vực thương mại điện tử. Hội đồng phát triển thương mại điện tử của Nhật đang cố gắng đơn giản hóa thủ tục thương mại điện tử ở Nhật, thông qua việc tiến hành xây dựng lòng tin và đưa ra nhiều phương án để tiếp cận với khách hàng. Nhật cũng đã tiến hành nhiều dự án trong lĩnh vực giao dịch này nhằm tạo môi trường điện tử thân thiện ở Nhật. Hiện nay, Nhật đã cho ra đời văn bản pháp luật về chữ ký điện tử nhằm tạo điều kiện cho thương mại điện tử phát triển bền vững.",
        "Summary": "\"APEC đã thành lập nhóm công tác chuyên trách về thương mại điện tử năm 1997 để thúc đẩy ứng dụng thương mại điện tử trong khu vực. Năm 1998, APEC đưa ra chương trình hành động, tập trung vào phát triển thương mại điện tử ở các doanh nghiệp có điều kiện và nâng cao vai trò của chính phủ trong việc tạo môi trường pháp lý. Mục tiêu là thực hiện thương mại điện tử vào năm 2005 (nước phát triển) và 2010 (nước đang phát triển). Nhật Bản là nước đi đầu trong khu vực, đơn giản hóa thủ tục và xây dựng lòng tin trong thương mại điện tử, đồng thời ban hành luật về chữ ký điện tử.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các sự kiện và số liệu (ví dụ: năm thành lập nhóm công tác, chương trình hành động, mục tiêu thực hiện thương mại điện tử) được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày theo trình tự thời gian hợp lý (từ năm 1997 đến hiện tại), giúp người đọc dễ dàng theo dõi sự phát triển của thương mại điện tử trong APEC. Các câu liên kết với nhau một cách logic, tạo thành một dòng chảy thông tin liền mạch và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm việc thành lập nhóm công tác, chương trình hành động, mục tiêu thực hiện thương mại điện tử và vai trò tiên phong của Nhật Bản. Các chi tiết không quan trọng đã được lược bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào những thông tin quan trọng nhất."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về khung pháp lý thương mại điện tử của APEC. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00072",
        "Article": "Quan sát và phản ứng với các hoạt động đáng ngờ trong cơ quan/tổ chức là một khía cạnh phức tạp và thường bị bỏ qua của quản lý sự cố. Nếu không có phương tiện phát hiện sự cố, kẻ tấn công có thể xâm nhập hệ thống và duy trì quyền truy cập trong thời gian dài. Nếu không có đủ phương tiện để quan sát trạng thái hệ thống và phân tích trạng thái bảo mật của chúng, cơ quan/tổ chức chỉ có thể biết về sự cố khi nhận được kích hoạt bên ngoài, chẳng hạn như thông tin bí mật xuất hiện trên trang web tấn công hoặc các chi tiết nhạy cảm về cơ quan/tổ chức xuất hiện trên các phương tiện truyền thông.\n Các sự kiện log được tạo ra bởi công nghệ hiện đại nhất để chúng có thể được nhập vào bởi các hệ thống giám sát đặc biệt được gọi là hệ thống quản lý sự kiện và thông tin bảo mật (SIEM), cho phép các nhóm vận hành an ninh giám sát môi trường từ một vị trí (trung tâm vận hành an ninh). Các sự kiện bảo mật yêu cầu mức độ phân tích, tự động hoặc bởi người phân tích được đào tạo để hiểu và sử dụng thông tin để phát hiện các mối đe dọa tiềm ẩn. Nếu một sự kiện hoặc cảnh báo được phát hiện được coi là dấu hiệu của sự xâm phạm thì quy trình quản lý sự cố có thể được ban hành. Trung tâm vận hành an ninh trở thành hệ thống cảnh báo sớm sàng lọc hàng trăm nghìn sự kiện log để tìm kiếm các dấu hiệu của sự xâm phạm, dựa trên chữ ký, kinh nghiệm và các quy tắc tương quan được lập trình trước để phát hiện các véc-tơ tấn công đang được sử dụng.\n Có hai phương pháp mà nhóm an ninh có thể sử dụng khi điều tra một sự cố tùy thuộc vào hoàn cảnh của sự kiện. Loại đầu tiên được gọi là phân tích tinh (static analysis), thường cần sử dụng các công cụ phần mềm đặc biệt để xem phần mềm độc hại nào được cài đặt trên hệ thống và cách phần mềm độc hại đó có thể hoạt động. Tuy nhiên, phần mềm độc hại sẽ không được thực thi để xem xét hành vi của nó. Hình thức điều tra thứ hai liên quan đến việc thiết lập một môi trường thử nghiệm đặc biệt và sau đó chạy phần mềm độc hại, để có thể ghi lại phần mềm độc hại làm gì và sử dụng những kết quả đó để xác định cách nó hoạt động và tác động của nó đối với mục tiêu. Việc phân tích động đôi khi còn được gọi là phân tích hành vi.",
        "Summary": "Việc quan sát và phản ứng với các hoạt động đáng ngờ là yếu tố quan trọng trong quản lý sự cố. Các hệ thống SIEM giúp giám sát và phân tích sự kiện bảo mật để phát hiện các mối đe dọa. Khi phát hiện dấu hiệu xâm phạm, quy trình quản lý sự cố được kích hoạt. Có hai phương pháp điều tra sự cố: phân tích tĩnh (static analysis) sử dụng công cụ để xem xét phần mềm độc hại mà không thực thi nó, và phân tích động (dynamic analysis/behavioral analysis) chạy phần mềm độc hại trong môi trường thử nghiệm để ghi lại hành vi và tác động của nó.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ nội dung cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin chính xác và trình bày một cách rõ ràng, dễ hiểu. Không có điểm cần cải thiện."
            }
        }
    },
    {
        "Index": "00073",
        "Article": "Một method trong java là một tập các câu lệnh được nhóm lại với nhau để thực hiện một hành động cụ thể. Cú pháp hàm: modifier returnType nameOfMethod (Parameter List) à // method body Giải thích: ▪ Modifiers (tạm dịch là phạm vi sửa đổi và truy cập): public hoặc static ▪ returnType: kiểu dữ liệu trả về ▪ nameOfMethod: tên của hàm(method) ▪ Parameter là các tham số đầu vào của hàm(có thể có nhiều tham số với nhiều kiểu dữ liệu khác nhau) ▪ // body: là các mã code bên trong hàm Ví dụ: Viết hàm tính tổng 2 chữ số a và b public static int sum(int a, int b) à return a + b; â Khi chúng ta đã viết xong một hàm rồi làm sao để chúng ta có thể sử dụng chúng đây ta! Trước tiên chúng ta sẽ có 2 loại hàm, mỗi loại sẽ có cách gọi khác nhau: ▪ Hàm có trả về kết quả ▪ Hàm không trả về kết quảĐối với hàm có kết quả trả về, chúng ta cần dùng từ khoá return để trả về kết qủa mà nó đã tính toán được. Khai báo biến có kiểu dữ kiệu tương ứng với kết quả trả về của hàm để nhận giá trị trả về. Như ví dụ tìm sum() của chúng ta, nhiệm vụ của nó là tính tổng của 2 số nguyên a, b nhập vào. Ví dụ 3.11: public class Main à public static int sum(int a, int b) à return a + b; â public static void main(String[] args) à int sum = sum(2,5); System.out.println(sum); â â Chúng ta sẽ dùng biến có kiểu dữ liệu tương ứng để nhận kết quả trả về từ hàm. Hàm sum() trả về int chúng ta dùng biến int sum để nhận kết quả.Đối với loại hàm này chúng ta chỉ cần gọi để sử dụng. Ví dụ: public static void printHello() à System.out.println(\"Hello\"); Hàm printHello() là một hàm không có kiểu trả về nên được thay thế thành void. Từ khoá void cho chúng ta biết là method đó sẽ không có kết quả trả về.Khi bạn gọi đến một hàm đã được định và nó có danh sách các thông số nhất định. Thì khi gọi các bạn sẽ phải truyền đúng thứ tự và kiểu dữ liệu cho từng tham số. Nếu sai xót trong quá trình này có thể dẫn đến biên dịch lỗi hoặc là kết quả không đúng như mong muốn. Ví dụ 3.12: public class Main à public static void swap(int a, int b) à int tam = a; a = b; b = tam; System.out.println(\"Ket qua swap: \" + \"a = \" + a + \" b= \" + b); â public static void main(String[] args) à int a = 5, b = 3; swap(a, b); System.out.println(\"a sau khi swap: \" + a); System.out.println(\"b sau khi swap: \" + b); â â Output: Ket qua swap: a = 3 b= 5 a sau khi swap: 5 b sau khi swap: 3 Nhìn vào kết quả trên, rõ ràng hàm swap đã được a thành b, b thành a, sao trong hàm main giá trị lại như cũ nhỉ? Đó chính là truyền thông số theo giá trị đó các bạn, các tham số truyền vào hàm sẽ chỉ nhận giá trị mà không tham chiếu đến 2 biến a, b của chúng ta. Thế nên đừng có viết hàm swap() như trên nữa nghen, hồi mình chuyển tử C/C++ sang java cũng đã cố gắng viết hàm swap mà không thành.",
        "Summary": "Văn bản mô tả methods trong Java, bao gồm cú pháp với các thành phần: modifiers (ví dụ: public, static), returnType (kiểu dữ liệu trả về), tên method, và danh sách tham số. Methods có hai loại: có trả về giá trị (sử dụng `return`) và không trả về giá trị (returnType là `void`). Việc truyền tham số vào method trong Java là truyền theo giá trị, nghĩa là thay đổi giá trị tham số trong method không ảnh hưởng đến biến gốc bên ngoài method, như ví dụ hàm `swap` minh họa. Điều này cần được lưu ý khi thiết kế và sử dụng methods trong Java.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào cú pháp method, các loại method và cách truyền tham số trong Java, là những điểm cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00074",
        "Article": "Phân tích lỗ hổng bảo mật (vulnerability assessment) là quá trình phát hiện, đo lường và đánh giá các điểm yếu trong hệ thống công nghệ thông tin có thể bị khai thác bởi các tác nhân độc hại. Việc thực hiện phân tích lỗ hổng định kỳ giúp tổ chức nhận diện các rủi ro tiềm ẩn trước khi kẻ tấn công có cơ hội lợi dụng, từ đó giảm thiểu khả năng xảy ra sự cố và tổn thất dữ liệu. Quy trình này thường bao gồm các bước như thu thập thông tin về tài sản CNTT, quét hệ thống bằng các công cụ chuyên dụng, phân loại lỗ hổng theo mức độ nghiêm trọng, xác định mức độ ưu tiên xử lý và xây dựng kế hoạch khắc phục. Một số công cụ phổ biến được sử dụng trong phân tích lỗ hổng gồm Nessus, OpenVAS, Qualys, Nexpose, Burp Suite… Các công cụ này có khả năng kiểm tra hàng trăm đến hàng nghìn lỗ hổng đã biết thông qua cơ sở dữ liệu được cập nhật thường xuyên. Tuy nhiên, cần lưu ý rằng kết quả phân tích lỗ hổng chỉ phản ánh trạng thái tại thời điểm thực hiện, vì vậy cần thực hiện kiểm tra định kỳ và sau mỗi lần cập nhật hệ thống. Ngoài ra, phân tích lỗ hổng nên được kết hợp với đánh giá rủi ro để xác định tác động thực tế của từng lỗ hổng đối với tổ chức. Đối với môi trường sản xuất, cần có kế hoạch quét lỗ hổng không gây ảnh hưởng đến hoạt động, đặc biệt với hệ thống thời gian thực. Một số tổ chức còn triển khai chương trình bug bounty nhằm khuyến khích cộng đồng an ninh mạng tìm kiếm và báo cáo lỗ hổng bảo mật với phần thưởng tương ứng. Kết hợp với kiểm thử xâm nhập, phân tích lỗ hổng là bước đầu trong việc xây dựng một hệ thống phòng thủ chủ động, giúp tổ chức chủ động đối phó với các nguy cơ thay vì chỉ phản ứng bị động.",
        "Summary": "Phân tích lỗ hổng bảo mật là quá trình xác định, đánh giá và xếp hạng mức độ nghiêm trọng của các điểm yếu trong hệ thống. Kỹ thuật này giúp tổ chức chủ động vá lỗi trước khi bị khai thác. Việc phân tích thường đi kèm công cụ tự động và đánh giá thủ công, đảm bảo độ chính xác cao. Kết quả phân tích là cơ sở để xây dựng kế hoạch cải thiện bảo mật và ưu tiên khắc phục lỗ hổng có rủi ro cao. Đây là hoạt động cần thực hiện định kỳ trong chiến lược bảo mật tổng thể.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn được liên kết chặt chẽ, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được trình bày rõ ràng, không gây khó khăn cho người đọc trong việc nắm bắt nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Nó tập trung vào các ý chính như định nghĩa, mục đích, phương pháp và vai trò của phân tích lỗ hổng bảo mật, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về phân tích lỗ hổng bảo mật một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00075",
        "Article": "Trong hệ điều hành, quản lý bộ đệm (buffering) và lưu trữ tạm (caching) là hai kỹ thuật quan trọng giúp cải thiện hiệu suất truy xuất dữ liệu giữa CPU và các thiết bị ngoại vi. Do sự chênh lệch lớn về tốc độ giữa CPU và thiết bị I/O, hệ điều hành cần sử dụng các vùng nhớ trung gian để tạm lưu dữ liệu, tránh làm CPU phải chờ đợi hoặc thiết bị bị nghẽn. Buffering là kỹ thuật lưu trữ tạm thời dữ liệu trong bộ nhớ chính trước khi chuyển đến hoặc từ thiết bị ngoại vi. Có nhiều kiểu bộ đệm như single buffer, double buffer, và circular buffer. Trong đó, double buffer giúp tránh mất dữ liệu bằng cách cho phép một bộ đệm được sử dụng trong khi bộ đệm kia đang được làm đầy hoặc làm trống. Buffering rất hữu ích trong các thiết bị tốc độ thấp như máy in, bàn phím hoặc giao tiếp mạng. Caching, ngược lại, là kỹ thuật lưu trữ dữ liệu đã truy xuất gần đây trong bộ nhớ tốc độ cao (cache), nhằm tăng tốc độ truy cập nếu dữ liệu đó được sử dụng lại. Cache có thể xuất hiện ở nhiều cấp độ: bộ đệm đĩa (disk cache), cache bộ nhớ chính, hay cache CPU. Hệ điều hành sử dụng các thuật toán thay thế như LRU (Least Recently Used), FIFO hoặc Adaptive Replacement Cache để quản lý cache hiệu quả. Ngoài ra, hệ điều hành còn đảm nhiệm đồng bộ dữ liệu giữa cache và bộ nhớ chính, đặc biệt trong các thao tác ghi đĩa. Sử dụng buffering và caching hợp lý giúp tăng thông lượng I/O, giảm thời gian đáp ứng và cải thiện trải nghiệm người dùng. Tuy nhiên, cần cẩn trọng khi xử lý dữ liệu quan trọng, vì mất điện hoặc sự cố hệ thống có thể khiến dữ liệu trong bộ đệm bị mất nếu chưa được ghi xuống thiết bị vĩnh viễn.",
        "Summary": "Quản lý bộ đệm (buffering) là kỹ thuật cho phép lưu tạm dữ liệu khi truyền giữa các thiết bị và tiến trình, nhằm giảm thời gian chờ và tăng hiệu suất hệ thống. Bộ đệm giúp giải quyết sự không đồng bộ giữa tốc độ xử lý của CPU và thiết bị ngoại vi. Các kiểu bộ đệm gồm: đơn, kép hoặc luân phiên. Sử dụng đúng cách, bộ đệm không chỉ tối ưu hóa tài nguyên mà còn đảm bảo truyền dữ liệu an toàn và liên tục, đặc biệt trong các ứng dụng cần tốc độ cao và độ ổn định lớn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số chi tiết không hoàn toàn chính xác hoặc không đầy đủ so với văn bản gốc. Ví dụ, bản tóm tắt đề cập đến việc 'đảm bảo truyền dữ liệu an toàn', trong khi văn bản gốc lại nhấn mạnh nguy cơ mất dữ liệu trong bộ đệm nếu có sự cố. Ngoài ra, phần tóm tắt về các kiểu bộ đệm chưa đầy đủ so với văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, các ý được trình bày rõ ràng và có sự liên kết logic. Tuy nhiên, có thể cải thiện bằng cách làm rõ hơn mối quan hệ giữa các câu, ví dụ như sử dụng các từ nối để tăng tính trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính về buffering, tuy nhiên, việc lược bỏ hoàn toàn phần caching làm giảm đi tính bao quát của tóm tắt so với văn bản gốc. Một vài chi tiết có thể được lược bỏ để tập trung vào các khái niệm quan trọng hơn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, nắm bắt được một số ý chính của văn bản gốc về buffering. Tuy nhiên, cần cải thiện về tính trung thực bằng cách đảm bảo thông tin chính xác và đầy đủ hơn, đồng thời cân nhắc việc đề cập đến caching để tăng tính bao quát. Cần xem xét lại việc lựa chọn thông tin để đảm bảo tính liên quan cao hơn."
            }
        }
    },
    {
        "Index": "00076",
        "Article": "Để có được kiểu sao chép hoàn toàn này, lập trình viên phải tự cài đặt quy trình sao chép. Java có hỗ trợ sao chép nông và sao chép sâu với phương thức clone và interface Cloneable. Tuy nhiên, nhiều chuyên gia, trong đó có Joshua Bloch – tác giả cuốn Effective Java [7], khuyên không nên sử dụng hỗ trợ này do nó có lỗi thiết kế và hiệu lực thực thi không ổn định, thay vào đó, nên dùng hàm khởi tạo sao chép. Hàm khởi tạo sao chép (copy constructor) là hàm khởi tạo với tham số duy nhất là một tham chiếu đối tượng và hàm này sẽ khởi tạo đối tượng mới sao cho có nội dung giống hệt đối tượng đã cho. Chẳng hạn: Trong đó, nội dung hàm khởi tạo Cow(Cow c) làm nhiệm vụ sao chép nội dung của đối tượng c vào đối tượng vừa tạo, ở đây chỉ là các phép gán giá trị cho các biến thực thể. Tuy nhiên, khi có quan hệ thừa kế, tình huống không phải lúc nào cũng đơn giản như ví dụ đó. Xét quan hệ thừa kế giữa Animal và Cat. Ta viết hàm khởi tạo sao chép cho cả hai lớp. Giả sử ta cần một tình huống đa hình chẳng hạn như một đoạn mã áp dụng cho các loại Animal nói chung, trong đó có Cat. Trong phương thức đó ta cần nhân bản các đối tượng mà không biết chúng thuộc lớp nào trong cây thừa kế Animal, chẳng hạn: Liệu trong tình huống này ta có thể dùng hàm khởi tạo sao chép của Animal để nhân bản các đối tượng thuộc các lớp con? Ta hãy thử xem. Hình 9.10: Hàm khởi tạo sao chép và quan hệ thừa kế. Ví dụ trong Hình 9.10 cho thấy câu trả lời là 'không thể'. Khi ta dùng lệnh new Animal(tom) gọi hàm khởi tạo sao chép nhằm tạo một bản sao của mèo Tom, thực ra ta đang tạo đối tượng Animal và dùng hàm khởi tạo của lớp Animal (nhớ lại rằng giữa các hàm khởi tạo không có quan hệ thừa kế do đó cũng không có đa hình). Cho nên kết quả của thao tác sao chép thứ hai không phải là một đối tượng mèo tên Tom mà là một đối tượng Animal tên Tom (phiên bản makeNoise() chạy cho đối tượng này in ra \"Huh?\" – đây là phiên bản của Animal chứ không phải phiên bản của Cat). Như vậy sử dụng hàm khởi tạo sao chép như trong tình huống này không cho ta kết quả mong muốn.",
        "Summary": "\"Java hỗ trợ sao chép nông và sâu thông qua phương thức clone và interface Cloneable, nhưng các chuyên gia khuyên dùng hàm khởi tạo sao chép thay thế. Hàm khởi tạo sao chép tạo một đối tượng mới có nội dung giống hệt đối tượng đã cho. Tuy nhiên, khi có quan hệ thừa kế, việc sử dụng hàm khởi tạo sao chép của lớp cha để nhân bản các đối tượng thuộc lớp con có thể không tạo ra bản sao chính xác của đối tượng con, mà chỉ tạo ra một đối tượng thuộc lớp cha với các thuộc tính được sao chép.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc dễ dàng nắm bắt được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào vấn đề sao chép trong Java, khuyến nghị sử dụng hàm khởi tạo sao chép và hạn chế của nó trong quan hệ thừa kế."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00077",
        "Article": "Các phương pháp trên đều không đảm bảo cá thể tốt nhất được lựa chọn. Trong phương pháp lựa chọn tinh hoa, một số lượng nhất định các cá thể tốt nhất được lựa chọn trước, sau đó phần còn lại được lựa chọn theo các phương pháp ru lét hay thi đấu như ở trên. Như vậy, các cá thể tốt nhất luôn được duy trì đoạn gen của mình sang thế hệ sau và tránh làm mất lời giải tốt nhất đã tìm - Loại bỏ các cá thể có hàm thích nghi nhỏ hơn một ngưỡng nhất định, sử dụng các cá thể còn lại để lai ghép và tạo quần thể mới. Xác suất lai ghép. Nếu xác suất lai ghép là 1 (100%) thì toàn bộ cá thể con sẽ được tạo ra do lai ghép. Ngược lại, nếu xác suất lai ghép là 0 thì toàn bộ cá thể con là bản sao của một số cá thể bố mẹ nhưng không nhất thiết quần thể tiếp theo trùng với quần thể cũ. Như đã nói ở trên, xác suất lai ghép được lựa chọn tương đối lớn, thường từ 0.5 trở lên. Xác suất đột biến. Nếu xác suất đột biến là 100% thì toàn bộ cá thể sau khi lai ghép sẽ bị thay đổi. Ngược lại, nếu xác suất này là 0 thì không cá thể nào bị thay đổi. Xác suất đột biến được lựa chọn rất nhỏ, ít khi vượt quá 0.1. Xác suất đột biến nhỏ để tránh cho thuật toán di chuyển theo kiểu ngẫu nhiên. Giải quyết vấn đề bằng tìm kiếm Kích thước quần thể N là số lượng cá thể được duy trì trong mỗi thế hệ. Nếu N quá nhỏ, thuật toán có ít lựa chọn để thực hiện lai ghép, dẫn tới chỉ một phần không gian tìm kiếm được khảo sát và do vậy có thể không tìm được lời giải tốt. Nếu N quá lớn, thuật toán sẽ thực hiện chậm do phải xử lý nhiều trong mỗi vòng lặp. Giá trị tốt của N phụ thuộc vào bài toán cụ thể và cách mã hoá lời giải. Tuy nhiên, nhiều kết quả thực nghiệm cho thấy, khi N tăng tới một mức độ nào đó, chất lượng lời giải không tăng, trong khi thuật toán sẽ chậm hơn.",
        "Summary": "Các phương pháp trên đều không đảm bảo cá thể tốt nhất được lựa chọn. Trong phương pháp lựa chọn tinh hoa, một số lượng nhất định các cá thể tốt nhất được lựa chọn trước, sau đó phần còn lại được lựa chọn theo các phương pháp ru lét hay thi đấu như ở trên.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt mạch lạc vì nó trích dẫn một đoạn văn liên tục từ văn bản gốc, đảm bảo tính liên kết và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có liên quan, nhưng chưa đầy đủ. Nó chỉ tập trung vào một phần nhỏ của văn bản gốc (phương pháp lựa chọn tinh hoa) mà bỏ qua các ý chính khác như xác suất lai ghép, xác suất đột biến và kích thước quần thể. Do đó, nó chưa bao quát được toàn bộ nội dung quan trọng của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng ở mức khá về tính trung thực và mạch lạc, tuy nhiên cần cải thiện về tính liên quan. Để cải thiện, bản tóm tắt nên bao gồm thêm thông tin về xác suất lai ghép, xác suất đột biến và kích thước quần thể để phản ánh đầy đủ hơn nội dung chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00078",
        "Article": "HDFS Hadoop framwork của Apache là một nền tảng dùng để phân tích các tập dữ liệu rất lớn mà không thể xử lý trên được trên một máy chủ duy nhất. Hadoop trừu tượng hóa mô hình tính toán MapReduce, làm nó trở nên dễ tiếp cận hơn với các nhà phát triển. Hadoop có khả năng mở rộng vô số các nút lưu trữ và có thể xử lý tất cả hoạt động và phân phối liên quan đến việc phân loại dữ liệu. Tổng quan thiết kế của HDFS HDFS (Hadoop distributed file system) ra đời trên nhu cầu lưu trữ dữ liệu của Nutch, một dự án Search Engine nguồn mở. HDFS kế thừa các đặc tính chung của các hệ thống tập tin phân tán thế hệ trước như độ tin cậy, khả năng mở rộng và hiệu suất hoạt động. HDFS được thiết kế với những giả định như dưới đây: Thứ nhất, các lỗi về phần cứng sẽ thường xuyên xảy ra. Hệ thống HDFS sẽ chạy trên các cluster với hàng trăm hoặc thậm chí hàng nghìn nút. Các nút này được xây dựng từ các phần cứng thông thường, giá rẻ, tỷ lệ lỗi cao. Chất lượng và số lượng của các thành phần phần cứng như vậy sẽ tất yếu dẫn đến tỷ lệ xảy ra lỗi trên hệ thống cluster cao. Có thể điểm qua một số lỗi như lỗi của ứng dụng, lỗi của hệ điều hành, lỗi đĩa cứng, bộ nhớ, lỗi của các thiết bị kết nối, lỗi mạng, lỗi về nguồn điện… Vì thế, khả năng phát hiện lỗi, chống chịu lỗi và tự động phục hồi phải được tích hợp vào trong hệ thống HDFS. Thứ hai, do đặc thù lưu trữ dữ liệu có dung lượng lớn, HDFS được thiết kế để tối ưu cho bài toán lưu trữ các tập tin có kích thước lớn hàng GB, thậm chí TB. Để giải quyết bài toán này, dữ liệu của các tập tin lớn sẽ được chia nhỏ thành các khối lớn (ví dụ 64MB) và phân tán trên các nút lưu trữ. So với các hệ thống tập tin khác, HDFS không tối ưu cho bài toán lưu trữ hàng tỉ tập tin nhỏ với kích thước mỗi tập tin chỉ vài KB. Ưu điểm của thiết kế tập tin lớn là giảm tải cho hệ thống quản lý không gian tập tin, giảm thời gian thao tác trên các thư mục hay tìm kiếm tập tin. Thứ ba, HDFS ban đầu được thiết kế chỉ cho phép thay đổi nội dung các tập tin được lưu trữ qua phép toán thêm “append” dữ liệu vào cuối tập tin hơn là ghi đè lên dữ liệu hiện có. Việc ghi dữ liệu lên một vị trí ngẫu nhiên trong tập tin không được hỗ trợ. Một khi đã được tạo ra, các tập tin sẽ trở thành file chỉ đọc (read-only). Thiết kế này khác căn bản so với các hệ thống quản lý tập tin truyền thống do khác biệt về mục đích sử dụng. HDFS được thiết kế để tối ưu cho bài toán lưu trữ dữ liệu cho việc phân tích khi mà đầu vào có thể là các tập tin nhật ký logs hay dữ liệu liên tục đến từ các cảm biến. Với đầu vào dữ liệu này thì thao tác ghi ngẫu nhiên hay ghi đè dữ liệu là không cần thiết. Hơn nữa, đơn giản hóa hỗ trợ ghi dữ liệu cũng là nhân tố để HDFS tối ưu và tăng hiệu năng hệ thống. Ngày nay, Hadoop cluster và HDFS rất phổ biến trên thế giới. Nổi bật nhất là hệ thống của Yahoo với một cluster lên đến 1100 nút với dung lượng HDFS là 12 PB. Các công ty khác như Facebook, Adode, Amazon cũng đã xây dựng các cluster chạy HDFS với dung lượng hàng trăm, hàng nghìn TB.",
        "Summary": "HDFS (Hadoop Distributed File System) là một phần của Hadoop, một nền tảng của Apache để phân tích dữ liệu lớn trên nhiều máy chủ. HDFS được thiết kế để đối phó với các lỗi phần cứng thường xuyên xảy ra trong các cluster lớn, lưu trữ hiệu quả các tập tin có kích thước lớn bằng cách chia nhỏ chúng thành các khối và phân tán trên các nút lưu trữ. HDFS ban đầu được tối ưu hóa cho việc thêm dữ liệu vào cuối tập tin thay vì ghi đè, phù hợp với việc lưu trữ dữ liệu cho phân tích, chẳng hạn như nhật ký hoặc dữ liệu từ cảm biến. Hadoop và HDFS ngày càng phổ biến và được sử dụng rộng rãi trong các công ty lớn như Yahoo, Facebook, Adobe và Amazon.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc dễ dàng nắm bắt được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, thiết kế, ưu điểm và ứng dụng của HDFS."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác nội dung quan trọng của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00079",
        "Article": "Tương tự kiểm thử đơn vị, kiểm thử hệ thống cũng có bộ các ca kiểm thử cho từng chức năng. Mỗi ca kiểm thử chức năng thường mô tả từng bước thực hiện ở mức sử dụng phần mềm để hoàn thành một tác vụ nào đó. Mỗi bước thực hiện có thể có dữ liệu đầu vào, thao tác thực hiện, và kết quả mong đợi quan sát được tương ứng để người kiểm thử khi thực hiện từng bước này sẽ kiểm tra xem phần mềm hoạt động đúng không.Trước đây việc thực hiện kiểm thử này phải làm bằng tay, tốn rất nhiều chi phí, cả máy móc, thời gian và sức người. Tuy nhiên gần đây việc thực hiện này đang được tự động hóa ngày càng nhiều nhờ có các công cụ mạnh đang được chú trọng nghiên cứu và phát triển tích cực. Một ví dụ có thể kể đến là Selenium - một công cụ có thể thực hiện các ca kiểm thử tự động cho các ứng dụng trên nền Web. Người kiểm thử có thể thực hiện thao tác kiểm thử lần đầu và cho Selenium ghi lại các thao tác của mình dưới dạng các mã dễ đọc của Selenium. Sau đó các ca kiểm thử này được chạy lại tự động. Người kiểm thử có thể chỉnh sửa mã Selenium sinh ra cho phù hợp hơn với ý đồ của ca kiểm thử. Khi phải kiểm tra tính tương thích của ứng dụng trên nhiều trình duyệt khác nhau, hoặc khi phải chạy lại các ca kiểm thử thì công cụ này giúp giảm đáng kể công sức phải thực hiện lại.Việc xây dựng các ca kiểm thử chức năng được gọi là việc thiết kế kiểm thử. Các ca kiểm thử chức năng nên được thiết kế chỉ dựa trên đặc tả chức năng của phần mềm, độc lập với thiết kế và cài đặt của phần mềm. Cách làm này giúp phát hiện các lỗi trong thiết kế vì nếu dựa trên thiết kế có lỗi, các ca kiểm thử sẽ được xây dựng cho đúng với thiết kế chứ không đúng theo đặc tả chức năng. Tuy nhiên, việc thiết kế kiểm thử hoàn toàn độc lập này có thể lại không giúp phát hiện các vấn đề với thiết kế. Do đó, trên thực tế chúng ta cần cân đối sử dụng một mức độ thông tin trong thiết kế và cài đặt để thiết kế ca kiểm thử. Mức độ này là bao nhiêu phụ thuộc rất nhiều vào tính chất của từng dự án và kinh nghiệm của người thiết kế kiểm thử. Cuối cùng, kiểm thử hệ thống có thể sử dụng lại các ca kiểm thử mức thấp hơn như kiểm thử tích hợp, kiểm thử đơn vị.Một khía cạnh khác nữa với kiểm thử hệ thống là việc tổ chức thực hiện. Chúng ta để một đội vừa phát triển vừa thực hiện kiểm thử hệ thống hay để hai đội độc lập thực hiện hai việc riêng biệt? Khi thực hiện độc lập, khối lượng công việc tăng lên vì đội thực hiện phải đọc lại tài liệu và hiểu hệ thống mới có thể thực hiện kiểm thử. Nhưng sự khách quan này thường giúp phát hiện nhiều vấn đề trong hệ thống và kết quả cho phép kiểm thử chấp nhận dễ dàng vượt qua hơn. Nếu đội phát triển thực hiện kiểm thử hệ thống, yếu tố chủ quan sẽ giúp việc kiểm thử tập trung vào một số điểm yếu của hệ thống, tuy nhiên đội sẽ bị ảnh hưởng bởi những thông tin đã biết về thiết kế và cài đặt của hệ thống nên thiếu tính khách quan trong thiết kế và thực hiện kiểm thử. Để giảm sự ảnh hưởng chủ quan này, trong các dự án phát triển theo quy trình linh hoạt, người ta phát triển các ca kiểm thử hệ thống ngay từ đầu, trong quá trình thu thập yêu cầu và trong quá trình xây dựng hệ thống.",
        "Summary": "\"Kiểm thử hệ thống sử dụng các ca kiểm thử chức năng để mô tả các bước thực hiện tác vụ, dữ liệu đầu vào và kết quả mong đợi. Việc kiểm thử này đang được tự động hóa bằng các công cụ như Selenium, giúp giảm chi phí và công sức. Các ca kiểm thử nên được thiết kế dựa trên đặc tả chức năng, độc lập với thiết kế để phát hiện lỗi thiết kế, nhưng cần cân đối với thông tin thiết kế và cài đặt. Kiểm thử hệ thống có thể sử dụng lại các ca kiểm thử mức thấp hơn. Việc tổ chức thực hiện kiểm thử hệ thống có thể do đội phát triển hoặc một đội độc lập thực hiện, mỗi cách có ưu và nhược điểm riêng. Trong quy trình linh hoạt, ca kiểm thử hệ thống được phát triển từ sớm để giảm ảnh hưởng chủ quan.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các khía cạnh chính của kiểm thử hệ thống, bao gồm ca kiểm thử chức năng, tự động hóa, thiết kế kiểm thử, sử dụng lại các ca kiểm thử mức thấp hơn và tổ chức thực hiện."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có đề xuất cải thiện nào."
            }
        }
    },
    {
        "Index": "00080",
        "Article": "Hiệu quả của một mô hình còn phụ thuộc vào các yếu tố khác ngoài thuật toán học ra, đó là các Sự phân bố các phân tử trong một lớp hay số lƣợng các phần tử khác nhau trong mỗi lớp và sự phân bổ chúng trong các lớp khác nhau có ảnh hƣởng rất lớn đối với hiệu quả phân lớp của một mô hình Chi phí của sự phân sai lớp Kích cỡ của tập dữ liệu dùng để huấn luyện và tập dùng để kiểm thử Đƣờng cong học trong hình vẽ dƣới đây thể độ chính xác thay đổi thế nào khi kích cỡ của tập huấn luyện thay đổi. Để vẽ đƣợc đƣờng cong này, chúng ta cần một lịch lấy mẫu để thay đổi kích cỡ lấy mẫu bằng cách lấy mẫu số học hoặc lấy mẫu dạng hình học. Hiệu quả của kích cỡ lấy mẫu nhỏ thể hiện trong sự sai khác về ƣớc lƣợng, phƣơng sai trong ƣớc lƣợng Các phƣơng pháp ƣớc lƣợng Phƣơng pháp giữ lại một phần (holdout): dùng 2/3 số bản ghi của tập dữ liệu cho việc huấn luyện và 1/3 còn lại cho việc kiểm thử. Việc lựa chọn 2/3 lƣợng bản ghi nào là ngẫu Phƣơng pháp lấy mẫu con: là cách dùng lại phƣơng pháp giữ một phần trình bày ở trên Phƣơng pháp xác nhận chéo: o Chia dữ liệu thành k tập con không giaonhau o Lặp lại k lần công việc sau: huấn luyện mô hình trên k-1 tập con và kiểm thử mô hình trên tập con thứ k còn lại o Trong trƣờng hợp đặc biết k=n có nghĩa là tập dữ liệu đƣợc chia thành n tập con (n là số bản ghi trong tập dữ liệu), mỗi lần huấn luyện sẽ dùng n-1 bản ghi và kiểm thử trên bản ghi còn lại. Lặp công việc đó n lần cho toàn bộ bản ghi trong Phƣơng pháp lấy mẫu: dùng các tập con của tập dữ liệu thu đƣợc bằng cách áp dụng các phƣơng pháp lấy mẫu để huấn luyện và kiểm thử mô hình. Cần quan tâm tới các vấn đề lấy mẫu với số lƣợng quá nhiều hoặc quá ít, khiến cho chất lƣợng huấn luyện mô hình và Phƣơng pháp khởi động nhanh: là cách lấy mẫu nhƣng có thay thế Khái niệm về phân tích phân cụm Cụm là một tập hợp các đối tƣợng dữ liệu giống nhau theo một tiêu chí nào đó, hai đối tƣợng giống nhau thì nằm trong cùng một cụm, hai đối tƣợng khác nhau thì nằm ở hai cụm khác nhau. Việc phân cụm các điểm thành 3 cụm (màu đỏ, màu tím và màu xanh) đƣợc mô tả trong hình dƣới đây trong đó chúng ta thấy khoảng cách giữa các phần tử trong cùng một cụm đƣợc tối thiểu hóa, còn khoảng cách giữa hai phần tử trong hai cụm khác nhau cần đƣợc tối đa hóa.",
        "Summary": "Việc lựa chọn 23 lƣợng bản ghi nào là ngẫu Phƣơng pháp lấy mẫu con là cách dùng lại phƣơng pháp giữ một phần trình bày ở trên Phƣơng pháp xác nhận chéo o Chia dữ liệu thành k tập con không giaonhau o Lặp lại k lần công việc sau huấn luyện mô hình trên k-1 tập con và kiểm thử mô hình trên tập con thứ k còn lại o Trong trƣờng hợp đặc biết kn có nghĩa là tập dữ liệu đƣợc chia thành n tập con n là số bản ghi trong tập dữ liệu, mỗi lần huấn luyện sẽ dùng n-1 bản ghi và kiểm thử trên bản ghi còn lại.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt trích dẫn trực tiếp một số câu từ trong văn bản gốc, nhưng không phải là một bản tóm tắt đầy đủ và chính xác. Các câu được trích dẫn không bị sai lệch so với văn bản gốc, tuy nhiên, việc lựa chọn các câu này có vẻ ngẫu nhiên và không phản ánh đầy đủ nội dung chính của văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc. Các câu trích dẫn được liệt kê một cách rời rạc, không có sự liên kết logic rõ ràng giữa chúng. Điều này khiến cho người đọc khó hiểu được ý nghĩa tổng thể mà bản tóm tắt muốn truyền đạt."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chỉ tập trung vào một phần nhỏ của văn bản gốc (các phương pháp lấy mẫu) và bỏ qua nhiều ý chính khác như các yếu tố ảnh hưởng đến hiệu quả của mô hình, khái niệm phân tích phân cụm. Do đó, tính liên quan của bản tóm tắt là khá thấp."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt này có chất lượng kém. Nó thiếu tính trung thực (do không bao quát được nội dung chính), tính mạch lạc (do các ý không liên kết với nhau) và tính liên quan (do bỏ qua nhiều thông tin quan trọng). Để cải thiện, cần tóm tắt đầy đủ hơn các ý chính của văn bản gốc, sắp xếp các ý một cách logic và đảm bảo sự liên kết giữa chúng."
            }
        }
    },
    {
        "Index": "00081",
        "Article": "b. Ghép kênh dòng chương trình & dòng truyền tải MPEG\n Dòng ghép kênh: Lớp hệ thống MPEG-2 mô tả cách thức các dòng sơ cấp của một\n chương trình hay của nhiều chương trình được ghép chung với nhau tạo ra một dòng số\n liệu thích hợp cho lưu trữ số hay truyền dẫn số.\n Chuẩn nén MPEG-2 được thiết kế cho tốc độ bit lớn hơn 4Mb/s. Tín hiệu video và audio\n được nén, xử lý đóng gói và ghép kênh tạo thành các dòng dữ liệu với tốc độ mong muốn.\n Các thông tin cần thiết sử dụng trong ghép kênh gồm:\n · Hệ thống các nhãn thời gian (Time - Stamp TS): Sử dụng để đảm bảo các dòng sơ\n cấp liên kết được phát lại một cách đồng bộ tại bộ giải mã.\n · Các bảng thông tin dịch vụ (Service Information): Mô tả các chi tiết về thông số\n mạng, về các chương trình đang được ghép kênh và về bản chất của các dòng sơ\n cấp khác nhau.\n · Các thông tin điều khiển việc xáo trộn (Scrambling) số liệu, các thông tin dùng để\n truy cập có điều kiện CA (Conditional Access).\n · Các kênh số liệu riêng (private data): Số liệu riêng là dòng số liệu mà nội dung\n của nó không được quy định bởi tiêu chuẩn MPEG. Ở MPEG đạt được sự đồng bộ thông qua việc sử dụng nhãn thời gian tần số và chuẩn\n đồng hồ (Clock system-CS).\n Ghép kênh dòng chương trình (Program stream-PS)\n Được thiết kế cho môi trường không có tạp nhiễu, một dòng chương trình là kết quả của\n ghép kênh một vài dòng cơ sở của một chương trình dùng chung một xung nhịp, bao gồm\n các gói PES có độ dài thay đổi. Dòng dữ liệu sau ghép kênh chứa dòng bit điều khiển bởi\n miêu tả chương trình. Dòng chương trình thường ứng dụng trên đĩa CD-ROM, DVD, HDDVD Như vậy, theo cách thức này:\n · Bộ mã hóa video mã hóa tín hiệu video số định dạng CCIR - 601 thành dòng sơ\n cấp video (video ES) có chiều dài gần như vô tận và chỉ chứa những thông tin tối\n cần thiết để có thể khôi phục lại hình ảnh ban đầu.\n · Bộ mã hóa audio mã hóa tín hiệu audio số định dạng AES/EBU thành dòng sơ cấp\n audio có chiều dài tùy ý (tần số lấy mẫu 48KHz, số bit mẫy 24 bit và tốc độ bit là\n 1152 Kbit/s).\n · Ban đầu, các dòng video, audio được đóng gói lại thành các dòng sơ cấp PES\n tương ứng với các gói có độ dài thay đổi. Mỗi gói PES bao gồm một header và\n một số liệu trích ra từ dòng sơ cấp.\n · Các gói PES lại được ghép với nhau tạo ra dòng chương trình PS.\n Dòng chương trình chỉ được thiết kế để truyền trong môi trường không có tạp nhiễu và\n sai nhầm, ví dụ như trong các ứng dụng CD – ROM vì hai nguyên nhân sau:\n · Dòng chương trình bao gồm các gói tương đối dài nối tiếp nhau và độ dài này lại\n luôn thay đổi. Mỗi gói bắt đầu bằng một tiêu đề (header). Mỗi lỗi xảy ra trong\n phần tiêu đề có thể làm mất thông tin của toàn gói. Vì các gói của chương trình có\n thể chứa vài chục Kbyte số liệu nên sự mất mát thông tin của một gói có thể làm\n mất hoặc gián đoạn cả một khung ảnh.\n · Độ dài gói không cố định khiến cho bộ giải mã không dự đoán được khi nào gói\n chấm dứt và khi nào gói mới bắt đầu. Thay vào đó, bộ giải mã đọc và dịch lại bộ\n thông tin về độ dài gói chứa trong mỗi tiêu đề, nếu thông tin về độ dài gói này bị\n lỗi, bộ giải mã sẽ mất đồng bộ và như vậy sẽ làm mất thông tin ít nhất là một gói.",
        "Summary": "Ghép kênh trong MPEG-2 kết hợp các dòng sơ cấp của một hoặc nhiều chương trình thành một dòng dữ liệu duy nhất, phù hợp cho lưu trữ hoặc truyền dẫn. Quá trình này sử dụng nhãn thời gian để đồng bộ hóa, bảng thông tin dịch vụ để mô tả chi tiết chương trình và mạng, thông tin điều khiển xáo trộn, và các kênh dữ liệu riêng. Ghép kênh dòng chương trình (PS) được thiết kế cho môi trường không nhiễu, ghép các dòng cơ sở của một chương trình sử dụng chung xung nhịp thành các gói PES có độ dài thay đổi, thường dùng trên CD-ROM, DVD. Tuy nhiên, PS dễ bị lỗi do độ dài gói thay đổi và tiêu đề gói dễ bị hỏng, gây mất đồng bộ và gián đoạn dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc có thể dễ dàng hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, các yếu tố sử dụng trong ghép kênh, đặc điểm và hạn chế của ghép kênh dòng chương trình (PS)."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được đầy đủ các ý chính của văn bản gốc và trình bày chúng một cách súc tích, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00082",
        "Article": "Kỹ thuật phân trang loại bỏ được hiện tượng phân mảnh ngoại vi vì mỗi khung trang đều có thể được cấp phát cho một tiến trình có yêu cầu. Tuy nhiên, phân mảnh nội vi vẫn có thể xảy ra nếu kích thước của tiến trình không đúng bằng bội số của kích thước một trang, dẫn đến trang cuối cùng không được sử dụng hết. Một lợi ích quan trọng của phân trang là sự phân biệt rõ ràng giữa góc nhìn của người dùng và bộ phận quản lý bộ nhớ vật lý. Đối với người dùng, bộ nhớ được nhìn nhận như một không gian liên tục, đồng nhất và chỉ chứa duy nhất tiến trình của họ. Trong khi đó, từ góc độ bộ nhớ vật lý, tiến trình của người dùng được lưu trữ phân tán khắp bộ nhớ cùng với các tiến trình khác. Phần cứng chịu trách nhiệm chuyển đổi địa chỉ logic thành địa chỉ vật lý, quá trình này hoàn toàn trong suốt đối với người sử dụng. Hệ điều hành duy trì một bảng khung trang để lưu trữ thông tin về tình trạng bộ nhớ vật lý, mỗi phần tử trong bảng mô tả trạng thái của một khung trang, có thể là đang tự do hoặc đã được cấp phát cho một tiến trình. Tuy nhiên, phân trang không phản ánh đúng cách thức người dùng cảm nhận về bộ nhớ. Người dùng thường tổ chức bộ nhớ thành các đối tượng chương trình như các đoạn mã (segments), thư viện, cũng như các đối tượng dữ liệu như biến toàn cục, stack, và vùng nhớ chia sẻ. Kỹ thuật phân đoạn giúp thể hiện cấu trúc logic của chương trình một cách tốt hơn, nhưng lại gây ra vấn đề phải cấp phát bộ nhớ với kích thước không cố định, phức tạp hơn so với cấp phát các trang có kích thước cố định trong phân trang. Một giải pháp dung hòa là kết hợp cả hai kỹ thuật bằng cách phân trang các phân đoạn. Điều này giúp tận dụng lợi ích của cả hai phương pháp: giữ được cấu trúc logic của chương trình trong phân đoạn, đồng thời tránh được vấn đề phân mảnh ngoại vi bằng cách phân trang từng phân đoạn.",
        "Summary": "Phân trang loại bỏ phân mảnh ngoại vi nhưng có thể gây phân mảnh nội vi nếu trang cuối không được sử dụng hết, đồng thời tách biệt góc nhìn của người dùng và bộ nhớ vật lý. Phân đoạn phản ánh cấu trúc logic của chương trình tốt hơn nhưng phức tạp trong cấp phát bộ nhớ. Kết hợp phân trang và phân đoạn giúp tận dụng ưu điểm của cả hai, giữ cấu trúc logic và tránh phân mảnh ngoại vi.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt súc tích giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào ưu nhược điểm của phân trang, phân đoạn và giải pháp kết hợp, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, thể hiện đầy đủ các ý chính của văn bản gốc một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00083",
        "Article": "Tại sao phải đổi trang Khi xẩy ra thiếu trang hệ điều hành tìm một khung trống trong bộ nhớ đọc trang thiếu vào khung và tiến trình sau đó hoạt động bình thường Tuy nhiên do kích thước của các tiến trình có thể lớn hơn kích thước bộ nhớ thực rất nhiều nên tới một lúc nào đó sẽ xảy ra tình trạng toàn bộ bộ nhớ đã được cấp phát hệ điều hành không thể tìm được khung trống để tải trang mới vào Cách giải quyết đơn giản nhất trong trường hợp đó là hệ điều hành kết thúc tiến trình do không thoả mãn được nhu cầu bộ nhớ Nhưng như ta đã biết mục đích của bộ nhớ ảo là cho phép các tiến trình sử dụng được không gian nhớ lớn hơn không gian nhớ thực và tăng tính đa chương trình của hệ thống Tiến trình và người dùng cần được đáp ứng nhu cầu về bộ nhớ Cách giải quyết thứ hai là tạm trao đổi tiến trình ra đĩa giải phóng toàn bộ không gian mà tiến trình chiếm trong bộ nhớ và chờ tới khi thuận lợi nhiều bộ nhớ trống hơn mới nạp lại tiến trình vào bộ nhớ để thực hiện tiếp Cách giải quyết này là cần thiết trong một số trường hợp Tuy nhiên nếu tất cả các tiến trình đều được đưa ra đĩa khi thiếu bộ nhớ thì hệ thống sẽ rơi vào tình trạng mất quá nhiều thời gian cho việc trao đổi tiến trình mà không thực sự thực hiện được công việc nào Cách giải quyết thứ ba được áp dụng trong đa số trường hợp Đó là sử dụng kỹ thuật đổi trang Kỹ thuật này cho phép thay thế một trang hiện có trong bộ nhớ bằng trang mới mà tiến trình cần truy cập mà không cần phải dừng tiến trình hoặc trao đổi toàn bộ tiến trình ra đĩa Để thực hiện điều này hệ điều hành cần một thuật toán quyết định trang nào sẽ bị thay thế Khi một trang được thay thế hệ điều hành kiểm tra xem trang đó đã được sửa đổi hay chưa Nếu chưa trang có thể bị ghi đè ngay lập tức Nếu đã bị sửa đổi thì trước khi thay thế hệ điều hành cần ghi nội dung của trang đó trở lại đĩa để đảm bảo dữ liệu không bị mất Do vậy lựa chọn trang nào để thay thế là một yếu tố quan trọng quyết định hiệu suất của hệ thống Các thuật toán thay thế trang sẽ được trình bày chi tiết trong các phần sau",
        "Summary": "Khi xảy ra thiếu trang, hệ điều hành tìm khung trống trong bộ nhớ để nạp trang mới. Nếu bộ nhớ đầy, hệ điều hành có thể kết thúc tiến trình, nhưng mục tiêu của bộ nhớ ảo là cho phép tiến trình sử dụng bộ nhớ lớn hơn bộ nhớ thực. Một giải pháp phổ biến là sử dụng kỹ thuật đổi trang, cho phép thay thế trang hiện có bằng trang mới mà không dừng tiến trình, với điều kiện dữ liệu trong trang phải được lưu lại đĩa nếu cần. Việc lựa chọn trang để thay thế ảnh hưởng lớn đến hiệu suất hệ thống.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về vấn đề đổi trang khi thiếu bộ nhớ, các giải pháp và tầm quan trọng của việc lựa chọn trang để thay thế. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00084",
        "Article": "Trong lập trình Arduino, biến số và hằng số là hai khái niệm cơ bản và quan trọng. Hằng số là các giá trị không thay đổi trong suốt quá trình thực thi chương trình. Các hằng số phổ biến trong Arduino bao gồm HIGH, LOW, INPUT, INPUT_PULLUP, OUTPUT, LED_BUILTIN, true, false, cũng như các hằng số nguyên và thực như số nguyên (integer constants) và số thực (floating point constants). Các hằng số này giúp cho việc lập trình dễ dàng hơn, đảm bảo tính rõ ràng và chính xác của mã lệnh. Kiểu dữ liệu trong Arduino rất đa dạng, bao gồm void, boolean, char, unsigned char, byte, int, unsigned int, word, long, unsigned long, short, float, double, array, string và String (object). Mỗi kiểu dữ liệu này phục vụ một mục đích khác nhau trong việc xử lý thông tin và tương tác với các thành phần phần cứng. Arduino cũng hỗ trợ chuyển đổi kiểu dữ liệu qua các hàm như char(), byte(), int(), word(), long(), và float(), giúp chuyển đổi giữa các kiểu dữ liệu khác nhau khi cần thiết. Phạm vi của biến được phân loại thành các loại như static (biến tĩnh), const (biến hằng) và volatile, với mỗi loại có một mục đích sử dụng riêng biệt trong việc quản lý bộ nhớ và hiệu suất của chương trình. Để hỗ trợ việc lập trình hiệu quả, Arduino cung cấp một số hàm hỗ trợ như sizeof() để xác định kích thước của dữ liệu. Hàm và thủ tục trong Arduino được chia thành các nhóm chức năng khác nhau như nhập xuất digital (pinMode(), digitalWrite(), digitalRead()), nhập xuất analog (analogReference(), analogRead(), analogWrite()), và các hàm thời gian như millis(), micros(), delay(), delayMicroseconds(). Các hàm toán học cơ bản như min(), max(), abs(), map(), pow(), sqrt() cũng rất hữu ích, cùng với các hàm lượng giác như cos(), sin(), tan(), asin() và các hàm xử lý chuỗi, số ngẫu nhiên, và giao tiếp như tone(), noTone(), shiftOut(), shiftIn(), pulseIn(). Các hàm ngắt và giao tiếp serial cũng hỗ trợ việc tương tác giữa các mạch Arduino và các thiết bị ngoại vi",
        "Summary": "Trong lập trình Arduino, biến số và hằng số là những khái niệm quan trọng, với hằng số có giá trị không thay đổi trong suốt chương trình. Arduino hỗ trợ nhiều kiểu dữ liệu khác nhau, bao gồm int, float, và string, cùng với các hàm chuyển đổi kiểu dữ liệu và xác định kích thước dữ liệu. Ngoài ra, Arduino cung cấp nhiều hàm hỗ trợ cho các chức năng như nhập xuất số, toán học, thời gian, và giao tiếp, giúp việc lập trình và tương tác với phần cứng hiệu quả hơn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các khái niệm cơ bản và các hàm hỗ trợ chính trong lập trình Arduino."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan đến nội dung chính của văn bản gốc. Bản tóm tắt đã làm nổi bật được những điểm quan trọng nhất về biến, hằng, kiểu dữ liệu và các hàm hỗ trợ trong lập trình Arduino. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00085",
        "Article": "Các chương trình thường cần phải lặp đi lặp lại một hoạt động nào đó. Ví dụ, một chương trình xếp loại học lực sẽ chứa các lệnh rẽ nhánh để gán xếp loại A, B, C… cho một sinh viên tùy theo điểm số của sinh viên này. Để xếp loại cho cả một lớp, chương trình sẽ phải lặp lại thao tác đó cho từng sinh viên trong lớp. Phần chương trình lặp đi lặp lại một lệnh hoặc một khối lệnh được gọi là một vòng lặp. Lệnh hoặc khối lệnh được lặp đi lặp lại được gọi là thân của vòng lặp. Cấu trúc lặp cho phép lập trình viên chỉ thị cho chương trình lặp đi lặp lại một hoạt động trong khi một điều kiện nào đó vẫn được thỏa mãn. Khi thiết kế một vòng lặp, ta cần xác định thân vòng lặp thực hiện hành động gì. Ngoài ra, ta còn cần một cơ chế để quyết định khi nào vòng lặp sẽ kết thúc. Mục này sẽ giới thiệu về các lệnh lặp mà Java cung cấp. Vòng while Vòng while lặp đi lặp lại chuỗi hành động, gọi là thân vòng lặp, nếu như điều kiện lặp vẫn còn được thỏa mãn. Cú pháp của vòng lặp while như sau: while (điều_kiện_lặp) thân_vòng_lặp Cấu trúc này bắt đầu bằng từ khóa while, tiếp theo là điều kiện lặp đặt trong một cặp ngoặc đơn, cuối cùng là thân vòng lặp. Thân vòng lặp hay chứa nhiều hơn một lệnh và khi đó thì phải được gói trong một cặp ngoặc à â. Khi thực thi một cấu trúc while, đầu tiên chương trình kiểm tra giá trị của biểu thức điều kiện, nếu biểu thức cho giá trị false thì nhảy đến điểm kết thúc lệnh while, còn nếu điều kiện lặp có giá trị true thì tiến hành thực hiện tập lệnh trong thân vòng lặp rồi quay trở lại kiểm tra điều kiện lặp, nếu không thỏa mãn thì kết thúc, nếu thỏa mãn thì lại thực thi thân vòng lặp rồi quay lại... Tập lệnh ở thân vòng lặp có thể làm thay đổi giá trị của biểu thức điều kiện từ true sang false để dừng vòng lặp.",
        "Summary": "Đoạn văn mô tả cấu trúc vòng lặp trong lập trình, đặc biệt là vòng lặp `while` trong Java. Vòng lặp `while` thực hiện lặp lại một khối lệnh (thân vòng lặp) cho đến khi điều kiện kiểm tra trở thành `false`. Cú pháp bao gồm từ khóa `while`, điều kiện trong ngoặc đơn và thân vòng lặp. Thân vòng lặp cần được thiết kế để điều kiện kiểm tra cuối cùng trở nên sai, đảm bảo vòng lặp kết thúc. Java cung cấp các cấu trúc lặp để xử lý các thao tác lặp đi lặp lại hiệu quả.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa vòng lặp, cấu trúc `while` và cách thức hoạt động của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00086",
        "Article": "Hình 9.5: Giao diện hiễn thịmã nguồn và đồthịdòng điều khiển. Công cụkiểm thửcho các đơn vịchương trình viết bằng Java, JUnit4, cung cấp một cơ sởhạtầng chuẩn cho việc thiết lập các bộkiểm thử. Một khi bộ kiểm thửđược thiết lập, nó có thểtựđộng chạy mỗi khi mã thay đổi. JUnit khuyến khích các nhà phát triển viết các kịch bản kiểm thử, chèn các mã kiểm thửvào mã nguồn Java và thực hiện chúng đểphát hiện các lỗi bên trong đơn vịchương trình. Khác với các công cụkhác, JUnit không hỗtrợ cơ chếsinh các ca kiểm thử. Hiện nay, JUnit đã được tích hợp trong Eclipse và hỗtrợrất đắc lực cho quá trình kiểm thử. 9.3. MỘT SỐCÔNG CỤKIỂM THỬTỰĐỘNG Hình 9.6: Báo cáo kiểm thửđược sinh bởi công cụJDFT. Quick Test Professional5 là phần mềm kiểm soát việc kiểm thửtựđộng các chức năng của các sản phẩm phần mềm cần kiểm thử. Sản phẩm này bao gồm một tập các mô-đun có thểtương tác với nhau nhằm quản lý toàn bộ quy trình kiểm thửphần mềm. Quick Test Professional là một công cụhỗ trợkiểm thửhàm (kiểm thửchức năng) và cho phép tiến hành kiểm thửhồi Apache JMeter6 được dùng đểkiểm thửkhảnăng chịu tải và kiểm thửhiệu năng cho các ứng dụng Web và một sốứng dụng khác. Công cụnày hỗtrợ kiểm thửhiệu năng của các mã nguồn được viết bằng các ngôn ngữkhác nhau như PHP, Java, ASP.NET, . . . Apache JMeter mô phỏng khảnăng chịu tải của các máy chủtrên máy sửdụng đểkiểm thửhệthống. Công cụ này hỗtrợgiao diện đồhọa giúp phân tích tốt hiệu suất khi kiểm thửđồng thời nhiều ca kiểm thử. Ngoài ra, Apache JMeter còn hỗtrợthêm nhiều tiện ích khác. Các tiện ích này được cung cấp tại 7. Load Runner8 giảlập một môi trường ảo gồm nhiều người dùng thực hiện các giao dịch cùng một lúc nhằm giám sát các thông sốxửlý của phần mềm cần kiểm thử.",
        "Summary": "Công cụkiểm thửcho các đơn vịchương trình viết bằng Java, JUnit4, cung cấp một cơ sởhạtầng chuẩn cho việc thiết lập các bộkiểm thử. Sản phẩm này bao gồm một tập các mô-đun có thểtương tác với nhau nhằm quản lý toàn bộ quy trình kiểm thửphần mềm. Quick Test Professional là một công cụhỗ trợkiểm thửhàm kiểm thửchức năng và cho phép tiến hành kiểm thửhồi Apache JMeter6 được dùng đểkiểm thửkhảnăng chịu tải và kiểm thửhiệu năng cho các ứng dụng Web và một sốứng dụng khác.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được liên kết với nhau một cách rõ ràng. Tuy nhiên, có thể cải thiện bằng cách sử dụng các từ nối để tăng tính trôi chảy giữa các ý."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào các công cụ kiểm thử. Tuy nhiên, có thể lược bỏ bớt một vài chi tiết nhỏ để bản tóm tắt ngắn gọn và tập trung hơn vào các ý chính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và liên quan. Tuy nhiên, cần chú ý hơn đến tính mạch lạc và loại bỏ một số chi tiết thừa để bản tóm tắt trở nên súc tích và hiệu quả hơn."
            }
        }
    },
    {
        "Index": "00087",
        "Article": "Quá trình chơi cờ là quá trình mà Trắng và Đen thay phiên nhau đưa ra các nước đi hợp lệ cho đến khi dẫn đến trạng thái kết thúc cuộc chơi. Quá trình này biểu diễn bởi đường đi từ nút gốc tới nút lá trên cây trò chơi. Giả sử tại một đỉnh u nào đó trên đường đi, nếu u là đỉnh Trắng (Đen) thì cần chọn một nước đi nào đó đến một trong các đỉnh con Đen (Trắng) v của u. Tại đỉnh Đen (Trắng) v sẽ chọn đi tiếp đến một đỉnh con Trắng (Đen) w của v. Quá trình này tiếp tục cho đến khi đạt đến một đỉnh lá của cây. Chiến lược tìm nước đi của Trắng hay Đen là luôn tìm những nước đi dẫn tới trạng thái tốt nhất cho mình và tồi nhất cho đối thủ. Giả sử Trắng cần tìm nước đi tại đỉnh u, nước đi tối ưu cho Trắng là nước đi dẫn tới đỉnh con v sao cho v là tốt nhất trong số các đỉnh con của u. Đến lượt Đen chọn nước đi từ v, Đen cũng chọn nước đi tốt nhất cho mình. Để chọn nước đi tối ưu cho Trắng tại đỉnh u, cần xác định giá trị các đỉnh của cây trò chơi gốc u. Giá trị của các đỉnh lá ứng với giá trị của hàm kết cuộc. Đỉnh có giá trị càng lớn càng tốt cho Trắng, đỉnh có giá trị càng nhỏ càng tốt cho Đen. Để xác định giá trị các đỉnh của cây trò chơi gốc u, ta đi từ mức thấp nhất (các đỉnh lá) lên gốc u. Giả sử cần xác định giá trị của đỉnh v mà các đỉnh con của nó đã xác định. Khi đó, nếu v là đỉnh Trắng thì giá trị của nó là giá trị lớn nhất trong các đỉnh con, nếu v là đỉnh Đen thì giá trị của nó là giá trị nhỏ nhất trong các đỉnh con.",
        "Summary": "Quá trình chơi cờ được mô tả qua việc Trắng và Đen thay phiên nhau chọn nước đi hợp lệ, tiếp tục cho đến khi đạt trạng thái kết thúc. Chiến lược của mỗi người là chọn nước đi tốt nhất cho mình và tồi nhất cho đối thủ. Để xác định nước đi tối ưu tại mỗi đỉnh, ta tính giá trị của các đỉnh lá dựa trên hàm kết cuộc và đi ngược từ các lá lên gốc. Đỉnh của Trắng sẽ có giá trị lớn nhất trong các đỉnh con, còn đỉnh của Đen có giá trị nhỏ nhất.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào những ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất để truyền tải thông điệp cốt lõi."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00088",
        "Article": "2.2.3 Phần cứng cảm biến\n Một tổ chức muốn thực hiện giám sát an toàn mạng một cách thực sự nghiêm túc thì cần phải\n đầu tư vào phần cứng tin cậy, và phần cứng cho các cảm biến ở đây nên thuộc cấp độ của máy\n chủ (những loại khác thường chỉ được chấp nhận với kịch bản phòng thí nghiệm). Các yếu tố kỹ\n thuật cần thiết để xác định số lượng tài nguyên phần cứng cần thiết bao gồm các loại cảm biến\n được triển khai, số lượng dữ liệu được thu thập bởi các cảm biến, và số lượng dữ liệu cần được\n lưu giữ.\n Có một cách được sử dụng để xác định các yêu cầu phần cứng quan trọng của cảm biến là\n thiết lập và cấu hình một cảm biến tạm thời. Cảm biến này có thể là một máy chủ, máy trạm hoặc\n thậm chí là một máy tính xách tay. Vị trí của cảm biến cũng cần được xác định trước khi các cảm\n biến này được cài đặt, bao gồm cả vị trí vật lý và vị trí logic để xác định những gì mà các cảm\n biến trên mạng cần phải theo dõi.\n Sau khi các cảm biến tạm thời được cài đặt trên mạng, cần sử dụng một cổng SPAN (SPAN\n port) hoặc một bộ trích dữ liệu mạng (network tap) để dẫn lưu lượng dữ liệu vào thiết bị. Sau đó,\n có thể cài đặt các công cụ thu thập dữ liệu, phát hiện xâm nhập và phân tích dữ liệu vào các cảm\n biến để xác định các yêu cầu về hiệu suất của các công cụ riêng lẻ. Chú ý là không nhất thiết phải\n có một cảm biến tạm thời rất mạnh có khả năng xử lý tất cả những công cụ này khi chúng được\n kích hoạt đồng thời, mà chỉ cần kích hoạt các công cụ riêng để tính toán tải trọng hoạt động của\n nó, và sau đó sẽ tổng hợp kết quả từ tất cả các công cụ để đánh giá nhu cầu tổng thể.",
        "Summary": "Để giám sát an toàn mạng hiệu quả, tổ chức cần đầu tư vào phần cứng cảm biến cấp máy chủ. Để xác định yêu cầu phần cứng, nên thiết lập cảm biến tạm thời (máy chủ, máy trạm, laptop) ở vị trí vật lý và logic phù hợp để theo dõi mạng. Sử dụng cổng SPAN hoặc network tap để dẫn lưu lượng dữ liệu vào cảm biến tạm thời, sau đó cài đặt và kích hoạt riêng lẻ các công cụ thu thập, phát hiện xâm nhập và phân tích dữ liệu để đánh giá yêu cầu hiệu suất của từng công cụ, rồi tổng hợp kết quả để xác định nhu cầu phần cứng tổng thể.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, theo đúng trình tự trong văn bản gốc. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng theo dõi và hiểu nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về yêu cầu phần cứng cho cảm biến trong giám sát an toàn mạng và phương pháp xác định các yêu cầu này. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00089",
        "Article": "Dịch vụ chia sẻ và quản lý tập tin là một phần quan trọng trong việc quản lý tài nguyên trên hệ thống mạng. Với Windows Server, người quản trị có thể dễ dàng chia sẻ các thư mục và tài nguyên giữa các người dùng, đồng thời kiểm soát quyền truy cập và bảo mật của các tài nguyên này. Để chia sẻ một thư mục dùng chung, người quản trị cần đăng nhập với quyền quản trị (Administrators) hoặc là thành viên nhóm Server Operators. Sau đó, trong Windows Explorer, người quản trị chỉ cần nhấp chuột phải vào thư mục muốn chia sẻ, chọn Properties, và trong hộp thoại xuất hiện, chọn tab Sharing để cấu hình chia sẻ thư mục. Quá trình này cho phép các người dùng trên mạng truy cập và sử dụng thư mục một cách dễ dàng. Khi thiết lập chia sẻ thư mục, người quản trị cần cấu hình Share Permissions để cấp quyền cho các người dùng truy cập qua mạng. Share Permissions chỉ có hiệu lực khi người dùng truy cập qua mạng, không ảnh hưởng khi người dùng truy cập trực tiếp vào hệ thống. Các quyền chia sẻ bao gồm Full Control (toàn quyền quản lý thư mục), Change (thay đổi dữ liệu và xóa tập tin trong thư mục), và Read (chỉ đọc và thực thi các tập tin trong thư mục). Để cấp quyền, người quản trị cần nhấn Add, chọn người dùng hoặc nhóm và sau đó đánh dấu vào các quyền phù hợp. Trong môi trường mạng với số lượng người dùng lớn, việc quản lý các thư mục chia sẻ có thể gặp phải các vấn đề về hiệu suất và bảo mật. Để giải quyết vấn đề này, Windows Server cung cấp công cụ Computer Management, giúp người quản trị dễ dàng theo dõi và quản lý các thư mục đang được chia sẻ. Trong công cụ này, menu Shares hiển thị danh sách các thư mục chia sẻ, đường dẫn và thông tin liên quan như số lượng client kết nối. Các thư mục có dấu $ ở cuối là các thư mục chia sẻ ẩn. Ngoài ra, công cụ quản lý còn cho phép theo dõi các Sessions, hiển thị thông tin về người dùng đang truy cập vào thư mục chia sẻ, bao gồm tên tài khoản, máy tính đang kết nối, hệ điều hành sử dụng và thời gian kết nối. Menu Open Files giúp hiển thị các tập tin đang được mở trong thư mục chia sẻ, đồng thời cung cấp thông tin về trạng thái của các tập tin như có đang bị khóa hay không và liệu người dùng có quyền Read hay Write tập tin. Tóm lại, dịch vụ chia sẻ và quản lý tập tin trên Windows Server cung cấp các công cụ mạnh mẽ để quản lý tài nguyên mạng hiệu quả, đảm bảo bảo mật và tối ưu hiệu suất hệ thống.",
        "Summary": "Dịch vụ chia sẻ và quản lý tập tin trên Windows Server cho phép người quản trị dễ dàng chia sẻ tài nguyên và kiểm soát quyền truy cập. Người quản trị có thể chia sẻ thư mục bằng cách cấu hình Share Permissions để cấp quyền truy cập qua mạng. Các quyền chia sẻ gồm Full Control, Change và Read. Công cụ Computer Management giúp quản lý hiệu quả các thư mục chia sẻ, theo dõi các kết nối client và hiển thị các phiên làm việc, tập tin mở, cũng như trạng thái của các tập tin. Tóm lại, dịch vụ này giúp quản lý tài nguyên mạng, bảo mật và tối ưu hiệu suất hệ thống.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các khía cạnh quan trọng của dịch vụ chia sẻ và quản lý tập tin trên Windows Server."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về dịch vụ chia sẻ và quản lý tập tin trên Windows Server. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00090",
        "Article": "Để hạn chế không gian tìm kiếm lời giải của bài toán, chúng ta biểu diễn KB và q bằng chỉ các câu dạng chuẩn hội (xem mục 4), khi đó chúng ta chỉ cần áp dụng một loại luật là luật phân giải trên KB và mỗi phép chuyển là một phép phân giải hai câu có chứa ít nhất một literal là phủ định của nhau trong KB, kết quả của phép phân giải hai câu dạng chuẩn hội lại là một câu dạng chuẩn hội và được bổ sung vào KB, lặp lại áp dụng luật phân giải trên KB đến khi nào KB chứa câu q thì dừng. Chi tiết thuật toán suy diễn dựa trên luật phân giải KB╞ q được trình bày trong mục 7 của Chương này (thực tế thì thuật toán suy diễn phân giải trả lời bài toán tương đương (KB ∧ ¬q)╞ [].) Giải thuật suy diễn phân giải là giải thuật đầy đủ trong logic mệnh đề, tức là với mọi câu q mà kéo theo được từ KB (q đúng khi KB đúng) thì sử dụng giải thuật suy diễn phân giải đều có thể suy diễn được KB ╞ q (tức là không có câu nào kéo được từ KB là không suy diễn phân giải được); bởi vì bất cứ câu trong logic mệnh đề đều có thể biểu diễn được bằng câu dạng chuẩn hội (xem mục 4). Do liên tục phải bổ sung các câu mới vào KB và lặp lại tìm kiếm các cặp câu có thể phân giải với nhau được nên nhân tố nhánh của cây tìm kiếm lời giải tăng dần theo độ sâu của cây tìm kiếm. Vì vậy không gian và thời gian của giải thuật sẽ tăng rất nhanh, giải thuật phân giải làm việc không hiệu quả. Để khắc phục nhược điểm này, người ta tìm cách biểu diễn KB dạng các câu Horn và áp dụng chỉ một loại luật (tam đoạn luận, xem mục 5) để suy diễn (tam đoạn luận áp dụng trên 2 câu dạng Horn và sinh ra câu mới cũng là câu dạng Horn). Thuật giải suy diễn tiến/lùi trên cơ sở tri thức dạng Horn trình bày chi tiết trong mục 8, nó có độ phức tạp tuyến tính đối với số câu trong KB.",
        "Summary": "Chi tiết thuật toán suy diễn dựa trên luật phân giải KB q được trình bày trong mục 7 của Chương này thực tế thì thuật toán suy diễn phân giải trả lời bài toán tương đương KB q . Thuật giải suy diễn tiếnlùi trên cơ sở tri thức dạng Horn trình bày chi tiết trong mục 8, nó có độ phức tạp tuyến tính đối với số câu trong KB.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt gần như hoàn toàn trung thực. Tuy nhiên, có một chi tiết nhỏ cần xem xét: Biểu thức 'KB q' trong bản tóm tắt có thể gây hiểu nhầm vì thiếu ký hiệu '╞' (dẫn xuất logic). Trong văn bản gốc, biểu thức này xuất hiện dưới dạng 'KB╞ q', thể hiện rõ ràng mối quan hệ kéo theo logic. Việc lược bỏ ký hiệu này có thể làm thay đổi ý nghĩa một chút, dù không lớn."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, nhưng sự liên kết giữa hai câu còn yếu. Việc liệt kê hai thuật toán mà không giải thích mối liên hệ hoặc mục đích chung của chúng khiến người đọc khó nắm bắt được ý chính. Cần có một câu dẫn nhập hoặc kết nối để làm rõ hơn vai trò của hai thuật toán này trong việc giải quyết vấn đề."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có chọn lọc một số ý từ văn bản gốc, nhưng bỏ qua nhiều thông tin quan trọng khác. Ví dụ, văn bản gốc giải thích lý do tại sao giải thuật phân giải không hiệu quả và tại sao cần sử dụng dạng Horn. Bản tóm tắt hiện tại chỉ đơn thuần liệt kê hai thuật toán mà không cung cấp bối cảnh hoặc động cơ, làm giảm đi giá trị thông tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức trung bình. Điểm mạnh là trung thực với thông tin trong văn bản gốc. Tuy nhiên, bản tóm tắt thiếu tính mạch lạc và liên quan do bỏ qua nhiều chi tiết quan trọng, khiến người đọc khó hiểu được bức tranh toàn cảnh. Để cải thiện, cần bổ sung thêm thông tin về bối cảnh, mục đích của các thuật toán, và mối liên hệ giữa chúng. Đồng thời, cần đảm bảo tính chính xác tuyệt đối trong việc sao chép các ký hiệu logic."
            }
        }
    },
    {
        "Index": "00091",
        "Article": "Khi xây dựng cây quyết định, nếu để độ sâu tùy ý thì cây sẽ phân loại đúng hết các dữ liệu trong tập học, dẫn đến mô hình có thể dự đoán tệ trên tập kiểm thử. Khi đó mô hình bị quá khớp. Thuật toán Random Forests gồm nhiều cây quyết định, mỗi cây quyết định đều có những yếu tố ngẫu nhiên: 1. Lấy ngẫu nhiên dữ liệu để xây dựng cây quyết định. 2. Lấy ngẫu nhiên các thuộc tính để đặt vào một đỉnh. Do mỗi cây quyết định trong thuật toán học Random Forests không dùng tất cả dữ liệu luyện, cũng như không dùng tất cả các thuộc tính của dữ liệu để xây dựng cây nên mỗi cây có thể sẽ dự đoán không tốt, khi đó mỗi mô hình cây quyết định không bị quá khớp mà có thế bị kém khớp, hay nói cách khác là mô hình có high bias. Tuy nhiên, kết quả cuối cùng của thuật toán Random Forests lại tổng hợp từ nhiều cây quyết định, thế nên thông tin từ các cây sẽ bổ sung thông tin cho nhau, dẫn đến mô hình có độ lệch và phương sai bé, hay mô hình có kết quả dự đoán tốt. Random Forest là một thuật toán học máy phổ biến thuộc về phương pháp học có giám sát. Nó có thể được sử dụng cho cả bài toán Phân loại và Hồi quy trong Học máy. Nó dựa trên khái niệm học kết hợp, là một quá trình kết hợp nhiều bộ phân loại để giải quyết một vấn đề phức tạp và để cải thiện hiệu suất của mô hình. Rừng ngẫu nhiên cũng là một thuật toán học máy linh hoạt, dễ sử dụng, tạo ra kết quả tuyệt vời ngay cả khi không điều chỉnh siêu tham số. Nó cũng là một trong những thuật toán được sử dụng nhiều nhất, do tính đơn giản và đa dạng của nó. Như tên gọi của phương pháp học máy này, “Rừng ngẫu nhiên là một bộ phân loại chứa một số cây quyết định trên các tập con khác nhau của tập dữ liệu cũng như các tập con thuộc tính khác nhau và lấy giá trị dự đoán trung bình để cải thiện độ chính xác dự đoán của tập dữ liệu đó.”",
        "Summary": "Random Forests là một thuật toán học máy có giám sát, sử dụng nhiều cây quyết định được xây dựng ngẫu nhiên từ các tập dữ liệu và thuộc tính con. Mỗi cây có thể kém khớp (high bias) do không sử dụng toàn bộ dữ liệu và thuộc tính, nhưng kết quả cuối cùng được tổng hợp từ nhiều cây, bổ sung thông tin cho nhau, giúp giảm độ lệch và phương sai, mang lại kết quả dự đoán tốt. Thuật toán này linh hoạt, dễ sử dụng và hiệu quả cho cả bài toán phân loại và hồi quy.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của thuật toán Random Forests, ưu điểm và ứng dụng của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về thuật toán Random Forests. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00092",
        "Article": "3.2. Sao chép, cắt dán, xóa văn bản\n Sao chép văn bản\n Trong quá trình soạn thảo, chỉnh sửa văn bản bạn thường xuyên có nhu cầu sao chép một phần, hoặc toàn\n bộ nội dung từ văn bản này sang văn bản khác hoặc giữa các đoạn trong cùng một văn bản. Để thực hiện\n bạn có thể làm theo các bước sau đây:\n Bước 1: Lựa chọn (bôi đen) nội dung văn bản cần sao chép\n Bước 2: Tiếp theo thực hiện theo một trong các cách sau đây:\n - Nhấn tổ hợp phím Ctrl + C\n - Nhấp phải chuột chọn Copy\n - Trong Tab Home trên thanh công cụ Ribbon tìm tới nhóm Clipboard chọn nút Copy.\n Cắt văn bản\n Trong một số trường hợp bạn cần di chuyển một đoạn văn bản từ vị trí này tới vị trí khác, hay từ văn bản\n này sang văn bản khác bạn có thể sử dụng chức năng Cut văn bản của Microsoft Word 2013. Cách thực\n hiện như sau:\n Bước 1: Chọn nội dung văn bản cần cắt (Cut).\n Bước 2: Thực hiện theo một trong các cách sau đây:\n - Nhấn tổ hợp phím Ctrl + X\n - Nhấp phải chuột chọn Cut\n - Nhấp chọn Tab Home trên thanh công cụ Ribbon, tìm tới nhóm Clipboard chọn biểu tượng Cut.\n Dán văn bản\n Sao khi sao chép hay cắt nội dung văn bản ở hai phần trước nhu cầu tiếp theo của bạn chắc chắn là cần\n phải dón nó vào một vị trí nào đó. Để thực hiện bạn làm như sau:\n Bước 1: Nhấp trỏ chuột tới vị trí cần dán văn bản.\n Bước 2: Thực hiện theo một trong các cách sau đây:\n - Nhấn tổ hợp phím Ctrl + V\n - Nhấp phải chuột trong mục Paste Options\n + Keep source formatting: Dán cả nội dung Text và dữ lại định dạng như nguyên gốc.\n + Merge formatting: Dán nội dung Text và hòa chộn định dạng gốc với định dạng của vị trí cần dán.\n + Keep Text Only: Chỉ dán mình nội dung Text, lấy định dạng theo định dạng của vị trí con trỏ hiện\n thời.\n - Nhấp chọn Tab Home trên thanh công cụ Ribbon chọn tới nhóm Clipboard.\n + Chọn biểu tượng Paste: Copy theo mặc định\n + Keep source formatting: Dán cả nội dung Text và dữ lại định dạng như nguyên gốc.\n + Merge formatting: Dán nội dung Text và hòa chộn định dạng gốc với định dạng của vị trí cần dán.\n + Keep Text Only: Chỉ dán mình nội dung Text, lấy định dạng theo định dạng của vị trí con trỏ hiện\n thời.\n - Nhấp chọn Tab Home trên thanh công cụ Ribbon chọn tới nhóm Clipboard.\n Xóa văn bản\n Bạn có thể thực hiện xóa chỉ một ký tự hoặc xoá một đoạn hay cả văn bản. Chương trình sẽ thực hiện\n lệnh xóa với những ký tự mà bạn đã chọn.\n - Xoá một ký tự: Đặt con trỏ Text trong văn bản, gõ phím Delete để xoá một ký tự ở bên phải con trỏ Text,\n gõ phím Backspace để xoá một ký tự ở bên trái con trỏ Text.\n - Xoá một đoạn văn bản: Đánh dấu chọn đoạn văn bản mà bạn cần xóa, nhấn phím Delete hoặc phím\n Backspace để xóa đoạn văn bản đó.",
        "Summary": "\"Văn bản hướng dẫn cách sao chép, cắt, dán và xóa văn bản trong Microsoft Word 2013. Để sao chép hoặc cắt văn bản, chọn nội dung cần thao tác, sau đó sử dụng tổ hợp phím (Ctrl+C/Ctrl+X), chuột phải hoặc lệnh trong nhóm Clipboard của tab Home. Để dán văn bản, di chuyển con trỏ tới vị trí cần dán và sử dụng tổ hợp phím (Ctrl+V), chuột phải (với các tùy chọn định dạng khác nhau) hoặc lệnh Paste trong nhóm Clipboard của tab Home. Để xóa văn bản, có thể xóa từng ký tự bằng phím Delete (xóa ký tự bên phải) hoặc Backspace (xóa ký tự bên trái), hoặc xóa cả đoạn văn bản bằng cách chọn đoạn văn bản và nhấn Delete hoặc Backspace.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, dễ hiểu. Các câu liên kết với nhau một cách trôi chảy, tạo thành một đoạn văn hoàn chỉnh."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào cách thực hiện các thao tác sao chép, cắt, dán và xóa văn bản."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã bao quát được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00093",
        "Article": "3.2. Phương pháp LSB\n Cách thay thế LSB là cách đơn giản để nhúng thông tin vào một tệp âm thanh kỹ thuật\n số. Phương pháp LSB cho phép một lượng lớn dữ liệu được nhúng, tốc độ truyền dữ liệu\n nhanh. Chi tiết về phương pháp thay thế LSB đã được trình bày trong chương 2 (kỹ thuật giấu\n tin trong ảnh). Điểm cần lưu ý đối với phương pháp LSB trong âm thanh là thông tin sẽ được\n giấu vào trong file âm thanh. Để thực hiện được điều đó thì người giấu tin cần thực hiện những\n thao tác sau:\n ü Bước 1: Đọc file âm thanh gốc. Chia âm thanh gốc thành các segmen. Thông thường,\n người giấu tin sẽ chia file âm thanh các segmen dựa trên độ dài bit của thông tin cần giấu. Sau\n đó các segmen này được vector giá trị của tín hiệu, rồi lưu vào mảng một chiều để thực hiện\n giấu tin.\n ü Bước 2: Chuyển đổi thông tin cần giấu sang dạng nhị phân, tính độ dài bit của thông\n tin rồi lưu vào L.62\n ü Bước 3: Chọn k là số bit LSB của tín hiệu âm thanh sẽ giấu sao cho phù hợp nhất.\n ü Bước 4: Chia chuỗi bit thông điệp thành các chuỗi con có độ dài k bit. Trong đó, mỗi\n chuỗi con này sẽ được thay thế vào k bit LSB của L k tín hiệu âm thanh để giấu đủ L bit thông\n điệp.\n ü Bước 5: Thực hiện giấu L bit đã tính vào các segmen. Để tăng độ an toàn cho kỹ thuật\n này, có thể sử dụng bộ sinh số ngẫu nhiên để sinh ra các vị trí các mẫu được chọn giấu chứ\n không phải các mẫu liên tục. Bộ sinh số này sử dụng một khóa bí mật như là phần tử khởi tạo\n bộ sinh số. Khóa được sử dụng trong cả quá trình giấu tin và giải tin.\n ü Bước 6: Lưu lại tệp âm thanh kết quả F’ được thông tin đã giấu Hình 3.2 thể hiện pháp thay thế LSB với trường hợp thay thế 1 bit LSB. Trong thực tế\n hiện nay cũng có một số hướng tiếp cận khác nhằm nâng cao chất lượng giấu tin trong kỹ thuật\n LSB. Ví dụ phương pháp sử dụng 4 bit LSB thay vì 1 bit LSB đơn lẻ hoặc phương pháp kết\n hợp giữa bít quan trọng nhất (MSB -Most Significant Bit) và LSB. Chi tiết các phương pháp\n này đã được trình bày trong một số bài báo [16, 17]. Hình 3.3 và 3.4 dưới đây mô tả quy trình\n giấu tin sử dụng 4 bit LSB và 7 bit MSB",
        "Summary": "\"Phương pháp LSB là một cách đơn giản để nhúng thông tin vào tệp âm thanh kỹ thuật số với tốc độ truyền dữ liệu nhanh. Để giấu tin, người dùng cần đọc file âm thanh gốc, chia thành các segment dựa trên độ dài bit của thông tin cần giấu, chuyển đổi thông tin cần giấu sang dạng nhị phân, chọn số bit LSB (k) phù hợp, chia chuỗi bit thông điệp thành các chuỗi con có độ dài k bit, thay thế vào k bit LSB của tín hiệu âm thanh, và lưu lại tệp âm thanh kết quả. Để tăng độ an toàn, có thể sử dụng bộ sinh số ngẫu nhiên để chọn vị trí giấu tin. Ngoài ra, có các phương pháp nâng cao chất lượng bằng cách sử dụng nhiều bit LSB hơn (ví dụ 4 bit) hoặc kết hợp MSB và LSB.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, theo đúng trình tự các bước trong quy trình giấu tin bằng phương pháp LSB. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng theo dõi và hiểu nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa phương pháp LSB, các bước thực hiện giấu tin, và các phương pháp nâng cao. Các chi tiết không quan trọng đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00094",
        "Article": "Phát hiện khuôn mặt và tăng cường dữ\n liệu ảnh với MTCNN\n 3.3.1. Phát hiện khuôn mặt\n Với một ảnh đầu vào, đầu tiên, hệ thống\n phải thực hiện phát hiện khuôn mặt (Face\n detection) với MTCNN (Ku Hongchang,\n 2020), một mô hình mạng nơ-ron tích hợp\n CNN hoạt động đa nhiệm. MTCNN là gồm\n ba lớp Mạng đề xuất P-net (Proposal\n Network), Mạng tinh chỉnh R-net (Refine\n Network) và Mạng đầu ra O-net (Output\n Network). Hình 4 mô tả thuật toán MTCNN. Ban đầu các hình ảnh đầu vào được đưa\n vào P-Net để điều chỉnh kích thước để phát\n hiện các khuôn mặt có tất cả các kích thước\n khác nhau, đồng thời lấy ra các cửa sổ có thể\n là khuôn mặt và các vectơ hồi quy trong các\n cửa sổ đó. Sau đó, các cửa sổ này được sàng\n lọc thông qua mạng R-Net để loại bỏ phần\n lớn các cửa sổ không chứa khuôn mặt. Cuối\n cùng, Mạng đầu ra (O-Net) được sử dụng để\n chọn lọc kết quả chính xác một lần nữa và\n đánh dấu tọa độ của năm điểm mốc trên\n khuôn mặt.\n 3.3.2. Tăng cường dữ liệu ảnh\n Bộ dữ liệu quy mô lớn là điều kiện cần\n thiết để huấn luyện thành công mạng nơ-ron.\n Công nghệ tăng cường hình ảnh sử dụng một\n loạt các thay đổi ngẫu nhiên đối với hình ảnh\n đào tạo để tạo ra các mẫu đào tạo tương tự\n nhưng khác nhau, do đó mở rộng kích thước\n của tập dữ liệu. Để nâng cao độ chính xác\n của mô hình khi nhận diện, thư viện MTCNN\n được sử dụng để tăng cường hình ảnh, được\n mô tả trong hình 5, cụ thể như sau:\n · Chuẩn hóa theo phân phối chuẩn các\n pixels của ảnh;\n · Tạo các ảnh với các góc nghiêng là\n 20 độ (trái, phải);\n · Dịch chuyển ảnh theo rộng;\n · Dịch chuyển ảnh theo chiều cao;\n · Lật ảnh theo chiều ngang;Như vậy, với từ một hình ảnh khuôn mặt\n được phát hiện, chúng tôi tăng cường thêm 9\n hình ảnh, tạo ra tập dữ liệu ảnh cho đầu vào\n mô hình FaceNet là 7700 ảnh. Mỗi lớp (thư\n mục ảnh) được chia thành 80-20 cho huấn\n luyện (training) và thử nghiệm (testing).",
        "Summary": "\"Để phát hiện khuôn mặt trong ảnh, hệ thống sử dụng MTCNN, một mô hình mạng nơ-ron tích hợp CNN đa nhiệm gồm ba lớp: P-Net, R-Net và O-Net. P-Net điều chỉnh kích thước ảnh, R-Net sàng lọc các cửa sổ không chứa khuôn mặt và O-Net chọn lọc kết quả chính xác, đánh dấu tọa độ năm điểm mốc trên khuôn mặt. Để tăng cường dữ liệu huấn luyện, thư viện MTCNN được sử dụng để tạo ra chín ảnh mới từ mỗi ảnh gốc thông qua chuẩn hóa pixel, tạo ảnh nghiêng 20 độ, dịch chuyển ảnh theo chiều rộng và cao, và lật ảnh theo chiều ngang. Tập dữ liệu ảnh sau tăng cường được chia thành tỷ lệ 80-20 cho huấn luyện và thử nghiệm.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, với sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào quy trình phát hiện khuôn mặt bằng MTCNN và phương pháp tăng cường dữ liệu ảnh, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00095",
        "Article": "Bo mạch chủ (mainboard hay motherboard) là bảng mạch lớn nhất trong máy tính, đóng vai trò trung tâm liên kết và điều khiển các thành phần phần cứng được cắm vào nó. Mainboard là cầu nối trung gian giúp các thiết bị trong hệ thống giao tiếp với nhau một cách hiệu quả.Trên bo mạch chủ, có các khe cắm RAM giúp mở rộng bộ nhớ hệ thống, khe cắm CPU dành cho bộ vi xử lý, và các khe cắm mở rộng như PCI, PCIe để kết nối card đồ họa, card âm thanh hoặc card mạng. Ngoài ra, mainboard còn có các cổng kết nối dành cho thiết bị lưu trữ (HDD, SSD) thông qua cổng SATA hoặc M.2. Các cổng giao tiếp ngoại vi như USB, HDMI, DisplayPort, COM, LPT, PS/2 giúp kết nối với chuột, bàn phím, màn hình và các thiết bị khác.Một thành phần quan trọng trên bo mạch chủ là BIOS (hoặc UEFI), phần mềm nhúng trong chip ROM giúp khởi động hệ thống và quản lý cài đặt phần cứng. Pin CMOS trên mainboard giúp duy trì đồng hồ hệ thống và các thiết lập BIOS khi máy tính bị tắt nguồn. BIOS cho phép người dùng cấu hình các thông số như thứ tự boot, tốc độ quạt, điện áp CPU, RAM, cũng như hỗ trợ ép xung để tối ưu hiệu suất hoạt động của hệ thống.Hệ thống bus trên bo mạch chủ đóng vai trò quan trọng trong việc truyền tải dữ liệu giữa các linh kiện. Bus bao gồm bus dữ liệu, bus địa chỉ và bus điều khiển, giúp CPU giao tiếp với RAM, ổ cứng và các thiết bị ngoại vi. Các loại bus hiện đại như PCIe 4.0, PCIe 5.0, USB 3.2, Thunderbolt giúp tăng tốc độ truyền tải dữ liệu, tối ưu hóa hiệu suất hệ thống.Ngoài ra, mainboard còn có hệ thống tản nhiệt với các cảm biến nhiệt độ để theo dõi và điều chỉnh tốc độ quạt nhằm giữ cho CPU và các linh kiện khác hoạt động ổn định. Một số bo mạch chủ cao cấp hỗ trợ đèn LED RGB, tích hợp Wi-Fi, Bluetooth và cổng âm thanh cao cấp để nâng cao trải nghiệm người dùng. Tùy theo nhu cầu, người dùng có thể lựa chọn mainboard phù hợp với chipset Intel hoặc AMD, hỗ trợ các dòng CPU khác nhau, cũng như cung cấp các tính năng đặc biệt phục vụ chơi game, thiết kế đồ họa hoặc làm việc chuyên sâu.",
        "Summary": "Bo mạch chủ (mainboard) là thành phần quan trọng kết nối và điều khiển các linh kiện trong máy tính, bao gồm khe cắm RAM, CPU, và các khe mở rộng như PCIe cho card đồ họa. Nó còn có cổng kết nối cho thiết bị lưu trữ và ngoại vi, cùng với BIOS/UEFI quản lý khởi động và cấu hình phần cứng. Hệ thống bus trên mainboard giúp truyền tải dữ liệu giữa các linh kiện, trong khi các tính năng như tản nhiệt, LED RGB và hỗ trợ Wi-Fi, Bluetooth mang lại trải nghiệm người dùng tối ưu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về vai trò, các thành phần, chức năng và tính năng của bo mạch chủ, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ về bo mạch chủ. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00096",
        "Article": "Phương pháp giải trực tiếp áp dụng khi bài toán có công thức rõ ràng, ví dụ tính diện tích hình tròn (S = πr²) chỉ cần nhập bán kính và áp dụng công thức. Ngược lại, phương pháp tìm kiếm lời giải dùng cho bài toán phức tạp, không có công thức cố định, như tìm đường đi ngắn nhất trong đồ thị, yêu cầu thử nghiệm các khả năng (thường dùng thuật toán vét cạn hoặc heuristic). Giáo trình minh họa qua bài toán tính UCLN của hai số: phương pháp trực tiếp dùng thuật toán Euclid (chia lấy dư liên tiếp), trong khi tìm kiếm có thể thử các ước chung từ nhỏ đến lớn. Độ phức tạp thuật toán được đánh giá qua thời gian (số phép tính) và không gian (bộ nhớ sử dụng), ví dụ thuật toán sắp xếp nổi bọt có độ phức tạp O(n²). Các bài toán được phân loại thành đơn giản (tính toán cơ bản), trung bình (xử lý mảng), và phức tạp (tối ưu hóa). Giáo trình nhấn mạnh rằng lựa chọn phương pháp phụ thuộc vào đặc điểm bài toán: nếu dữ liệu đầu vào ít và yêu cầu nhanh, giải trực tiếp là tối ưu; nếu cần khám phá nhiều khả năng, tìm kiếm là cần thiết. Các bài tập thực hành, như viết chương trình kiểm tra số nguyên tố, giúp sinh viên rèn luyện kỹ năng áp dụng cả hai phương pháp. Nội dung này không chỉ cung cấp lý thuyết mà còn hướng dẫn cách tư duy có hệ thống, từ đó giải quyết hiệu quả các vấn đề thực tế trong lập trình và khoa học máy tính. Bài toán được định nghĩa là một tình huống cần tìm lời giải, với dữ liệu đầu vào và kết quả đầu ra mong muốn.",
        "Summary": "Phương pháp giải trực tiếp được áp dụng khi giải hệ phương trình tuyến tính có số lượng ẩn không quá lớn. Điển hình là phương pháp Gauss hoặc Gauss-Jordan nhằm đưa hệ về dạng tam giác rồi giải ngược. Ưu điểm của phương pháp này là cho kết quả chính xác nếu không xảy ra sai số làm tròn. Tuy nhiên, nó không phù hợp với hệ có kích thước lớn do tiêu tốn nhiều bộ nhớ và thời gian. Việc lựa chọn đúng phương pháp giải phù hợp với bài toán giúp tối ưu hiệu quả tính toán và đảm bảo độ chính xác.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 1,
                "Đánh giá": "Bản tóm tắt hoàn toàn không trung thực. Nội dung của bản tóm tắt không hề liên quan đến nội dung của văn bản gốc. Bản tóm tắt nói về 'giải hệ phương trình tuyến tính' và 'phương pháp Gauss', trong khi văn bản gốc thảo luận về hai phương pháp giải quyết vấn đề chung: giải trực tiếp và tìm kiếm lời giải, cùng với các ví dụ và khái niệm liên quan đến độ phức tạp thuật toán và phân loại bài toán."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt tự thân nó mạch lạc. Các câu liên kết với nhau một cách logic và rõ ràng, tạo thành một đoạn văn dễ hiểu về chủ đề giải hệ phương trình tuyến tính."
            },
            "Tính liên quan": {
                "Điểm": 1,
                "Đánh giá": "Bản tóm tắt hoàn toàn không liên quan đến văn bản gốc. Nó tập trung vào một chủ đề khác (giải hệ phương trình tuyến tính) và bỏ qua hoàn toàn các ý chính của văn bản gốc (phương pháp giải trực tiếp, tìm kiếm lời giải, độ phức tạp thuật toán, phân loại bài toán)."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt này có chất lượng rất kém. Nó không trung thực, không liên quan đến văn bản gốc, mặc dù tự thân nó mạch lạc. Cần phải viết lại hoàn toàn bản tóm tắt, đảm bảo bám sát nội dung và ý chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00097",
        "Article": "Qui ước đặt tên biến và tên hằng: Prolog là ngôn ngữ cho máy tính, vì vậy nó cần một qui ước rất quan trọng trong việc đặt tên biến và tên hằng, theo đó, tên một biến phải bắt đầu bằng ký tự in hoa (chẳng hạn X, Sinhvien, v.v.), còn tên hằng phải bắt đầu bằng ký tự in thường (ví dụ: an, binh, lasinhvien, v.v.). Vì Prolog là ngôn ngữ các câu Horn trong logic vị từ cấp một nên các biến chỉ xuất hiện trong các hạng thức là tham số của các vị từ. Chương trình Prolog, các câu Horn dương: Chương trình Prolog về cơ bản là dãy (hội) các câu Horn dương (câu tuyển có đúng 1 literal dương). Các câu này có dạng Horn dương trong Prolog có dạng tổng quát như sau: head:- p1, p2, …, pn. {nghĩa là: if (p1 and p2 and … and pn) then head}. Ở đây head, P1, p2, …, pn là các vị từ (có thể có các tham số); vị từ head gọi là phần đầu của luật, còn P1, p2, …, pn gọi phần thân (phần điều kiện) của luật. Nếu n>0 thì câu Horn dương trên là câu dạng luật; còn nếu n=0 thì câu không có phần điều kiện, khi này ta có câu mô tả sự kiện và có thể viết đơn giản là: head. Chú ý: các câu trong chương trình Prolog đều kết thúc bởi dấu chấm (“.”). Tất cả các câu đều là câu đóng, nếu có ký hiệu biến xuất hiện trong câu thì ta ngầm hiểu rằng biến đó là biến buộc, đặt dưới lượng từ ∀ , trừ các biến chỉ xuất hiện trong phần điều kiện của câu thì biến đó được hiểu là đặt dưới lượng từ ∃ (thực chất thì nếu chuyển dạng câu tuyển thì ∃ sẽ chuyển sang ∀ do chuyển vế và lấy phủ định). Vị từ, hạng thức: Như đã giới thiệu ở trên, chương trình Prolog bao gồm hai loại câu: câu sự kiện (câu đơn) và câu luật (câu phức). Các câu này được xây dựng từ các vị từ (head, P1, p2, …, pn), mỗi vị từ có cú pháp như sau: tên_vi_tu(hang_thuc1, hang_thuc2, …, hang_thucn) trong đó tên_vị_từ tuân theo qui tắc đặt tên hằng; các hạng_thứci có thể là: Giá trị: tên hằng ký hiệu, ví dụ như an, x, mauxanh, v.v.; hằng xâu, ví dụ ‘Xin chao’; hằng số nguyên hoặc số thực, ví dụ như 5, 3.1416, v.v. Tên biến, ví dụ như X, Sinhvien, v.v. (chú ý: tên biến bắt đầu bằng ký tự viết hoa; các biến đều không có kiểu biến, nó có thể nhận bất cứ một giá trị nào; tất cả các biến đều là biến địa phương trong câu nó xuất hiện). Cấu trúc (nhóm các hạng thức lại thành cấu trúc), ví dụ như: mau[red, green, blue], [march, 17, 2011], v.v. Hai trường hợp đặc biệt của cấu trúc là list và string sẽ được tìm hiểu sâu hơn ở các phần sau của Chương này. Ví dụ về chương trình Prolog: chương trình lưu trong file giapha.pl của ví dụ trước bao gồm ba câu đầu là các câu sự kiện và 2 câu cuối là câu luật; có 4 ký hiệu vị từ là: cha, me, chame, ongba; có 4 tên hằng: nam, hoan, hoa, duong; có 3 biến: X,Y,Z.",
        "Summary": "Trong Prolog, tên biến bắt đầu bằng ký tự in hoa và tên hằng bắt đầu bằng ký tự in thường. Chương trình Prolog gồm các câu Horn dương, trong đó mỗi câu có một phần đầu và phần thân, với phần thân có thể là các điều kiện. Các câu trong Prolog có thể là câu sự kiện (không có điều kiện) hoặc câu luật (có điều kiện), và đều sử dụng các vị từ với các tham số, với biến được hiểu là biến buộc hoặc biến tồn tại tùy theo ngữ cảnh.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tính súc tích và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác và đầy đủ các ý chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00098",
        "Article": "Xây dựng và tối ưu hàm mất mát Tổng quát, nếu mỗi điểm dữ liệu được mô tả bởi một vector đặc trưng d chiều x ∈ R d , hàm dự đoán đầu ra được viết dưới dạng y = w1x1 + w2x2 + · · · + wdxd = x T w. (7.2) 7.2.1. Sai số dự đoán Sau khi xây dựng được mô hình dự đoán đầu ra như (7.2), ta cần tìm một phép đánh giá phù hợp với bài toán. Với bài toán hồi quy nói chung, ta mong muốn sự sai khác e giữa đầu ra thực sự y và đầu ra dự đoán yˆ là nhỏ nhất: 1 2 e 2 = 1 2 (y − yˆ) 2 = 1 2 (y − x T w) 2 . (7.3) Ở đây, bình phương được lấy vì e = y − yˆ có thể là một số âm. Việc sai số là nhỏ nhất có thể được mô tả bằng cách lấy trị tuyệt đối |e| = |y − yˆ|. Tuy nhiên, cách làm này ít được sử dụng vì hàm trị tuyệt đối không khả vi tại gốc toạ độ, không thuận tiện cho việc tối ưu. Hệ số 1 2 sẽ bị triệt tiêu khi lấy đạo hàm của e theo tham số mô hình w. 7.2.2. Hàm mất mát Điều tương tự xảy ra với tất cả các cặp dữ liệu (xi , yi), i = 1, 2, . . . , N, với N là số lượng dữ liệu trong tập huấn luyện. Việc tìm mô hình tốt nhất tương đương với việc tìm w để hàm số sau đạt giá trị nhỏ nhất: L(w) = 1 2N X N i=1 (yi − x T i w) 2 . (7.4) Hàm số L(w) chính là hàm mất mát của mô hình hồi quy tuyến tính với tham số θ = w. Ta luôn mong muốn sự mất mát là nhỏ nhất, điều này có thể đạt được bằng cách tối thiểu hàm mất mát theo w: w ∗ = argmin w L(w). (7.5) w∗ là nghiệm cần tìm của bài toán. Đôi khi dấu ∗ được bỏ đi và nghiệm có thể được viết gọn lại thành w = argmin w L(w). Machine Learning cơ bản 101 https://thuviensach.vn Chương 7. Hồi quy tuyến tính Trung bình sai số Trong machine learning, hàm mất mát thường là trung bình cộng của sai số tại mỗi điểm. Về mặt toán học, hệ số 1 2N không ảnh hưởng tới nghiệm của bài toán. Tuy nhiên, việc lấy trung bình này quan trọng vì số lượng điểm dữ liệu trong tập huấn luyện có thể thay đổi. Việc tính toán mất mát trên từng điểm dữ liệu sẽ hữu ích hơn trong việc đánh giá chất lượng mô hình. Ngoài ra, việc lấy trung bình cũng giúp tránh hiện tượng tràn số khi số lượng điểm dữ liệu lớn.",
        "Summary": "\"Hàm mất mát trong machine learning, đặc biệt là hồi quy tuyến tính, được xây dựng để đánh giá sai số giữa đầu ra dự đoán và đầu ra thực tế. Sai số thường được tính bằng bình phương sai lệch (y - xTw)^2 để đảm bảo giá trị dương và tính khả vi. Hàm mất mát L(w) là trung bình cộng của các sai số này trên toàn bộ tập huấn luyện, và mục tiêu là tìm vector trọng số w sao cho L(w) đạt giá trị nhỏ nhất, từ đó tìm ra mô hình dự đoán tốt nhất. Việc lấy trung bình sai số giúp ổn định kết quả khi số lượng dữ liệu huấn luyện thay đổi và tránh tràn số.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy và kiểm chứng trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ việc xây dựng hàm mất mát đến mục tiêu tối ưu hóa nó. Các câu liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa hàm mất mát, cách tính sai số, và mục tiêu tối ưu hóa. Không có chi tiết nào thừa hoặc không liên quan được đưa vào."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00099",
        "Article": "Các gam màu sắc Được chia làm 8 loại Màu nóng: Màu nóng tự mang trong nó sự lôi cuốn và gây chú ý, có tính phản chiếu cao. Tạo nên những ý tưởng tươi vui, cởi mở, kích động, … Nó có tác động mạnh mẽ đến không gian trong bố cục chung. Màu nóng gồm 2 màu chính là đỏ và vàng cùng các màu tương cận của chúng (như cam, hồng, tím đỏ, vàng xanh lục…). Màu lạnh: những màu cho ta cảm giác mát mẻ, ví dụ như: xanh lam, xanh lá cây, đen, tím…… Màu lạnh làm cho bức hình cảm giác tươi tắn, toả sáng, gợi cảm giác mát mẻ, nhẹ nhàng. Màu lạnh đối lập với màu nóng. Màu nóng và màu lạnh Màu tương phản: là sự đối lập của màu nóng và màu lạnh. Tương phản với các hệ thống các màu gốc: Xanh = C, Vàng = Y, Đỏ = M, nhờ có màu tương phản mà bức hình đạt được sự rực rỡ. Màu tương phản thường là những màu gốc hoặc có tính gốc cao. Bản thân các màu này có độ mạnh thị giác cao, nên khi đặt cạnh nhau trong một bố cục, các màu sẽ tạo nên thị cảm mạnh. Với những màu nóng và lạnh đứng cạnh nhau, sự tương phản sẽ dịu hơn nếu được thay đổi độ sáng tối. Màu tương đồng: Với những màu cùng Gam nóng hoặc lạnh có một sự tương quan nhất định, chúng được gọi là màu cùng tone, hoặc màu tương đồng. Trong thực tế, màu tương đồng vẫn có Phát triển Web 2012 64 www.izwebz.com Demon Warlock thể chứa một lượng màu tương phản hoặc ngược lại, vấn đề là phải xem xét lượng màu trên một diện tích và vai trò của nó đến quan hệ hoà sắc. Màu tương đồng Màu vô sắc: Là những màu mà khi ta hoà trộn chúng với nhau không tạo nên được màu mới. Ví dụ đen, trắng và các thang độ xám khi được hoà trộn. Màu vô sắc Màu bổ túc: Những cặp màu bổ túc là những cặp màu có tính tương phản mạnh, gồm có những cặp màu cơ bản sau đây. Đỏ – Xanh lục, Da cam – Xanh lam, Vàng – Tím. Những màu này không thể gây cảm cảm giác đồng thời đối với con người, chẳng hạn không thể có một màu gọi là “đỏ – lục” hoặc “vàng – tím”. Điều này tương tự cảm giác về nhiệt độ, không có cảm giác nào được gọi là cảm giác “nóng – lạnh”, mà là “nóng” hoặc “lạnh”. Phát triển Web 2012 65 www.izwebz.com Demon Warlock Màu sắc độ: Đây là thuật ngữ để chỉ độ đậm nhạt của từng loại màu. Sự thay đổi này phụ thuộc vào việc ta cộng thêm màu đen hay màu trắng cho màu gốc để tạo nên các dải màu. Màu trắng sẽ cho ta màu sáng hơn còn màu đen thì ngược lại. Màu sắc điệu: Là khái niệm chỉ sự biến thiên của màu sắc. Sự kết hợp giữa các màu hữu sắc sẽ cho ta thấy điều này. Bạn có thể dễ dàng hiểu được thế nào là một bức hình “ ngả vàng”, tone xanh hay thiên đỏ… đó chính là hiệu quả của sự kết hợp các màu. Màu đen, trắng và xám không có sắc điệu mà chỉ có sắc độ mà thôi.",
        "Summary": "Các gam màu sắc được chia thành 8 loại chính: màu nóng (lôi cuốn, gây chú ý, tạo cảm giác tươi vui, gồm đỏ, vàng và các màu tương cận), màu lạnh (mát mẻ, tươi tắn, nhẹ nhàng, gồm xanh lam, xanh lá cây, đen, tím), màu tương phản (đối lập giữa nóng và lạnh, tạo sự rực rỡ), màu tương đồng (cùng gam nóng hoặc lạnh, có sự tương quan), màu vô sắc (không tạo ra màu mới khi trộn, ví dụ đen, trắng, xám), màu bổ túc (tương phản mạnh, ví dụ đỏ - xanh lục, da cam - xanh lam, vàng - tím), màu sắc độ (độ đậm nhạt của màu) và màu sắc điệu (sự biến thiên của màu sắc). Màu đen, trắng, xám chỉ có sắc độ, không có sắc điệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các loại màu sắc được liệt kê và mô tả ngắn gọn, rõ ràng. Các ý được liên kết với nhau một cách logic, giúp người đọc dễ dàng nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, đó là các loại màu sắc và đặc điểm của chúng. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày các ý chính một cách hiệu quả, giúp người đọc nhanh chóng nắm bắt được nội dung của văn bản gốc."
            }
        }
    },
    {
        "Index": "00100",
        "Article": "Thủ tục hóa tất cả các câu lệnh và chỉ cấp quyền thực + Cấm hoặc vô hiệu hóa (disable) việc thực hiện các thủ tục hệ thống (các thủ tục cơ sở dữ liệu có sẵn) cho phép can thiệp vào hệ quản trị cơ sở dữ liệu và hệ điều - Sử dụng các công cụ rà quét lỗ hổng chèn mã SQL, nhƣ SQLMap, hoặc Acunetix Vulnerability Scanner để chủ động rà quét, tìm các lỗ hổng chèn mã SQL và có biện pháp khắc phục phù hợp. 2.4. Tấn công vào các cơ chế xác thực Xác thực (authentication) trong một mức độ nào đó nhằm xác minh thông tin nhận dạng của một cá nhân hoặc một thực thể. Trao quyền (authorization) xác định các quyền truy nhập vào các đối tƣợng, tài nguyên mà ngƣời dùng đƣợc cấp, sau khi ngƣời dùng đã đƣợc xác thực. Tấn công vào các cơ chế xác thực (Authentication attacks) là các loại tấn công vào khâu xác thực thông tin định danh ngƣời dùng (User authentication) và trao quyền cho ngƣời dùng (User authorization). Để phá đƣợc cơ chế xác thực ứng dụng web, kẻ tấn công có 2 lựa chọn: (1) Đánh cắp mật khẩu tài khoản ngƣời dùng và (2) Bỏ qua khâu xác thực ngƣời dùng. Cả 2 lựa chọn trên đều đƣợc các tin tặc sử dụng trong từng điều kiện khác nhau trên các hệ thống khác nhau. 2.4.2. Các dạng tấn công vào các cơ chế xác thực Các dạng tấn công vào các cơ chế xác thực bao gồm các dạng sau: phát lại chuỗi định danh phiên, vét cạn, nghe lén, khởi tạo lại mật khẩu và XSS / SQL Injection. 2.4.2.1. Phát lại chuỗi định danh phiên Nhƣ đã đề cập trong Chƣơng 1, giao thức HTTP không hỗ trợ phiên (session) làm việc.",
        "Summary": "Thủ tục hóa tất cả các câu lệnh và chỉ cấp quyền thực + Cấm hoặc vô hiệu hóa disable việc thực hiện các thủ tục hệ thống các thủ tục cơ sở dữ liệu có sẵn cho phép can thiệp vào hệ quản trị cơ sở dữ liệu và hệ điều - Sử dụng các công cụ rà quét lỗ hổng chèn mã SQL, nhƣ SQLMap, hoặc Acunetix Vulnerability Scanner để chủ động rà quét, tìm các lỗ hổng chèn mã SQL và có biện pháp khắc phục phù hợp. Để phá đƣợc cơ chế xác thực ứng dụng web, kẻ tấn công có 2 lựa chọn 1 Đánh cắp mật khẩu tài khoản ngƣời dùng và 2 Bỏ qua khâu xác thực ngƣời dùng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Tuy nhiên, có một vài chỗ có thể cải thiện để tăng tính trôi chảy. Ví dụ, có thể thêm các từ nối để liên kết các ý tưởng lại với nhau."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến văn bản gốc, tập trung vào các ý chính. Tuy nhiên, có thể lược bỏ bớt một vài chi tiết nhỏ để bản tóm tắt ngắn gọn hơn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, trung thực và liên quan đến văn bản gốc. Tuy nhiên, có thể cải thiện thêm về tính mạch lạc và độ ngắn gọn."
            }
        }
    },
        {
        "Index": "00101",
        "Article": "Thông qua môn học này, sinh viên hiểu được sự cần thiết phải học tốt các môn học tiếp theo như ngôn ngữ lập trình, phân tích, thiết kế, kiểm thử, bảo trì, quản lý dự án phần mềm,… và hiểu được những kiến thức đó sẽ góp phần vào giai đoạn nào của quy trình phát triển phần mềm mà học phần nhập môn công nghệ phần mềm đã giới thiệu. Công nghiệp phần mềm đã trở thành ngành khổng lồ bởi vì chi phí phần mềm thường chiếm phần lớn chi phí của cả hệ thống máy tính. Chi phí phần mềm trên máy tính cá nhân thường lớn hơn nhiều so với chi phí phần cứng. Ví dụ một đơn vị sử dụng 100 máy tính (chi phí phần cứng là mua 100 máy tính và các thiết bị khác), tất cả các máy tính đều cài hệ điều hành bản quyền. Giả sử mỗi máy tính cài 20 phần mềm ứng dụng thường dùng phải trả tiền bản quyền mỗi năm và còn phải mua bản quyền phần mềm đặc thù của đơn vị. Như vậy chi phí phần mềm cực lớn so với phần cứng. Một đặc trưng khác là phần mềm không mòn cũ nhưng thoái hóa theo thời gian. Trên thực tế, môi trường sử dụng luôn có những thay đổi, nhu cầu người dùng ngày càng cao, hoặc trong quá trình sử dụng phần mềm cần được nâng cấp, thay đổi nhiều lần dẫn đến lỗi phát sinh tăng quá mức kiểm soát, do đó phần mềm trước đây trở nên lỗi thời, thoái hóa, không dùng đến. Ví dụ phần mềm hệ điều hành Windows đang sử dụng thì trước đây người ta dùng Windows 98, Windows 2000, Windows XP,… Một đặc trưng quan trọng nữa thuộc về bản chất của phần mềm là sự thay đổi để thích ứng. Thế giới thực luôn thay đổi và phát triển theo thời gian dẫn đến những nghiệp vụ thay đổi, nhu cầu con người thay đổi thì phần mềm phải được thay đổi theo để thích ứng với những thay đổi đó, thích ứng với môi trường vận hành. Quá trình phát triển về mặt công nghệ có sự thay đổi phần cứng, phần mềm như hệ điều hành thay đổi từ Windows XP qua Windows 7 hay Linux thì các phần mềm nghiệp vụ cũng phải thay đổi theo để tương thích với hệ thống mới. Một điều nữa cần nhấn mạnh là phần mềm không được lắp ráp hay sản xuất từ mẫu sẵn có như các sản phẩm công nghiệp khác. Một sản phẩm phần mềm là kết quả của lao động trí tuệ, là kết tinh từ chất xám của những nhóm người làm việc chuyên nghiệp. Đặc thù của việc phát triển phần mềm là phải làm việc theo nhóm, vì sản phẩm của ngành công nghiệp này có thể giúp con người thực hiện một số chức năng trong công việc một cách hiệu quả và tin cậy.",
        "Summary": "Môn học công nghệ phần mềm giúp sinh viên hiểu được tầm quan trọng và vai trò của phần mềm trong xã hội hiện đại, từ đó tiếp cận được những phương pháp phát triển hiệu quả. Thông qua việc học lý thuyết và thực hành, sinh viên được trang bị kiến thức về chu trình phát triển, các mô hình quy trình, kỹ thuật kiểm thử và bảo trì phần mềm. Mục tiêu là xây dựng nền tảng kiến thức vững chắc để có thể tham gia vào các dự án thực tế, giải quyết vấn đề một cách hệ thống và nâng cao kỹ năng nghề nghiệp trong lĩnh vực công nghệ phần mềm.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chứa nhiều thông tin không có trong văn bản gốc hoặc diễn giải sai lệch ý nghĩa. Ví dụ, văn bản gốc tập trung vào sự cần thiết của môn học, chi phí phần mềm, đặc trưng của phần mềm (không mòn cũ, thay đổi để thích ứng, sản phẩm trí tuệ), trong khi bản tóm tắt lại nói về 'phương pháp phát triển hiệu quả', 'chu trình phát triển', 'mô hình quy trình', 'kỹ thuật kiểm thử và bảo trì phần mềm' và 'tham gia vào các dự án thực tế' mà không hề đề cập đến trong văn bản gốc. Mục tiêu xây dựng nền tảng kiến thức vững chắc để có thể tham gia vào các dự án thực tế, giải quyết vấn đề một cách hệ thống và nâng cao kỹ năng nghề nghiệp trong lĩnh vực công nghệ phần mềm cũng không được đề cập đến."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, các câu liên kết với nhau một cách logic và dễ hiểu. Tuy nhiên, vì nội dung không bám sát văn bản gốc nên tính mạch lạc này không thực sự giá trị."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chứa nhiều thông tin không liên quan đến các ý chính của văn bản gốc. Các ý chính về chi phí phần mềm, đặc trưng của phần mềm (không mòn cũ, thay đổi để thích ứng, sản phẩm trí tuệ) hoàn toàn bị bỏ qua, thay vào đó là các thông tin về 'phương pháp phát triển hiệu quả', 'chu trình phát triển', 'mô hình quy trình', 'kỹ thuật kiểm thử và bảo trì phần mềm' không được đề cập trong văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng kém do không trung thực và không liên quan đến văn bản gốc. Bản tóm tắt đã thêm quá nhiều thông tin không có trong văn bản gốc và bỏ qua các ý chính. Cần tập trung vào việc tóm tắt chính xác các ý chính của văn bản gốc thay vì thêm các thông tin mới."
            }
        }
    },
    {
        "Index": "00102",
        "Article": "Ý tưởng đối tượng xuất phát từ ngôn ngữ lập trình mô phỏng. Đối tượng là thực thể có tính tự trị nằm trong hệ thống. Chương trình mô phỏng có thể coi như chương trình quản lý một số lượng lớn các đơn vị tính toán riêng biệt, mỗi đơn vị tính toán thực hiện một nhiệm vụ nào đó tại một thời điểm cụ thể và các đơn vị tính toán có thể có quan hệ với nhau. Ngôn ngữ lập trình mô phỏng Simula 67 đưa ra ý tưởng về lớp (class), dùng để định nghĩa hành vi của đơn vị tính toán mô phỏng, giống như chương trình định nghĩa hành vi tiến trình. Định nghĩa lớp bao gồm các phương tiện cho phép đối tượng khai báo dữ liệu riêng của mình. Như vậy, lớp giống một kiểu dữ liệu trừu tượng có trạng thái riêng (tập hợp giá trị của các biến riêng) và được thực hiện như một đơn vị tính toán tự trị. Quá trình mô phỏng được định nghĩa bằng cách xác định tập thể hiện của các lớp, là các đối tượng và giao tiếp giữa các đối tượng thông qua việc gửi thông điệp. Đối tượng chỉ phản ứng lại với các thông điệp. Sau khi tạo ra, đối tượng có thể nhận thông điệp từ các đối tượng khác. Đối tượng phản ứng lại bằng cách thực hiện tính toán trên dữ liệu của mình và sau đó gửi thông điệp trả lời. Do hành vi của đối tượng được xác định thông qua định nghĩa lớp, lập trình viên định nghĩa các lớp và cách thức khởi tạo đối tượng từ định nghĩa lớp. Ngày nay, hướng đối tượng được sử dụng trong tất cả các ứng dụng. Ngôn ngữ lập trình hướng đối tượng đã đưa ra mô hình lập trình ứng dụng mới. Bởi tính phổ biến của mô hình này, một số HĐH hiện nay được cài đặt bằng cách sử dụng đối tượng (HĐH Spring). Hướng đối tượng ngày càng có vai trò quan trọng trong các HĐH hiện đại.",
        "Summary": "Ý tưởng đối tượng trong lập trình xuất phát từ ngôn ngữ mô phỏng, với Simula 67 giới thiệu khái niệm lớp để định nghĩa hành vi của các đơn vị tính toán tự trị. Đối tượng trong hệ thống có thể giao tiếp qua việc gửi và nhận thông điệp, thực hiện tính toán trên dữ liệu riêng của mình. Ngày nay, lập trình hướng đối tượng đã trở thành mô hình phổ biến trong phát triển ứng dụng và hệ điều hành hiện đại, như HĐH Spring, nhờ khả năng quản lý và tổ chức mã hiệu quả.\n",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy và kiểm chứng trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng để đảm bảo rằng bản tóm tắt cung cấp một cái nhìn tổng quan chính xác và đầy đủ về chủ đề."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, tính mạch lạc và tính liên quan. Bản tóm tắt đã chọn lọc và trình bày một cách hiệu quả những thông tin quan trọng nhất từ văn bản gốc, giúp người đọc nhanh chóng nắm bắt được ý chính. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00103",
        "Article": "b) Một số loại văn bản điển hình\n - Văn bản text: Văn bản text hay văn bản thuần túy (Plain text, trái với Formatted\n text, styled text hay rich text) là dạng trình bày văn bản trên máy tính chỉ chứa văn bản mà\n không sử dụng các định dạng văn bản để trình bày, nó có thể đọc được dễ dàng mà không cần\n xử lý phức tạp. Hầu hết các tệp văn bản thuần túy đều có phần mở rộng là đuôi .txt và có rất\n nhiều các phần mềm hỗ trợ việc soạn thảo văn bản thuần túy sẵn có trên hệ điều hành như là\n là Notepad, NotePad++ (Windows), edit (DOS), ed, emacs, vi, vim, Gedit hoặc nano (Unix,\n Linux), SimpleText (Mac OS), hoặc TextEdit (Mac OS X).\n - Siêu văn bản HTML: HTML - Hyper Text Markup Language (Ngôn ngữ đánh\n dấu siêu văn bản) được sử dụng để tạo một trang web, trên một website có thể sẽ chứa nhiều\n trang và mỗi trang được quy ra là một tài liệu HTML. Một tập tin HTML sẽ bao gồm các phần\n tử HTML và được lưu lại dưới đuôi mở rộng là .html hoặc .htm. Các thẻ HTML không phân\n biệt chữ hoa chữ thường và có thể tạo tài liệu HTML bằng bất kỳ trình soạn thảo nào như\n Notepad, DreamWeaver, …\n - Văn bản theo chuẩn Microsoft Word: Microsoft Word, còn biết đến với tên khác là\n Winword, là một công cụ soạn thảo văn bản khá phổ biến hiện nay của công ty phần mềm nổi\n tiếng Microsoft. Nó cho phép người dùng làm việc với văn bản thô (text), các hiệu ứng như\n phông chữ, màu sắc cùng với hình ảnh đồ họa và nhiều hiệu ứng đa phương tiện khác nhau\n như âm thanh, video khiến cho việc soạn thảo văn bản được sinh động và thuận tiện hơn.\n Ngoài ra cũng có các công cụ kiểm tra như kiểm tra chính tả, ngữ pháp của nhiều ngôn ngữ\n khác nhau để hỗ trợ cho người dùng.\n - Văn bản theo chuẩn định dạng PDF: PDF hay còn được gọi với cái tên đầy đủ114\n Portable Document Format là một định dạng văn bản di động của hãng Adobe System. Tương\n tự như Microsoft Word, file PDF hỗ trợ hiển thị nhiều loại nội dung khác nhau như text, hình\n ảnh, video,... Hơn thế nữa, với ưu điểm nhỏ gọn cùng tính bảo mật cao nên PDF được sử dụng\n rộng rãi để lưu trữ tài liệu trên mạng. Đặc biệt các định dạng file PDF không thể chỉnh sửa,\n thay đổi được nội dung mà chỉ có phần mềm chuyên dụng mới chỉnh sửa được. Nhưng khi\n chỉnh sửa sẽ khó có được văn bản chuẩn như ban đầu.",
        "Summary": "\"Có nhiều loại văn bản điển hình như văn bản text (thuần túy, .txt) dễ đọc và soạn thảo bằng các trình soạn thảo đơn giản. Siêu văn bản HTML (.html hoặc .htm) được sử dụng để tạo trang web và chứa các phần tử HTML. Microsoft Word (Winword) là công cụ soạn thảo phổ biến, hỗ trợ định dạng phong phú và kiểm tra chính tả. Cuối cùng, PDF (Portable Document Format) là định dạng văn bản di động của Adobe, nhỏ gọn, bảo mật và khó chỉnh sửa, thích hợp cho lưu trữ tài liệu.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các loại văn bản được liệt kê và mô tả một cách rõ ràng, logic. Các câu liên kết với nhau một cách trôi chảy, tạo thành một đoạn văn dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm các ý chính về các loại văn bản điển hình và đặc điểm của chúng. Không có chi tiết thừa hoặc thông tin không quan trọng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày hiệu quả những thông tin quan trọng nhất từ văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00104",
        "Article": "Chính vì vậy, cuộc sống của con ngƣời ngày càng “gắn chặt” với chúng, nó đƣợc ví nhƣ một dạng “thuốc phiện mới”. Ngƣời sử dụng di động luôn hoạt động online, lƣớt web mọi lúc mọi nơi. Số liệu đƣợc công bố từ nghiên cứu của Ofcom: Có đến 81% ngƣời dùng điện thoại bật điện thoại liên tục, ngay cả khi ngủ; 23% ngƣời lớn và 34% thanh thiếu niên sử dụng điện thoại suốt giờ ăn và 22%ngƣời lớn, 47% thanh thiếu niên dùng điện thoại trong… toilet. Vì vậy các doanh nghiệp đang ngày càng phát triển thị trƣờng kinh doanh trực tuyến trên điện thoại di động và dần đƣa nó trở thành xu hƣớng mua bán phổ biến trên toàn cầu. Ví dụ doanh thu bán hàng của di động của eBay đã đạt gần 2 tỷ USD trong năm 2010. Vào năm 2011, con số này đã lên đến 5 tỷ USD, tăng gần 2 lần. Hay Theo số liệu mùa thu năm 2013 của IBM Core Metrics, thƣơng mại di động của Mỹ chiếm 9,8% doanh thu thƣơng mại điện Tại Việt Nam, trong số hơn 30 đơn vị lớn nhỏ đang tham gia thị trƣờng thƣơng mại điện tử, đã có khoảng 1/3 trong số đó phát triển thêm ứng dụng cho phép ngƣời dùng xem và đặt hàng trên smartphone nhƣ: Lazada, Zalora, Vatgia, NhomMua hay Hotdeal. Theo nghiên cứu của hãng nghiên cứu thị trƣờng IHS, số ngƣời sử dụng smartphone năm 2017 sẽ đạt 1.5 tỷ ngƣời và có xu hƣớng ngày càng gia tăng. Chính vì vậy, Mobile retailing hay m-commerce cũng sẽ trở thành hình thức kinh doanh trực tuyến chủ yếu, đáp ứng xu hƣớng mới trong tâm lý khách hàng. Social commerce ra đời trong thời đại các mạng xã hội và các nhóm hoạt động đƣợc kết hợp với thƣơng mại điện tử và bán lẻ trực tiếp. Điểm mạnh tạo nên thành công của thƣơng mại xã hội là tạo sự vui thích cho khách hàng để họ tuyên truyền cho những ngƣời khác thông Hình 3.1: Minh họa hoạt động thƣơng mại xã hội Hiện nay, 42% ngƣời sử dụng phƣơng tiện truyền thông xã hội làm nghiên cứu các sản phẩm mà họ muốn mua trên các mạng xã hội đặc biệt là facebook bởi vì tỷ lệ các nhấp chuột thông qua đƣờng facebook đạt tới 6,5% trong khi các hình thức khác trong việc nỗ lực marketing trực tuyến nhƣ banner quảng cáo nếu đƣợc xem là thành công chỉ có 2% tỷ lệ Bên cạnh đó báo cáo của eConsultancy cho biết 90% khách hàng tin tƣởng lời giới thiệu của những ngƣời họ đã biết, và những nhà bán lẻ trên Facebook gần đây đã thông báo 67% khách hàng dành nhiều thời gian hơn cho mua sắm sau khi nghe lời khuyên của những ngƣời bạn, những cộng đồng trên mạng. Chính vì vậy trong tƣơng lai, với sự ra đời và phát triển của nhiều trang mạng xã hội khác nhƣ twitter, Instagrams, Google+,… xu hƣớng thƣơng mại xã hội cũng mở rộng theo.",
        "Summary": "Số liệu đƣợc công bố từ nghiên cứu của Ofcom Có đến 81% ngƣời dùng điện thoại bật điện thoại liên tục, ngay cả khi ngủ 23% ngƣời lớn và 34% thanh thiếu niên sử dụng điện thoại suốt giờ ăn và 22%ngƣời lớn, 47% thanh thiếu niên dùng điện thoại trong toilet. Hay Theo số liệu mùa thu năm 2013 của IBM Core Metrics, thƣơng mại di động của Mỹ chiếm 9,8% doanh thu thƣơng mại điện Tại Việt Nam, trong số hơn 30 đơn vị lớn nhỏ đang tham gia thị trƣờng thƣơng mại điện tử, đã có khoảng 13 trong số đó phát triển thêm ứng dụng cho phép ngƣời dùng xem và đặt hàng trên smartphone nhƣ Lazada, Zalora, Vatgia, NhomMua hay Hotdeal. Điểm mạnh tạo nên thành công của thƣơng mại xã hội là tạo sự vui thích cho khách hàng để họ tuyên truyền cho những ngƣời khác thông Hình 3.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt gần như hoàn toàn trung thực. Tuy nhiên, có một chi tiết nhỏ không chính xác: '13 trong số đó' thay vì '1/3 trong số đó' như trong văn bản gốc. Ngoài ra, 'Hình 3' không rõ ràng và thiếu thông tin so với 'Hình 3.1: Minh họa hoạt động thƣơng mại xã hội' trong văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, nhưng các câu trích dẫn số liệu có vẻ hơi rời rạc và thiếu sự liên kết rõ ràng. Cần có câu dẫn hoặc liên kết để tạo sự liền mạch hơn giữa các ý."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các số liệu thống kê và một số ý chính về thương mại di động và thương mại xã hội. Tuy nhiên, việc chỉ trích dẫn số liệu mà không có bối cảnh có thể làm giảm tính liên quan và khó hiểu cho người đọc. Phần 'Hình 3' không rõ ràng và có thể bỏ qua."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, đã chọn lọc được một số thông tin quan trọng từ văn bản gốc. Tuy nhiên, cần cải thiện tính chính xác ở một vài chi tiết nhỏ và tăng cường tính mạch lạc bằng cách thêm các câu dẫn hoặc liên kết giữa các ý. Nên lược bỏ những chi tiết khó hiểu hoặc không đầy đủ như 'Hình 3'."
            }
        }
    },
    {
        "Index": "00105",
        "Article": "Bộ điều phối có ảnh hưởng lớn tới hiệu suất máy tính. Nếu bộ điều phối cấp phát CPU ngay cho tiến trình sẵn sàng thực thi, tiến trình sẽ tốn ít thời gian nằm chờ ở hàng đợi và được sử dụng CPU ngay khi cần thiết. Khi đó, hiệu suất chỉ phụ thuộc vào tốc độ phần cứng máy tính. Ngược lại, nếu tiến trình bị \"bỏ quên\" trong hàng đợi, khoảng thời gian tiến trình nằm tại hàng đợi lớn hơn rất nhiều so với khoảng thời gian sử dụng CPU. Hiệu suất cũng bị tác động bởi thời gian thực hiện chuyển ngữ cảnh. Chi phí phụ trội này lại bị ảnh hưởng bởi phần cứng. Một nhân tố khác ảnh hưởng đến hiệu suất là chính sách điều phối - xác định thời gian tiến trình đợi để được sử dụng CPU khi tiến trình đã ở trạng thái sẵn sàng. So với yếu tố thời gian chuyển ngữ cảnh, yếu tố về chính sách ảnh hưởng tới hiệu suất nhiều hơn. Ở đây chúng ta xét ảnh hưởng của điều phối tới hiệu suất tổng thể hệ thống. Thông thường, tại một thời điểm có một vài tiến trình sẵn sàng thực thi. Khi nào bộ điều vận chọn tiến trình được thực thi kế tiếp? Tiêu chí nào được sử dụng trong quá trình lựa chọn? Tiến trình mãi mãi bị \"bỏ quên\" trong hàng đợi sẽ không bao giờ sử dụng được CPU để hoàn thành công việc của mình, hiện tượng này gọi là \"chết đói\". Nếu tiến trình được lựa chọn ngay khi sẵn sàng, khi đó thời gian thực thi thực sự của tiến trình sẽ liệm cận với tốc độ phần cứng. Phương pháp và chính sách điều phối sẽ định ra tiêu chí lựa chọn tiến trình thực thi kế tiếp. Các cơ chế trình bày ở đây được sử dụng để cài đặt một phương pháp đã được người quản trị hoặc người thiết kế HĐH lựa chọn. Có những phương pháp tập trung vào hiệu suất hệ thống tổng thể, có phương pháp mong muốn chia sẻ công bằng CPU giữa các tiến trình, thậm chí có phương pháp cố gắng tối ưu hiệu suất của một lớp tiến trình cụ thể. Nói chung, hiệu suất sẽ quyết định lựa chọn phương pháp điều phối phù hợp.",
        "Summary": "Bộ điều phối ảnh hưởng lớn đến hiệu suất máy tính thông qua việc cấp phát CPU cho các tiến trình sẵn sàng thực thi, với hiệu suất phụ thuộc vào tốc độ phần cứng và thời gian chuyển ngữ cảnh. Chính sách điều phối, quyết định thời gian đợi của tiến trình để sử dụng CPU, có tác động lớn hơn đến hiệu suất so với thời gian chuyển ngữ cảnh. Các phương pháp điều phối khác nhau có thể tập trung vào hiệu suất tổng thể, chia sẻ công bằng CPU, hoặc tối ưu hóa cho một lớp tiến trình cụ thể, và hiệu suất sẽ quyết định lựa chọn phương pháp điều phối phù hợp.\n",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc có thể dễ dàng hiểu được nội dung chính của văn bản gốc thông qua bản tóm tắt này."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về vai trò của bộ điều phối đối với hiệu suất máy tính, các yếu tố ảnh hưởng đến hiệu suất, và các phương pháp điều phối khác nhau. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác nội dung quan trọng của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00106",
        "Article": "Các dạng còn lại không có khả năng tự lây nhiễm. Việc phân loại các phần mềm độc hại kể trên mang tính chất tương đối do hiện nay, có một số phần mềm độc hại có các đặc tính của cả Vi rút, Sâu và Phần mềm gián điệp. Hình 2.33. Các dạng phần mềm độc hại Logic bomb (Bom lô gíc) là các đoạn mã độc thường được “nhúng” vào các chương trình bình thường và thường hẹn giờ để “phát nổ” trong một số điều kiện cụ thể. Điều kiện để bom “phát nổ” có thể là sự xuất hiện hoặc biến mất của các file cụ thể, một thời điểm cụ thể, hoặc một ngày trong tuần. Khi “phát nổ” bom logic có thể xoá dữ liệu, file, Thực tế đã ghi nhận quả bom logic do Tim Lloyd cài lại đã “phát nổ” tại công ty Omega Engineering vào ngày 30/7/1996, 20 ngày sau khi Tim Lloyd bị sa thải. Bom lô gíc này đã xoá sạch các bản thiết kế và các chương trình, gây thiệt hại 10 triệu USD cho công ty. Bản thân Tim Lloyd bị phạt 2 triệu USD và 41 tháng tù. Trojan horse lấy tên theo tích “Con ngựa thành Tơ roa”, là chương trình chứa mã độc, thường giả danh những chương trình có ích, nhằm lừa người dùng kích hoạt chúng. Trojan horse thường được sử dụng để thực thi gián tiếp các tác vụ, mà tác giả của chúng không thể thực hiện trực tiếp do không có quyền truy nhập. Chẳng hạn, trong một hệ thống nhiều người dùng, một người dùng (kẻ tấn công) có thể tạo ra một trojan đội lốt một chương trình hữu ích đặt ở thư mục chung. Khi trojan này được thực thi bởi một người dùng khác, nó sẽ thay đổi quyền truy nhập các file và thư mục của người dùng đó, cho phép tất cả người dùng (trong đó có kẻ tấn công) truy nhập vào các file của người Back door (Cửa hậu) thường được các lập trình viên tạo ra, dùng để gỡ rối và kiểm thử chương trình trong quá trình phát triển.",
        "Summary": "Việc phân loại các phần mềm độc hại kể trên mang tính chất tương đối do hiện nay, có một số phần mềm độc hại có các đặc tính của cả Vi rút, Sâu và Phần mềm gián điệp. Các dạng phần mềm độc hại Logic bomb Bom lô gíc là các đoạn mã độc thường được nhúng vào các chương trình bình thường và thường hẹn giờ để phát nổ trong một số điều kiện cụ thể. Khi phát nổ bom logic có thể xoá dữ liệu, file, Thực tế đã ghi nhận quả bom logic do Tim Lloyd cài lại đã phát nổ tại công ty Omega Engineering vào ngày 3071996, 20 ngày sau khi Tim Lloyd bị sa thải.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt gần như hoàn toàn trung thực. Tuy nhiên, có một chi tiết nhỏ không chính xác: '3071996' thay vì '30/7/1996'. Ngoài ra, bản tóm tắt bỏ qua phần mô tả về Trojan horse và Back door."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu liên kết với nhau khá rõ ràng. Tuy nhiên, việc lược bỏ một số thông tin (Trojan horse, Back door) khiến cho bố cục có phần chưa được đầy đủ."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính về phần mềm độc hại và logic bomb. Tuy nhiên, việc bỏ qua Trojan horse và Back door làm giảm tính bao quát của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá. Điểm mạnh là trung thực và mạch lạc. Tuy nhiên, cần bao quát hơn bằng cách đề cập đến Trojan horse và Back door để tăng tính liên quan và đầy đủ của bản tóm tắt. Cần sửa lỗi chính tả nhỏ (3071996 -> 30/7/1996)."
            }
        }
    },
    {
        "Index": "00107",
        "Article": "Thẻ thông minh (Smart Card), thẻ gắn chip, hay thẻ tích hợp vi mạch (integrated circuit card -ICC) là loại thẻ bỏ túi thường có kích thước của thẻ tín dụng, bên trong chứa một mạch tích hợp có khả năng lưu trữ và xử lý thông tin. Nó có thể đóng vai trò như thẻ căn cước, thực hiện việc xác thực thông tin, lưu trữ dữ liệu hay dùng trong các ứng dụng thẻ. Thẻ thông minh được chia làm 2 loại chính như sau:\n - Thẻ thông minh có tiếp xúc: Loại thẻ thông minh có tiếp xúc có một diện tích tiếp xúc, bao gồm một số tiếp điểm mạ vàng, và có diện tích khoảng 1 cm vuông. Khi được đưa vào máy đọc, con chip trên thẻ sẽ giao tiếp với các tiếp điểm điện tử và cho phép máy đọc thông tin từ chip và viết thông tin lên nó. \n - Thẻ thông minh không tiếp xúc: Đây là loại thẻ mà chip trên nó liên lạc với máy đọc thẻ thông qua công nghệ cảm ứng RFID (với tốc độ dữ liệu từ 106 đến 848 kbit/s). \n Một số chức năng và vai trò của thẻ thông minh trong vấn đề xác thực và bảo mật thông tin: \n - Cho phép thực hiện các giao dịch kinh doanh một cách hiệu quả theo một cách chuẩn mực, linh hoạt và an ninh mà trong đó con người ít phải can thiệp vào. \n - Giúp thực hiện việc kiểm tra và xác nhận chặt chẽ mà không phải dùng thêm các công cụ khác như mật khẩu…Chính vì thế, có thể thực hiện hệ thống dùng cho việc đăng nhập sử dụng máy tính, máy tính xách tay, dữ liệu bảo mật hoặc các môi trường kế hoạch sử dụng tài nguyên của công ty như SAP, v.v.. với thẻ thông minh là phương tiện kiểm tra và xác nhận duy nhất. \n Ngoài ra, thẻ thông minh cung cấp một số tính năng có thể được sử dụng để cung cấp hoặc tăng cường bảo vệ quyền riêng tư trong hệ thống. Trong bài giảng chỉ liệt kê một số tính năng quan trọng của thẻ thông minh. Chi tiết về những tính năng này và làm thế nào thực hiện được các chức năng này, có thể tham khảo trong các tài liệu tham khảo khác. Một số tính năng cụ thể như sau: Chứng thực; An toàn dữ liệu lưu trữ; mã hóa; Bảo mật thiết bị; Thông tin liên lạc an toàn; Sinh trắc học; Chứng chỉ….",
        "Summary": "Thẻ thông minh (smart card) là thẻ bỏ túi chứa mạch tích hợp, có khả năng lưu trữ và xử lý thông tin, được dùng cho xác thực, lưu trữ dữ liệu và các ứng dụng thẻ. Có hai loại chính: thẻ tiếp xúc (giao tiếp qua tiếp điểm mạ vàng) và thẻ không tiếp xúc (giao tiếp qua RFID). Thẻ thông minh giúp thực hiện giao dịch kinh doanh hiệu quả, an toàn, kiểm tra xác nhận chặt chẽ, và tăng cường bảo vệ quyền riêng tư thông qua các tính năng như chứng thực, an toàn dữ liệu, mã hóa, bảo mật thiết bị, thông tin liên lạc an toàn, sinh trắc học và chứng chỉ.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, phân loại và chức năng của thẻ thông minh, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00108",
        "Article": "Khi nào nên cho một lớp là lớp độc lập, lớp con, lớp trừu tượng, hay nên biến nó thành interface? • Một lớp nên là lớp độc lập, nghĩa là nó không thừa kế lớp nào (ngoại trừ Object) nếu nó không thỏa mãn kiểm tra IS-A đối với bất cứ loại nào khác. • Một lớp nên là lớp con nếu ta cần cho nó làm một phiên bản chuyên biệt hơn của một lớp khác và cần cài đè hành vi có sẵn hoặc bổ sung hành vi mới. • Một lớp nên là lớp cha nếu ta muốn định nghĩa một khuôn mẫu cho một nhóm các lớp con, và ta có một chút mã cài đặt mà tất cả các lớp con kia có thể sử dụng. Cho lớp đó làm lớp trừu tượng nếu ta muốn đảm bảo rằng không ai được tạo đối tượng thuộc lớp đó. • Dùng một interface nếu ta muốn định nghĩa một vai trò mà các lớp khác có thể nhận, bất kể các lớp đó thuộc cây thừa kế nào. Những điểm quan trọng: • Khi muốn cấm tạo đối tượng từ một lớp, ta dùng từ khóa abstract tại định nghĩa lớp để tuyên bố lớp đó là lớp trừu tượng. • Một lớp trừu tượng có thể có các phương thức trừu tượng cũng như không trừu tượng. • Nếu một lớp có dù chỉ một phương thức trừu tượng, lớp đó buộc phải là lớp trừu tượng. • Một phương thức trừu tượng không có thân, khai báo phương thức đó kết thúc bằng dấu chấm phảy. • Một lớp cụ thể phải cài đặt hoặc được thừa kế cài đặt của tất cả các phương thức trừu tượng. • Mỗi lớp Java đều là lớp con trực tiếp hoặc gián tiếp của lớp Object. • Nếu ta dùng một tham chiếu để gọi phương thức, tham chiếu đó được khai báo thuộc lớp gì hay interface gì thì ta chỉ được gọi các phương thức có trong lớp đó hoặc interface đó, bất kể đối tượng mà tham chiếu đó đang chiếu tới là đối tượng thuộc lớp nào. • Một biến tham chiếu lớp cha có thể được gán giá trị là tham chiếu kiểu lớp con bất kì mà không cần đổi kiểu. Có thể dùng phép đổi kiểu để gán giá trị là tham chiếu kiểu lớp cha cho một biến tham chiếu kiểu lớp con, tuy nhiên khi chạy chương trình, phép đổi kiểu đó sẽ thất bại nếu đối tượng đang được chiếu tới không thuộc kiểu tương thích với phép đổi kiểu. • Java không hỗ trợ đa thừa kế do vấn đề Hình thoi. Java chỉ cho phép mỗi lớp chỉ có duy nhất một lớp cha. • Một interface tương tự với một lớp thuần túy trừu tượng. Nó chỉ định nghĩa các phương thức trừu tượng. • Một lớp có thể cài đặt nhiều interface. • Lớp nào cài đặt một interface thì phải cài tất cả các phương thức của interface đó, do tất cả các phương thức interface đều là các phương thức trừu tượng public.",
        "Summary": "\"Nên xác định lớp là lớp độc lập nếu không thuộc loại chuyên biệt nào khác; lớp con nếu cần chuyên biệt hóa lớp cha; lớp cha nếu định nghĩa khuôn mẫu chung cho các lớp con và có mã cài đặt dùng chung; lớp trừu tượng để cấm tạo đối tượng trực tiếp. Interface phù hợp khi định nghĩa một vai trò mà nhiều lớp từ các cây thừa kế khác nhau có thể đảm nhận.\n \n Lớp trừu tượng dùng từ khóa `abstract`, có thể chứa cả phương thức trừu tượng và không trừu tượng. Lớp chứa phương thức trừu tượng phải là lớp trừu tượng. Phương thức trừu tượng không có thân. Lớp cụ thể phải cài đặt tất cả phương thức trừu tượng.\n \n Mọi lớp trong Java đều kế thừa Object. Tham chiếu chỉ gọi được phương thức trong lớp/interface mà nó khai báo. Tham chiếu lớp cha có thể trỏ tới đối tượng lớp con mà không cần ép kiểu.\n \n Java không hỗ trợ đa kế thừa, mỗi lớp chỉ có một lớp cha. Interface tương tự lớp trừu tượng thuần túy, chỉ định nghĩa phương thức trừu tượng. Lớp có thể implement nhiều interface và phải cài đặt tất cả phương thức của interface.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Việc chia thành các đoạn nhỏ giúp người đọc dễ dàng theo dõi và nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa hoặc không cần thiết. Tóm tắt tập trung vào các khái niệm cốt lõi về lớp độc lập, lớp con, lớp trừu tượng, interface, và các quy tắc liên quan đến kế thừa và phương thức trừu tượng trong Java."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ và chính xác về các khái niệm quan trọng trong văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00109",
        "Article": "Năng suất cũng sẽ đƣợc cải thiện do các doanh nghiệp bổ sung và hỗ trợ lực lƣợng lao động hiện có của họ bằng các công nghệ TTNT. Nó sẽ yêu cầu đầu tƣ vào phần mềm, hệ thống và máy móc dựa trên trí thông minh đƣợc hỗ trợ, tự chủ và tăng cƣờng; điều này sẽ không chỉ cho phép lực lƣợng lao động thực hiện nhiệm vụ của mình tốt hơn và hiệu quả hơn mà còn giải phóng thời gian cho phép lực lƣợng này tập trung vào các hoạt động kích thích hơn và có giá trị gia tăng cao hơn. Tự động hóa sẽ loại bỏ một phần nhu cầu đầu vào lao động, dẫn đến tăng năng suất nói chung. Cuối cùng, sự sẵn có của các sản phẩm và dịch vụ đƣợc cá nhân hóa và chất lƣợng cao hơn đƣợc nâng cao bởi TTNT - sẽ trở nên quan trọng hơn, vì tính khả dụng này có khả năng thúc đẩy nhu cầu của ngƣời tiêu dùng, từ đó tạo ra nhiều dữ a) Ứng dụng TTNT trong sản xuất TTNT là một trong những nền tảng của quá trình số hóa ngành công nghiệp đang phát triển . Các công nghệ làm nền tảng cho quá trình này - chẳng hạn nhƣ IoT, 5G, điện toán đám mây, phân tích dữ liệu lớn, cảm biến thông minh, thực tế tăng cƣờng, in 3D và robot - có khả năng biến sản xuất thành một hệ thống vật lý mạng duy nhất, trong đó công nghệ kỹ thuật số, internet và sản xuất hợp nhất trong một. Trong các nhà máy thông minh của tƣơng lai, các quy trình sản xuất sẽ đƣợc kết nối và các giải pháp TTNT sẽ là nền tảng trong việc liên kết các máy móc, giao diện và các thành phần (ví dụ: sử dụng nhận diện khung cảnh). Một lƣợng lớn dữ liệu sẽ đƣợc thu thập và đƣa vào các thiết bị TTNT, từ đó sẽ tối ƣu hóa quy trình sản xuất. OECD cho rằng việc sử dụng TTNT có thể đƣợc 'áp dụng cho hầu hết các hoạt động công nghiệp từ việc tối ƣu hóa các hệ thống nhiều máy móc đến tăng cƣờng nghiên cứu công nghiệp'. Việc triển khai TTNT trong sản xuất có thể sẽ tăng lên theo thời gian, do sự phát triển của các quy trình học tập tự động.",
        "Summary": "Nó sẽ yêu cầu đầu tƣ vào phần mềm, hệ thống và máy móc dựa trên trí thông minh đƣợc hỗ trợ, tự chủ và tăng cƣờng điều này sẽ không chỉ cho phép lực lƣợng lao động thực hiện nhiệm vụ của mình tốt hơn và hiệu quả hơn mà còn giải phóng thời gian cho phép lực lƣợng này tập trung vào các hoạt động kích thích hơn và có giá trị gia tăng cao hơn. Các công nghệ làm nền tảng cho quá trình này - chẳng hạn nhƣ IoT, 5G, điện toán đám mây, phân tích dữ liệu lớn, cảm biến thông minh, thực tế tăng cƣờng, in 3D và robot - có khả năng biến sản xuất thành một hệ thống vật lý mạng duy nhất, trong đó công nghệ kỹ thuật số, internet và sản xuất hợp nhất trong một.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được trích dẫn từ văn bản gốc và ghép lại với nhau. Tuy nhiên, vì là trích dẫn nên có thể thiếu một chút sự liên kết so với việc viết lại hoàn toàn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào việc ứng dụng TTNT trong sản xuất và các công nghệ liên quan. Tuy nhiên, có thể lược bỏ bớt một vài chi tiết nhỏ để bản tóm tắt ngắn gọn hơn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và liên quan. Tuy nhiên, để tăng tính mạch lạc và ngắn gọn, nên diễn giải lại các ý chính thay vì chỉ trích dẫn trực tiếp từ văn bản gốc."
            }
        }
    },
    {
        "Index": "00110",
        "Article": "Quản lý an toàn thay đổi hàng năm do các máy tính, môi trường mạng và các ứng dụng xử lý thông tin thay đổi. Máy tính cá nhân ngày trở nên mạnh hơn, môi trường mạng kết nối càng rộng rãi hơn, người dùng có nhiều thông tin về hoạt động của hệ thống máy tính hơn, thông tin phân tán ra khắp các thiết bị khác nhau trong mạng. Việc này khiến cho vấn đề quản lý an toàn thông tin phức tạp và nghiêm trọng hơn. Mặt khác, thông tin và dữ liệu trở nên quan trọng hơn cả tài sản vật lý khác như thiết bị hay nhà xưởng. Quản lý an toàn bao gồm tất cả các hoạt động cần thiết để giữ cho một chương trình an toàn hoạt động và phát triển. Việc này bao gồm quản lý rủi ro, lập tài liệu, quản lý và triển khai các biện pháp kiểm soát an toàn, quy trình và thủ tục, an toàn nhân sự, kiểm toán và đào tạo nâng cao nhận thức an toàn liên tục. Việc phân tích rủi ro xác định các tài sản quan trọng, phát hiện ra các mối đe dọa, xếp chúng vào nguy cơ và được sử dụng để ước tính thiệt hại có thể và tổn thất tiềm ẩn mà cơ quan/tổ chức có thể chịu đựng. Phân tích rủi ro giúp quản lý xây dựng ngân sách với các quỹ cần thiết để bảo vệ tài sản được ghi nhận khỏi các mối đe dọa được xác định và phát triển các chính sách an toàn giúp định hướng cho các hoạt động an ninh. Các biện pháp bảo vệ được xác định, triển khai và duy trì để giữ rủi ro bảo mật của tổ chức ở mức có thể chấp nhận được. Việc giáo dục an ninh và nhận thức đưa thông tin này đến từng nhân viên trong cơ quan/tổ chức để mọi người được thông tin đầy đủ và có thể dễ dàng làm việc hơn hướng tới cùng mục tiêu an toàn.",
        "Summary": "Quản lý an toàn thông tin ngày càng phức tạp do sự phát triển của máy tính, mạng và ứng dụng, với thông tin trở thành tài sản quan trọng hơn cả tài sản vật lý. Quá trình này bao gồm quản lý rủi ro, triển khai biện pháp kiểm soát, phân tích rủi ro để xác định mối đe dọa và xây dựng ngân sách bảo vệ, cùng với việc giáo dục và nâng cao nhận thức an toàn cho nhân viên để hướng tới mục tiêu chung.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, giúp người đọc nhanh chóng nắm bắt được trọng tâm của vấn đề."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan đến văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00111",
        "Article": "2.1.3.3 Thẻ thông minh\n ü Khái niệm\n Thẻ thông minh là loại thẻ có kích thước như một chiếc thẻ tín dụng thông thường\n nhưng trên đó có gắn một con chip – vi mạch điện tử. Vi mạch điện tử này bao gồm một thiết\n bị ra vào đặc trưng, một bộ vi xử lý, một bộ nhớ. Tất cả những thiết bị này sẽ giúp lưu trữ rất\n nhiều những loại thông tin khác nhau từ các thông tin như số thẻ tín dụng, hồ sơ sức khoẻ cá\n nhân, bảo hiểm y tế, hồ sơ công tác, bằng lái xe… với dung lượng lớn gấp hàng trăm lần so32\n với dung lượng của các thông tin có thể lưu trữ trên một thẻ tín dụng thông thường. Thẻ thông\n minh có khả năng lưu trữ và xử lý thông tin với độ an toàn cao nên được sử dụng trong rất\n nhiều ngành như ngân hàng, tài chính, y tế hay bưu chính viễn thông. Hiện nay, thẻ thông\n minh được sử dụng tại rất nhiều nước. Công nghệ thẻ thông minh được khởi đầu tại Pháp\n nhưng ít thông dụng hơn ở Mỹ, nơi mà người ta hay sử dụng thẻ tín dụng là chủ yếu ü Phân loại\n Dựa trên phương thức đọc thẻ, người ta chia thẻ thông minh thành hai loại cơ bản:\n Thẻ tiếp xúc vật lý (thẻ có khả năng liên kết) – Contact smart card\n Thẻ tiếp xúc vật lý là thẻ thông minh mà trên mạch vi xử lý có gắn một miếng kim\n loại nhỏ mạ vàng. Thẻ sẽ được kích hoạt khi đưa thẻ này vào thiết bị đọc thẻ. Khi đưa thẻ tiếp\n xúc với thiết bị đọc thẻ, thông tin dữ liệu trên thẻ sẽ được truyền từ chip qua miếng kim loại\n nhỏ mạ vàng sang thiết bị đọc thẻ.\n Để đọc, ghi thông tin, bề mặt con chip phải tiếp xúc trực tiếp với đầu đọc thẻ. Loại thẻ\n này được sử dụng nhiều trong tài chính (công nghệ của thẻ tiếp xúc phi vật lý thường được sử\n dụng để tạo ra thẻ ghi nợ và thẻ tín dụng). Truyền thông (sim điện thoại) vì ưu điểm giá cả\n không quá đắt, đáp ứng nhiều tiêu chuẩn về công nghệ, độ bảo mật cao. Khi được đưa\n vào máy đọc, chip trên thẻ sẽ giao tiếp với các tiếp điểm điện tử cho phép đọc các thông tin từ\n chip và viết thông tin lên nó. Thẻ thông minh loại này không có pin, năng lượng làm việc sẽ\n được cấp trực tiếp từ máy đọc thẻ.",
        "Summary": "Thẻ thông minh là thẻ có kích thước tương đương thẻ tín dụng nhưng được gắn chip điện tử, có khả năng lưu trữ lượng lớn thông tin (số thẻ, hồ sơ cá nhân, v.v.) với độ an toàn cao. Dựa trên phương thức đọc, thẻ thông minh được chia thành hai loại: thẻ tiếp xúc vật lý (có miếng kim loại mạ vàng trên chip, truyền dữ liệu khi tiếp xúc trực tiếp với đầu đọc) và thẻ không tiếp xúc. Thẻ tiếp xúc vật lý phổ biến trong tài chính và truyền thông nhờ giá cả hợp lý, đáp ứng tiêu chuẩn công nghệ và bảo mật cao.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các chi tiết như kích thước tương đương thẻ tín dụng, khả năng lưu trữ thông tin lớn, phân loại thẻ, và ứng dụng của thẻ tiếp xúc vật lý đều được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng. Mở đầu bằng định nghĩa, sau đó đến phân loại và cuối cùng là ứng dụng, tạo thành một dòng chảy thông tin dễ theo dõi và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Ví dụ, bản tóm tắt tập trung vào định nghĩa, phân loại và ứng dụng chính của thẻ thông minh, bỏ qua các chi tiết vụn vặt như lịch sử phát triển ở Pháp và Mỹ."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày các thông tin quan trọng nhất từ văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00112",
        "Article": "2.5 Hệ thống thanh toán séc điện tử\n 2.5.1 Khái niệm séc điện tử\n Séc là một tờ mệnh lệnh vô điều kiện của người chủ tài khoản ra lệnh cho ngân hàng\n trích từ tài khoản của mình để trả cho người có tên trong séc (payee), hoặc trả theo lệnh của\n người ấy hoặc trả cho người cầm séc (bearer) một số tiền nhất định bằng tiền mặt hay chuyển\n khoản.\n Phương thức thanh toán bằng séc cũng chiếm tới gần 10% tổng các giao dịch trực\n tuyến trên thế giới. Tuy phương thức này trước đây khá phức tạp (sau khi giao dịch trực tuyến\n được thực hiện, người mua phải ra khỏi mạng và gửi séc qua thư đến cho người bán), tuy\n nhiên nhiều khách hàng vẫn sẵn sàng chấp nhận sự phức tạp đó để được thực hiện thanh toán\n bằng séc. Để thoả mãn mong muốn đó của khách hàng, một giải pháp mới cho phương thức\n thanh toán bằng séc ra đời, đó là việc sử dụng “séc điện tử”.\n Séc điện tử là phiên bản điện tử có giá trị pháp lý đại diện cho một tấm séc giấy. Séc\n điện tử là cơ chế thanh toán điện tử đầu tiên được kho bạc Mỹ lựa chọn để tiến hành các\n khoản thanh toán có giá trị lớn trên mạng Internet.\n Về mặt nguyên tắc, hệ thống thanh toán séc điện tử được xây dựng trên các nguyên tắc\n của hệ thống thanh toán séc giấy, tuy nhiên được điện tử hóa toàn bộ quy trình thanh toán.\n Hiện nay có rất nhiều tổ chức cung cấp dịch vụ thanh toán séc điện tử: Authorize.net,\n Paysimple.com, Checkpay.us. Ở một số quốc gia phát triển, người ta hay đồng nhất các thuật\n ngữ: electronic checks, direct debit, or ACH transfer. Từ năm 2015, séc điện tử được coi là\n một hình thức thanh toán tiêu chuẩn, cùng với thẻ tín dụng hoặc những công cụ thanh toán\n của bên thứ ba.\n Tại Việt Nam, hình thức thanh toán bằng séc truyền thống chỉ chiếm khoảng 2% trong\n tổng thanh toán phi tiền mặt, trong đó chủ yếu là thanh toán giữa các doanh nghiệp. Hầu hết\n người dân vẫn e ngại thanh toán bằng séc, và tính đến thời điểm hiện tại cũng chưa có tổ chức\n nào cung cấp dịch vụ thanh toán séc điện tử.\n Thanh toán bằng séc điện tử có rất nhiều lợi ích:\n - Người bán cắt giảm được chi phí quản lý\n - Người bán nhận được tiền từ người mua nhanh hơn, an toàn hơn và không mất thời\n gian xử lý giấy tờ\n - Cải tiến hiệu quả quy trình chuyển tiền đối với cả người bán và tổ chức tài chính\n - Cung cấp thông tin chi tiết về việc mua hàng trên tài khoản của người mua\n - Không yêu cầu khách hàng tiết lộ các thông tin về tài khoản của mình cho các nhân\n khác trong quá trình giao dịch\n - Không yêu cầu khách hàng phải thường xuyên gửi các thông tin tài chính nhạy cảm\n trên web\n - Tiết kiệm so với thanh toán bằng thẻ tín dụng cho người bán\n - Nhanh và tiện lợi hơn so với séc giấy.",
        "Summary": "\"Séc điện tử là phiên bản điện tử có giá trị pháp lý của séc giấy, được xây dựng trên nguyên tắc của thanh toán séc giấy nhưng được điện tử hóa. Nó là cơ chế thanh toán điện tử đầu tiên được kho bạc Mỹ lựa chọn cho các khoản thanh toán lớn trên Internet và được coi là một hình thức thanh toán tiêu chuẩn từ năm 2015. Séc điện tử mang lại nhiều lợi ích như giảm chi phí quản lý cho người bán, tăng tốc độ và an toàn trong chuyển tiền, cung cấp thông tin chi tiết về giao dịch, bảo mật thông tin tài khoản của người mua và tiết kiệm chi phí so với thẻ tín dụng. Tuy nhiên, tại Việt Nam, hình thức thanh toán bằng séc điện tử chưa phổ biến.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, nguyên tắc hoạt động, lợi ích và tình hình sử dụng séc điện tử tại Việt Nam, là những điểm cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00113",
        "Article": "Trong những chương trước ta đã xem xét một số kỹ thuật giải quyết vấn đề và suy diễn. Đặc điểm chung của những kỹ thuật này là phương pháp giải quyết vấn đề cùng với tri thức được cung cấp cho chương trình máy tính từ trước và chương trình không thể thay đổi hoặc cải thiện hoạt động của mình dựa trên kinh nghiệm thu được trong quá trình làm việc sau đó. Trong chương này, ta sẽ xem xét các kỹ thuật học máy (machine learning), là kỹ thuật cho phép giải quyết vấn để hoặc ra quyết định dựa trên dữ liệu và kinh nghiệm. Học máy là khả năng của chương trình máy tính sử dụng kinh nghiệm, quan sát, hoặc dữ liệu trong quá khứ để cải thiện công việc của mình trong tương lai thay vì chỉ thực hiện theo đúng các quy tắc đã được lập trình sẵn. Chẳng hạn, máy tính có thể học cách dự đoán dựa trên các ví dụ, hay học cách tạo ra các hành vi phù hợp dựa trên quan sát trong quá khứ. Ví dụ: Xét một số ví dụ sau. Ví dụ thứ nhất là học cách đánh cờ. Chương trình có thể quan sát các ván cờ cùng với kết quả (thắng hay thua) để cải thiện khả năng chơi cờ và tăng số ván thắng trong tương lai. Trong trường hợp này, kinh nghiệm là các ván cờ trong quá khứ (có thể là ván cờ chương trình tự chơi với chính mình), được sử dụng để học cách làm tốt hơn công việc chơi cờ với tiêu chí đánh giá là số ván thắng. Ví dụ thứ hai là học nhận dạng các ký tự. Chương trình được cung cấp dữ liệu dưới dạng ảnh chụp các ký tự (chữ cái) cùng mã UNICODE của ký tự đó. Sau khi học, chương trình cần có khả năng nhận dạng các ảnh chụp ký tự mới, tức là xác định được mã UNICODE của các ảnh mới chụp ký tự đã được học. Tương tự quá trình học thông thường, một hệ thống học máy cần có khả năng ghi nhớ, thích nghi, và đặc biệt là tổng quát hóa. Tổng quát hóa là khả năng của hệ thống học máy ra quyết định chính xác trong các trường hợp mới, chưa gặp, dựa trên kinh nghiệm học được từ dữ liệu hoặc các quan sát trước đó.",
        "Summary": "Học máy (machine learning) là kỹ thuật cho phép chương trình máy tính cải thiện hiệu suất dựa trên kinh nghiệm, quan sát hoặc dữ liệu quá khứ, thay vì chỉ thực hiện theo các quy tắc lập trình sẵn. Ví dụ, chương trình có thể học cách chơi cờ dựa trên các ván cờ trước đó hoặc nhận dạng ký tự từ dữ liệu ảnh và mã UNICODE. Một hệ thống học máy cần khả năng ghi nhớ, thích nghi và tổng quát hóa để ra quyết định chính xác trong các trường hợp mới.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa học máy, ví dụ minh họa và các khả năng cần thiết của một hệ thống học máy."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00114",
        "Article": "NoSQL là một thuật ngữ nổi tiếng trong lĩnh vực công nghệ, có nghĩa là \"Not Relational SQL\" hoặc \"Not Only SQL\". Điều này xuất phát từ thực tế rằng trong kiến trúc Big Data, dữ liệu tồn tại dưới nhiều định dạng khác nhau, không chỉ giới hạn ở mô hình quan hệ truyền thống. Hệ quản trị cơ sở dữ liệu quan hệ (RDBMS) không đủ linh hoạt để xử lý tất cả các loại dữ liệu này. Do đó, nhiều công nghệ, kiến trúc và thuật toán mới đã được phát triển để có thể tiếp nhận và xử lý dữ liệu phi cấu trúc, bán cấu trúc hoặc có cấu trúc không đồng nhất. Những công nghệ này được gọi chung là NoSQL, giúp giải quyết các hạn chế của SQL truyền thống trong việc xử lý dữ liệu lớn. Big Data mang lại nhiều lợi ích quan trọng, đặc biệt là trong các lĩnh vực thương mại, tài chính và quản lý. Có bốn lợi ích chính mà Big Data có thể đem lại, bao gồm cắt giảm chi phí, giảm thời gian xử lý, tối ưu hóa sản phẩm và hỗ trợ con người đưa ra quyết định chính xác hơn. Chẳng hạn, trong lĩnh vực thương mại điện tử, các hệ thống phân tích dữ liệu lớn có thể đưa ra các gợi ý sản phẩm thông minh, giúp tăng trải nghiệm mua sắm của khách hàng. Khi người dùng tìm kiếm một sản phẩm như điện thoại trên các trang web như eBay hay Amazon, hệ thống sẽ tự động đề xuất các phụ kiện liên quan như ốp lưng, pin dự phòng. Tương tự, nếu khách hàng mua áo thun, hệ thống có thể gợi ý thêm quần jean hoặc dây nịt. Điều này giúp doanh nghiệp tối ưu hóa doanh thu, đồng thời mang lại trải nghiệm cá nhân hóa cho người dùng. NoSQL và Big Data đang ngày càng trở thành nền tảng quan trọng trong việc phát triển các hệ thống thông minh, giúp doanh nghiệp tận dụng hiệu quả nguồn dữ liệu khổng lồ trong thời đại số.",
        "Summary": "NoSQL, viết tắt của \"Not Relational SQL\" hoặc \"Not Only SQL\", ra đời để giải quyết hạn chế của RDBMS trong việc xử lý dữ liệu phi cấu trúc, bán cấu trúc và có cấu trúc không đồng nhất trong kiến trúc Big Data. Big Data mang lại nhiều lợi ích như cắt giảm chi phí, giảm thời gian xử lý, tối ưu hóa sản phẩm và hỗ trợ ra quyết định. Ví dụ, trong thương mại điện tử, Big Data giúp đưa ra gợi ý sản phẩm thông minh, tăng trải nghiệm mua sắm và tối ưu hóa doanh thu. NoSQL và Big Data là nền tảng quan trọng cho các hệ thống thông minh hiện đại.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa NoSQL, lợi ích của Big Data và ứng dụng của chúng trong thương mại điện tử, đúng với trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00115",
        "Article": "Khởi động một chương trình: Có nhiều cách để khởi động một chương trình từ Windows: chọn Start Menu -> Tên chương trình ứng dụng. Hoặc từ Search Box -> nhập tên chương trình -> click chọn chương trình từ danh sách tìm thấy Hoặc double click vào Shortcut (nếu có) để khởi động các chương trình. Để thoát khỏi chương trình ứng dụng: Nhấn tổ hợp phím Alt + F4, hoặc click vào nút Close, hoặc Chọn Tab File->Exit. • Tự động chạy ứng dụng khi khởi động Windows: Một số cần được tự khởi động ngay khi bắt đầu phiên làm việc với Windows. Để thực hiện điều này ta tạo Shortcut của chương trình đó trong mục Start up: Search Box -> nhập Startup Apps-> double click vào tên Startup để mở cửa sổ Startup. • Cửa sổ chương trình: Người sử dụng giao tiếp với các chương trình thông qua các cửa sổ, một cửa sổ chương trình gồm các thành phần sau: - Title bar: hiển thị tên chương trình - Toolbar: Chứa các lệnh thường sử dụng dưới dạng các công cụ. - Statusbar: Thanh trạng thái, hiển thị thông tin trong cửa sổ. - Scrollbar: Thanh cuộn, dùng để xem phần nội dung bị che khuất. - Các nút Minimize, Maximize, Close: Phóng to, thu nhỏ, đóng cửa sổ chương trình. - Path: Đường dẫn, dùng để di chuyển nhanh đến một thư mục hoặc một tệp tin. - Menu bar: Thanh menu, chứa các nút lệnh của chương trình. • Các thao tác trên một cửa sổ: - Di chuyển cửa sổ: kéo thanh Title để cửa sổ đến vị trí mới. - Thay đổi kích thước của cửa sổ: Di chuyển con trỏ chuột đến cạnh hoặc góc cửa sổ, khi con trỏ chuột biến thành hình mũi tên hai chiều thì drag cho đến khi đạt được kích thước mong muốn. - Phóng to cửa sổ ra toàn màn hình: click nút Maximize. - Phục hồi kích thước trước đó của cửa sổ: click nút Restore. - Thu nhỏ cửa sổ thành biểu tượng trên Taskbar: Click lên nút Minimize - Chuyển đổi giữa các cửa sổ của các ứng dụng đang mở: Để chuyển đổi giữa các ứng dụng nhấn tổ hợp phím Alt + Tab hoặc chọn ứng dụng tương ứng trên thanh Taskbar. • Sao chép dữ liệu giữa các ứng dụng: Trong Windows việc sao chép dữ liệu trong một ứng dụng hoặc giữa các ứng dụng được thực hiện thông qua bộ nhớ đệm (Clipboard). Tại một thời điểm, bộ nhớ đệm chỉ chứa một thông tin mới nhất. Khi một thông tin khác được đưa vào bộ nhớ đệm thì thông tin trước đó sẽ bị xoá. Khi thoát khỏi Windows thì nội dung trong bộ nhớ đệm cũng bị xoá. Các bước sao chép dữ liệu: − Chọn đối tượng cần sao chép. − Chọn Home->Copy (hoặc tổ hợp phím Ctrl + C). − Chọn vị trí cần chép tới. − Chọn Home->Paste (hoặc tổ hợp phím Ctrl + V) để chép dữ liệu từ Clipboard vào vị trí cần chép. • Tìm kiếm dữ liệu: Chức năng tìm kiếm trong Windows 10 giúp tìm hầu như tất cả những gì có trên PC của bạn một cách nhanh chóng và dễ dàng. Có nhiều cách để tìm kiếm, người dùng có thể sử dụng Search box ở Thanh Taskbar, Search box trong thư mục hay thư viện... • Tìm kiếm bằng Search box ở Thanh Taskbar: Click chuột vào Start button->Search và nhập từ hay bộ phận của từ cần tìm vào Search box. Kết quả sẽ được xuất trực tiếp lên khung kết quả tìm kiếm. • Tìm kiếm bằng Search box ở thư mục Mở ổ đĩa, thư mục hay thư viện nơi mà bạn muốn tìm kiếm, nhập vào Search box từ hay bộ phận của từ cần tìm. (có thể bổ sung điều kiện tìm bằng cách hiệu chỉnh trong công cụ hỗ trợ Search).",
        "Summary": "Để khởi động chương trình trong Windows, có thể sử dụng Start Menu, Search Box hoặc shortcut. Thoát chương trình bằng Alt + F4, nút Close hoặc File -> Exit. Ứng dụng có thể tự động chạy khi khởi động Windows bằng cách tạo shortcut trong Startup Apps. Cửa sổ chương trình gồm Title bar, Toolbar, Statusbar, Scrollbar, các nút Minimize/Maximize/Close, Path và Menu bar, cho phép di chuyển, thay đổi kích thước, phóng to/thu nhỏ và chuyển đổi giữa các cửa sổ. Sao chép dữ liệu giữa các ứng dụng thông qua Clipboard bằng các lệnh Copy (Ctrl + C) và Paste (Ctrl + V). Tìm kiếm dữ liệu nhanh chóng bằng Search box ở Taskbar hoặc trong thư mục, có thể bổ sung điều kiện tìm kiếm.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Nhờ đó, bản tóm tắt tập trung vào trọng tâm và cung cấp thông tin hữu ích nhất cho người đọc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Đảm bảo đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Văn bản tóm tắt đã chọn lọc và trình bày thông tin một cách hiệu quả, giúp người đọc dễ dàng nắm bắt nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00116",
        "Article": "Bảo mật Web server thương mại điều có cùng một dạng điều khiển truy nhập chống xâm phạm. Một số web server cung cấp hàng loạt các lựa chọn điều khiển truy nhập cho người quản trị như địa chỉ IP, tên máy khách, tập tin, thư mục, tên người dùng và nhóm người dùng. Cơ cấu bảo mật có thể nằm trong web server hoặc trong hệ điều hành hay các thành phần liên kết. Các web server xử lý thông tin mật giống như trong các ứng dụng thương mại điện tử cần thiết bảo mật giao tác. Với tính năng này, truyền thông trên mạng giữa khách hàng và máy chủ được mã hóa. Giao thức được sử dụng cho bảo mật gồm Secure Sockets Layer (SSL) và Secure HTTP (SHTTP). Giao thức được sử dụng nhiều nhất là SSL, mã hóa toàn bộ phiên giao tác khách hàng/chủ. SHTTP là loại hướng tập tin. Thay vì mã hóa toàn bộ giao tác, giao thức này mã hóa các văn bản Web, sử dụng cho cả máy khách và máy chủ. Tuy nhiên, việc mã hóa dữ liệu phải dựa trên sự nhất quán về thuật toán giữa máy chủ và máy khách. Lưu trữ và truy nhập cơ sở dữ liệu Một lĩnh vực mà các nhà cung cấp web server đang bắt đầu khai phá là các giao thức dữ liệu, văn bản web lưu trữ và truy nhập như thế nào. Phương pháp thông thường nhất là dữ liệu được lưu dưới dạng các tập tin riêng rẽ trên các máy chủ khác nhau. Tuy vậy, một vấn đề sẽ xuất hiện đối với các web server lớn bởi vì một số lớn tập tin tăng lên không ngừng làm cho máy chủ ngày càng khó khăn trong việc kết xuất dữ liệu. Lựa chọn cuối cùng Việc lập kế hoạch web server không kết thúc ở lựa chọn sản phẩm. Người quản trị mạng cần phải lưu tâm đến vấn đề trước khi cài đặt và cấu hình web server. Các vấn đề đó liên quan đến thiết kế mạng, độ tin cậy của máy và giá cả. Trước khi đưa vào sử dụng web server, người quản trị mạng cần đảm bảo kiến trúc hạ tầng cho việc xử lý giao dịch về web, chẳng hạn như dự tính lưu lượng yêu cầu tới, kích thước đường truyền, vị trí các bộ router và cấu hình của mạng nội bộ. Một vấn đề khó nhận ra nữa là các web server cần thiết phải có khả năng xử lý hoặc chịu các lỗi và tính dư thừa hay phân đoạn sản phẩm. Một cách để đảm bảo độ tin cậy máy chủ là sử dụng kỹ thuật gọi là DNS (Domain Name Server) trong đó có một máy chủ là ánh xạ dữ liệu của một máy chủ có địa chỉ IP khác. Nhưng cái khó là làm thế nào để đảm bảo tại mọi lúc hai máy chủ đều giống nhau. Hầu hết các sản phẩm web server đều có giá vài nghìn đôla. Nhưng thực tế việc này còn liên quan đến giá phát triển, bảo trì và điều hành hệ thống, nghĩa là, khả năng phát triển của nhà cung cấp web server, đội ngũ bảo trợ tại địa phương cũng như việc huấn luyện đào tạo có chất lượng.",
        "Summary": "\"Bảo mật Web server thương mại dựa trên các điều khiển truy nhập như địa chỉ IP, tên máy khách, tập tin, thư mục, tên người dùng và nhóm người dùng. Các web server xử lý thông tin mật cần bảo mật giao tác bằng giao thức SSL hoặc SHTTP, trong đó SSL mã hóa toàn bộ phiên giao tác và được sử dụng phổ biến hơn. Một vấn đề khác là cách web server lưu trữ và truy nhập dữ liệu. Ngoài ra, người quản trị mạng cần lưu ý đến thiết kế mạng, độ tin cậy của máy chủ (sử dụng DNS) và chi phí phát triển, bảo trì hệ thống khi lựa chọn web server.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc có thể dễ dàng hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các khía cạnh chính như bảo mật, lưu trữ dữ liệu, và các yếu tố cần xem xét khi lựa chọn web server."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác nội dung quan trọng của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00117",
        "Article": "Quá trình vận chuyển dữ liệu an toàn thực hiện bởi giao thức SSL Record sau khi khởi tạo phiên làm việc thành công. Giao thức SSL Record sử dụng các tham số mã hóa và các bộ mã hóa thiết lập trong quá trình khởi tạo để tạo đường hầm vận chuyển dữ liệu an toàn. SSL Record đảm bảo tính bí mật cho khối dữ liệu sử dụng mã hóa đối xứng với khóa phiên, và đảm bảo tính toàn vẹn và xác thực cho khối dữ liệu sử dụng hàm băm có khóa (MAC). Quá trình xử lý dữ liệu bởi SSL Record tại bên gửi, gồm các bước. Phân mảnh dữ liệu (Fragment): Dữ liệu từ ứng dụng (Application Data) được phân mảnh thành các khối cho phù hợp với việc đóng gói và truyền của các lớp giao thức tầng thấp hơn. Nén dữ liệu (Compress): Từng khối dữ liệu được được nén để giảm kích thước. Bước nén dữ liệu là không bắt buộc. Thêm MAC (Add MAC): Tính toán giá trị MAC (sử dụng hàm băm có khóa) cho khối dữ liệu nén và ghép giá trị MAC vào khối dữ liệu. Việc thêm MAC và kiểm tra MAC ở bên nhận để đảm bảo tính toàn vẹn và xác thực khối dữ liệu. Mã hóa (Encrypt): Mã hóa khối dữ liệu (gồm khối dữ liệu nén và MAC) để đảm bảo tính bí mật sử dụng mã hóa khóa đối xứng với khóa phiên. Thêm đề mục của SSL Record (Append SSL Record Header): thêm đề mục của SSL Record vào khối dữ liệu đã mã hóa và chuyển xuống tầng giao vận để chuyển sang bên nhận. Quá trình xử lý dữ liệu khối dữ liệu nhận được tại bên nhận được thực hiện bởi SSL Record theo trình tự ngược lại, gồm các bước: Tách đề mục của SSL Record, Giải mã, Tách và kiểm tra MAC, Giải nén và Ghép các mảnh dữ liệu thành chuỗi dữ liệu để chuyển cho lớp ứng dụng.",
        "Summary": "Giao thức SSL Record vận chuyển dữ liệu an toàn bằng cách sử dụng mã hóa đối xứng với khóa phiên để đảm bảo tính bí mật và hàm băm có khóa (MAC) để đảm bảo tính toàn vẹn và xác thực. Tại bên gửi, dữ liệu được phân mảnh, nén (nếu cần), thêm MAC, mã hóa và gắn đề mục trước khi gửi. Tại bên nhận, dữ liệu được xử lý ngược lại để giải mã, kiểm tra MAC, giải nén và ghép mảnh trước khi chuyển cho lớp ứng dụng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào chức năng và quy trình xử lý dữ liệu của giao thức SSL Record, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00118",
        "Article": "Hình 9.7: Hai hàm khởi tạo chồng. Nói cách khác là ta có các hàm khởi tạo chồng nhau để phục vụ các lựa chọn khác nhau cho việc tạo mới đối tượng. Và cũng như các phương thức chồng khác, các hàm khởi tạo chồng nhau phải có danh sách tham số khác nhau. 148 Như với khai báo lớp Cow trong ví dụ Hình 9.7, ta viết hai hàm khởi tạo cho lớp Cow, và người dùng sẽ có hai lựa chọn để tạo một đối tượng Cow mới: Cow c1 = new Cow(12.1); hoặc Cow c1 = new Cow(); Quay lại vấn đề về hàm khởi tạo không nhận đối số mà trình biên dịch cung cấp cho ta. Không phải lúc nào ta cũng có sẵn một hàm khởi tạo như vậy. Trình biên dịch chỉ cung cấp cho ta một hàm khởi tạo mặc định nếu ta không viết bất cứ một hàm khởi tạo nào cho lớp đó. Khi ta đã viết dù chỉ một hàm khởi tạo cho lớp đó, thì ta phải tự viết cả hàm khởi tạo không nhận đối số nếu cần đến nó. Những điểm quan trọng: • Biến thực thể sống ở bên trong đối tượng chủ của nó. • Các đối tượng sống trong vùng bộ nhớ heap. • Hàm khởi tạo là đoạn mã sẽ chạy khi ta gọi new đối với một lớp đối tượng • Hàm khởi tạo mặc định là hàm khởi tạo không lấy đối số. • Nếu ta không viết một hàm khởi tạo nào cho một lớp thì trình biên dịch sẽ cung cấp một hàm khởi tạo mặc định cho lớp đó. Ngược lại, ta sẽ phải tự viết hàm khởi tạo mặc định. • Nếu có thể, nên cung cấp hàm khởi tạo mặc định để tạo điều kiện thuận lợi cho các lập trình viên sử dụng đối tượng. Hàm khởi tạo mặc định khởi tạo các giá trị mặc định cho các biến thực thể. • Ta có thể có các hàm khởi tạo khác nhau cho một lớp. Đó là các hàm khởi tạo chồng. • Các hàm khởi tạo chồng nhau phải có danh sách đối số khác nhau. • Các biến thực thể luôn có sẵn giá trị mặc định, kể cả khi ta không tự khởi tạo chúng. Các giá trị mặc định là 0/0.0/false cho các kiểu cơ bản và null cho kiểu tham chiếu.",
        "Summary": "Văn bản mô tả khái niệm hàm khởi tạo (constructor) trong lập trình hướng đối tượng, đặc biệt là hàm khởi tạo chồng (overloaded constructors). Trình biên dịch tự động cung cấp hàm khởi tạo mặc định (không tham số) nếu không có hàm khởi tạo nào được định nghĩa trong lớp. Tuy nhiên, nếu định nghĩa bất kỳ hàm khởi tạo nào, lập trình viên phải tự định nghĩa hàm khởi tạo mặc định nếu cần. Hàm khởi tạo được gọi khi tạo đối tượng mới (sử dụng từ khóa `new`), khởi tạo các biến thành viên với giá trị mặc định (0, 0.0, false hoặc null). Việc cung cấp hàm khởi tạo mặc định giúp lập trình viên dễ dàng sử dụng đối tượng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Tóm tắt tập trung vào khái niệm hàm khởi tạo, hàm khởi tạo mặc định và hàm khởi tạo chồng, đúng như trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00119",
        "Article": "HtmlTable control được sử dụng để điều khiển thẻ <table>. Trong HTML, thẻ <table> được sử dụng để tạo một bảng. Các thuộc tính: Align: Xác định cách sắp xếp của bảng. Attributes: Trả về tất cả tên thuộc tính và giá trị tương ứng của thuộc thẻ. BGColor: Xác định màu nền của bảng. Border: Xác định độ dày của viền. BorderColor: Xác định màu của viền. CellPadding: Xác định khoảng cách giữa viền của ô và nội dung bên trong. CellSpacing: Xác định khoảng cách giữa các ô. Disabled: Giá trị boolean xác định control có bị vô hiệu hóa hay không. Mặc định là false. Id: ID duy nhất của control. innerHtml: Điền vào hoặc trả về nội dung giữa thẻ đóng và thẻ mở, những ký tự đặc biệt thì không tự động chuyển thành các entities. innerText: Điền vào hoặc trả về nội dung giữa thẻ đóng và thẻ mở. Những ký tự đặc biệt tự động chuyển thành các entities. Rows: Trả về đối tượng HtmlRowCollection thể hiện tất cả các dòng trong bảng. Style: Xác định hoặc trả về thuộc tính CSS được áp dụng cho control. TagName: Trả về tên của thẻ. Visible: Giá trị boolean xác định control có được hiển thị hay không. Width: Xác định chiều rộng của bảng. Giao diện của chúng ta có hai HtmlSelect control và một HtmlInputButton. Người dùng có thể chọn số dòng và số cột của bảng. Khi người dùng nhấn nút submit, hàm xử lý sự kiện click của button được thực thi và tạo ra bảng với số dòng và số cột đã chọn. HtmlTableCell control được sử dụng để điều khiển thẻ <td> và <th>. Trong HTML, những thẻ này được sử dụng để tạo các ô trong bảng và các ô tiêu đề của bảng. Các thuộc tính: Align: Sắp xếp theo chiều ngang nội dung của ô. Attributes: Trả về tất cả tên thuộc tính và giá trị tương ứng của thuộc thẻ. BGColor: Xác định màu nền của ô. Border: Xác định độ dày của viền. ColSpan: Số cột mà ô mở rộng. Disabled: Giá trị boolean xác định control có bị vô hiệu hóa hay không. Mặc định là false. Id: ID duy nhất của control. innerHtml: Điền vào hoặc trả về nội dung giữa thẻ đóng và thẻ mở, những ký tự đặc biệt thì không tự động chuyển thành các entities. innerText: Điền vào hoặc trả về nội dung giữa thẻ đóng và thẻ mở. Những ký tự đặc biệt tự động chuyển thành các entities. RowSpan: Số dòng mà ô mở rộng. Runat: Xác định rằng control này là server control. Phải được xác định là \"server\". Style: Xác định hoặc trả về thuộc tính CSS được áp dụng cho control. TagName: Trả về tên của thẻ. Valign: Sắp xếp theo chiều dọc nội dung của ô. Visible: Giá trị boolean xác định control có được hiển thị hay không. Width: Xác định chiều rộng của ô. Giao diện của chúng ta có một HtmlTable control và một HtmlInputButton control. Khi người dùng nhấn nút submit, hàm xử lý sự kiện click của button này sẽ được thực thi. Khi đó, màu nền của bảng sẽ được gán là màu vàng và viền của bảng sẽ được đổi thành màu đỏ như hình dưới đây.",
        "Summary": "HtmlTable điều khiển thẻ <table> để tạo bảng với các thuộc tính về bố cục và hiển thị; người dùng có thể chọn số dòng, số cột và tạo bảng khi nhấn nút submit. HtmlTableCell điều khiển thẻ <td> và <th> để tạo các ô trong bảng với thuộc tính về vị trí và kích thước; khi nhấn nút submit, màu nền bảng sẽ chuyển thành vàng và viền đổi sang màu đỏ.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa, giúp người đọc nhanh chóng nắm bắt được nội dung cốt lõi."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt đầy đủ, chính xác, mạch lạc và liên quan đến nội dung gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00120",
        "Article": "Tấn công từ chối dịch vụ (DoS - Denial of Service) và tấn công phân tán từ chối dịch vụ (DDoS - Distributed Denial of Service) là những hình thức tấn công phổ biến nhằm làm gián đoạn hoặc tê liệt dịch vụ của một hệ thống, website hoặc ứng dụng. Trong cuộc tấn công DoS, kẻ tấn công gửi một lượng lớn yêu cầu hoặc gói dữ liệu độc hại đến mục tiêu nhằm làm cạn kiệt tài nguyên hệ thống như băng thông, CPU, bộ nhớ, hoặc làm nghẽn mạng. DDoS phức tạp hơn vì sử dụng nhiều máy tính bị kiểm soát từ xa (botnet) đồng thời phát động tấn công, khiến việc xác định nguồn gốc rất khó khăn và khả năng chống chịu của hệ thống bị thử thách nghiêm trọng. Các kỹ thuật tấn công có thể bao gồm: SYN flood, UDP flood, HTTP GET/POST flood, Smurf, ICMP flood, DNS amplification, v.v. Một số cuộc tấn công DDoS hiện nay còn kết hợp với mã độc hoặc tấn công ứng dụng, làm cho tác động trở nên nghiêm trọng hơn. Để phòng chống DDoS, cần kết hợp nhiều biện pháp: cấu hình hệ thống và tường lửa đúng cách, sử dụng hệ thống phát hiện và ngăn chặn xâm nhập (IDS/IPS), triển khai dịch vụ chống DDoS chuyên dụng từ các nhà cung cấp như Cloudflare, Akamai hoặc AWS Shield, đồng thời có kế hoạch khôi phục sau tấn công. Một số biện pháp khác bao gồm: giới hạn tốc độ truy cập, lọc lưu lượng bất thường, sử dụng CAPTCHA cho các dịch vụ web, và theo dõi hệ thống theo thời gian thực để phản ứng kịp thời. Ngoài ra, việc thường xuyên kiểm tra và đánh giá năng lực hệ thống trước các kịch bản DDoS giả lập (stress testing) cũng rất quan trọng. Trong bối cảnh nhiều tổ chức hoạt động trực tuyến, sự gián đoạn dịch vụ do DDoS không chỉ gây thiệt hại về tài chính mà còn ảnh hưởng đến uy tín và lòng tin của người dùng. Do đó, phòng chống DDoS cần được xem như một phần không thể thiếu trong chiến lược bảo vệ hạ tầng công nghệ thông tin hiện đại.",
        "Summary": "Tấn công từ chối dịch vụ (DoS) là hình thức tấn công nhằm làm cho hệ thống không thể phục vụ người dùng hợp pháp, gây gián đoạn hoạt động. Các kỹ thuật như gửi yêu cầu liên tục, chiếm dụng tài nguyên khiến hệ thống quá tải và ngừng hoạt động. Biến thể DDoS còn nguy hiểm hơn khi sử dụng nhiều nguồn tấn công phân tán. Để phòng ngừa, tổ chức cần triển khai tường lửa, hệ thống phát hiện xâm nhập, phân tích lưu lượng và phối hợp chặt chẽ với nhà cung cấp dịch vụ mạng để phản ứng nhanh và hiệu quả.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính về DoS, DDoS và các biện pháp phòng ngừa đều được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Cách trình bày rõ ràng, giúp người đọc nắm bắt nhanh chóng các ý chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa DoS và DDoS, cách thức tấn công và các biện pháp phòng ngừa. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Đã tóm gọn được các ý chính của văn bản gốc một cách trung thực, mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00121",
        "Article": "Sử dụng quy tắc Modus Ponens tổng quát cho phép xây dựng thuật toán suy diễn tự động, cụ thể là phương pháp suy diễn tiến và suy diễn lùi. Suy diễn tiến và lùi có thể áp dụng đối với KB chỉ chứa các câu xác định, tức là các câu Horn với đúng một literal dương. Suy diễn tiến (forward chaining) Giả sử ta có KB bao gồm các câu xác định. Thủ tục suy diễn tiến được thực hiện như sau: bắt đầu từ các câu trong KB, áp dụng Modus Ponens để sinh ra các câu mới cho đến khi không thể sinh ra thêm câu nào nữa. Nếu các câu trong KB được biểu diễn dưới dạng quy tắc kéo theo thì việc suy diễn được thực hiện theo chiểu của phép kéo theo, tức là từ các tiền để suy ra kết luận, do vậy suy diễn được gọi là suy diễn tiến. Nhận xét: Suy diễn tiến thêm dần các câu vào KB khi có các câu mới xuất hiện. Quá trình suy diễn này không hướng tới câu truy vấn hay kết luận cụ thể nào mà chỉ được khởi động khi có thêm câu mới. Nếu KB chỉ chứa các câu Horn xác định thì suy diễn tiến là thủ tục suy diễn đúng đắn, tức là chỉ sinh ra những câu thực sự là hệ quả logic của KB. Tính đúng đắn của suy diễn tiến được suy ra từ tính đúng đắn của Modus Ponens tổng quát. Nếu KB chỉ chứa các câu Horn xác định thì suy diễn tiến là thủ tục suy diễn đầy đủ, tức là có thể sinh ra tất cả các câu là hệ quả logic của KB. Tuy nhiên, do không phải câu logic vị từ nào cũng có thể biến đổi về dạng câu xác định nên suy diễn tiến không phải là thủ tục suy diễn đầy đủ đối với logic vị từ nói chung. Suy diễn lùi (Backward chaining) Thủ tục suy diễn tiến trình bầy ở trên bắt đầu từ các câu đã có trong KB và sinh ra các câu mới bằng cách sử dụng quy tắc GMP. Một vấn đề với suy diễn tiến là số câu sinh ra có thể rất nhiều, trước khi sinh ra được câu truy vấn mà ta cần xác định tính đúng sai. Ngược lại với suy diễn tiến, suy diễn lùi bắt đầu từ câu truy vấn, sau đó tìm các sự kiện và quy tắc trong KB cho phép chứng minh câu truy vấn là đúng. Quá trình suy diễn có thể coi như được tiến hành ngược với chiều của phép kéo theo, tức là từ hệ quả ta tìm cách tìm ra các tiền đề làm cho hệ quả đó đúng. Suy diễn lùi rất phù hợp với việc trả lời câu hỏi hoặc chứng minh một câu cụ thể là đúng hay sai từ các câu có trong KB. Quá trình suy diễn lùi được tiến hành như sau. Thủ tục suy diễn nhận câu hỏi hoặc câu cần chứng minh (gọi chung là câu truy vấn) dưới dạng một câu nguyên tử. Câu truy vấn có thể chứa lượng tử với mọi và biến tương ứng. Kết quả trả về là chuỗi các phép thế nếu có thể chứng minh câu truy vấn là đúng. Trước hết, thủ tục suy diễn tìm cách hợp nhất câu truy vấn với các các sự kiện trong KB (nhắc lại: sự kiện là câu Horn chỉ chứa một literal dương và không có literal âm). Nếu không được thì tìm luật và vế phải có thể hợp nhất với câu truy vấn sau đó tìm cách chứng minh vế trái một cách đệ quy bằng cách dùng cùng một thủ tục như chứng minh câu truy vấn.",
        "Summary": "\"Quy tắc Modus Ponens tổng quát cho phép xây dựng thuật toán suy diễn tự động, bao gồm suy diễn tiến và suy diễn lùi, áp dụng cho KB chứa các câu xác định (câu Horn với một literal dương). Suy diễn tiến bắt đầu từ các câu trong KB, áp dụng Modus Ponens để sinh ra các câu mới theo chiều của phép kéo theo (từ tiền đề suy ra kết luận), thêm dần các câu vào KB và là thủ tục suy diễn đúng đắn và đầy đủ nếu KB chỉ chứa các câu Horn xác định. Suy diễn lùi, ngược lại, bắt đầu từ câu truy vấn và tìm các sự kiện/quy tắc trong KB để chứng minh câu truy vấn là đúng theo hướng ngược lại với chiều của phép kéo theo (từ hệ quả tìm tiền đề), phù hợp cho việc trả lời câu hỏi hoặc chứng minh một câu cụ thể.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của suy diễn tiến và suy diễn lùi."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Đã làm nổi bật được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00122",
        "Article": "Khuôn dạng của bản tin HTTP Các đặc tả HTTP 1.0 (RFC 1945) và HTTP 1.1 (RFC 2016) qui định khuôn dạng bản tin yêu cầu và trả lởi của giao thức HTTP. Bản tin yêu cầu HTTP: Một bản tin yêu cầu thường có dạng sau: GET /english/index.html HTTP/1.l Host: www.ptit.edu.vn Connection: close User-agent:Mozzilla /4. 0 Accept- language:En (extra carry return line feed) Hình 3.3 Khuôn dạng chung của bản tin yêu cầu Trước hết ta thấy rằng bản tin được viết bằng mã ASCII vì thế bất kỳ máy tính thông thường nào cũng có thể đọc được. Thứ hai, bản tin gồm 5 dòng và mỗi dòng đều kết thúc bởi lặp ký tự đặc biệt Carriage Return (CR=13h) và Line Feed (LF-10h), trong thực tế một bản tin có thể có nhiều dòng hơn. Dòng đầu tiên của bản tin được gọi là dòng yêu cầu, các dòng sau gọi là tiêu đề. Dòng yêu cầu có 3 trường: trường phương thức, trường URL và trường phiên bản HTTP. Trường phương thức nhận một trong ba giá trị: GET, POST và PUT, thông thường các yêu cầu sử dụng phương thức GET, phương thức này được trình duyệt sử dụng để yêu cầu đối tượng có địa chỉ URL, trường phiên bản xác định phiên bản giao thức HTTP. Phương thức GET là yêu cẩu của máy khách gửi đến máy chủ để lấy dữ liệu web, phương thức POST dùng để gửi các thông Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 54 điệp cần đẩy dữ liệu lên máy chủ, phương thức PUT đẩy tài nguyên hoặc nội dung từ máy khách lên máy chủ. Trong ví dụ trên thì trình duyệt yêu cầu đối tượng english/index.html vả sử dụng phiên bản HTTP 1.1. Bây giờ hãy xét các trường trong tiêu đề, Host: www.ptit.edu.vn là địa chỉ của máy tính có chứa đối tượng được yêu cầu. Ý nghĩa của trường Connection: close là trình duyệt yêu cầu máy chủ không sử dụng cách kết nối liên tục và yêu cầu máy chủ đóng kết nối lại sau khi đã gửi đi đói tượng được yêu cầu, mặc đù máy khách sử dụng phiên bản HTTP 1.1 nhưng nó không sử dụng kết nối liên tục. Trường User-agent là phần mềm trình duyệt của người sử dụng, phần mềm trình duyệt ở đây là Mozzila, một sản phẩm của hãng Nestcape. Trường này rất quan trọng vì máy chủ có thể gửi các bản khác nhau của cùng một đối tượng đến các trình duyệt khác nhau (các bản đối tượng này đều được xác định qua cùng một địa chỉ URL duy nhất). Cuối cùng là trường Accept language trong ví đụ này người sử dụng yêu cầu bản tiếng Anh của đối tượng nếu máy chủ có bản này, trong trường hợp không có thì máy chủ gửi đi bản mặc định.",
        "Summary": "Bản tin HTTP, bao gồm yêu cầu và trả lời, tuân theo khuôn dạng được quy định trong các đặc tả HTTP 1.0 và 1.1. Bản tin yêu cầu HTTP thường có dạng ASCII, gồm dòng yêu cầu và các dòng tiêu đề, mỗi dòng kết thúc bằng CR và LF. Dòng yêu cầu chứa phương thức (GET, POST, PUT), URL và phiên bản HTTP. Các dòng tiêu đề cung cấp thông tin như địa chỉ máy chủ (Host), yêu cầu kết nối (Connection), thông tin trình duyệt (User-agent) và ngôn ngữ ưu tiên (Accept-language). Máy chủ có thể sử dụng thông tin này để gửi các phiên bản khác nhau của cùng một đối tượng cho các trình duyệt khác nhau hoặc lựa chọn ngôn ngữ phù hợp.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào khuôn dạng bản tin HTTP, các thành phần chính và ý nghĩa của chúng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00123",
        "Article": "First, a high transfer capacity must exist along the entire path between host memory and the individual disk drives. This includes internal controller buses, host system I/O buses, I/O adapters, and host memory buses. The second requirement is that the application must make I/O requests that drive the disk array efficiently. This requirement is met if the typical request is for large amounts of logically contiguous data, compared to the size of a strip. In this case, a single I/O request involves the parallel transfer of data from multiple disks, increasing the effective transfer rate compared to a single-disk transfer. RAID 0 FOR HIGH I/O REQUEST RATE In a transaction-oriented environment, the user is typically more concerned with response time than with transfer rate. For an individual I/O request for a small amount of data, the I/O time is dominated by the motion of the disk heads (seek time) and the movement of the disk (rotational latency). In a transaction environment, there may be hundreds of I/O requests per sec- ond. A disk array can provide high I/O execution rates by balancing the I/O load across multiple disks. Effective load balancing is achieved only if there are typically 2.5. Bộ nhớ ảo (Virtual Memory) Khái niệm bộ nhớ ảo: gồm bộ nhớ chính và bộ nhớ ngoài mà được CPU coi như là một bộ nhớ duy nhất (bộ nhớ Các kỹ thuật thực hiện bộ nhớ ảo: Kỹ thuật phân trang: Chia không gian địa chỉ bộ nhớ thành các trang nhớ có kích thước bằng nhau và nằm liền kề nhau Thông dụng: kích thước trang = 4KiB Kỹ thuật phân đoạn: Chia không gian nhớ thành các đoạn nhớ có kích thước thay đổi, các đoạn nhớ có thể gối lên nhau. CS-HEDSPI2019 Computer Systems 138 Phân chia bộ nhớ thành các phần có kích thước bằng nhau gọi là các khung trang Chia chương trình (tiến trình) thành các trang Cấp phát số hiệu khung trang yêu cầu cho OS duy trì danh sách các khung trang nhớ Tiến trình không yêu cầu các khung trang liên Sử dụng bảng trang để quản lý CS-HEDSPI2019 Computer Systems 139 8.3 / MEMORY MANAGEMENT But these addresses are not fixed. They will change each time a process is swapped in. To solve this problem, a distinction is made between logical addresses and physical addresses. A logical address is expressed as a location relative to the beginning of the program. Instructions in the program contain only logical addresses.",
        "Summary": "CS-HEDSPI2019 Computer Systems 138 Phân chia bộ nhớ thành các phần có kích thước bằng nhau gọi là các khung trang Chia chương trình tiến trình thành các trang Cấp phát số hiệu khung trang yêu cầu cho OS duy trì danh sách các khung trang nhớ Tiến trình không yêu cầu các khung trang liên Sử dụng bảng trang để quản lý CS-HEDSPI2019 Computer Systems 139 8.3 MEMORY MANAGEMENT But these addresses are not fixed.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt chứa thông tin từ văn bản gốc, tuy nhiên, nó chỉ tập trung vào một phần nhỏ của văn bản gốc và bỏ qua nhiều ý quan trọng khác. Ngoài ra, có một số phần trong bản tóm tắt có vẻ như được cắt ra trực tiếp từ văn bản gốc mà không có sự chỉnh sửa hoặc tóm lược, điều này làm giảm tính trung thực của nó như một bản tóm tắt thực sự."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có vẻ hơi rời rạc. Các câu và ý không được liên kết một cách rõ ràng, và có vẻ như chỉ là một tập hợp các câu được trích ra từ văn bản gốc. Cần có sự liên kết và diễn giải để tạo ra một bản tóm tắt mạch lạc hơn."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tập trung vào một phần cụ thể của văn bản gốc (quản lý bộ nhớ và bộ nhớ ảo), nhưng bỏ qua các phần khác như RAID 0 và các yêu cầu về dung lượng truyền tải. Điều này làm cho bản tóm tắt không hoàn toàn liên quan đến toàn bộ nội dung của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt cần được cải thiện về cả ba mặt: tính trung thực, tính mạch lạc và tính liên quan. Cần đảm bảo rằng bản tóm tắt bao gồm các ý chính từ toàn bộ văn bản gốc, được trình bày một cách mạch lạc và dễ hiểu. Nên diễn giải lại các ý thay vì chỉ sao chép trực tiếp từ văn bản gốc."
            }
        }
    },
    {
        "Index": "00124",
        "Article": "Mã Caesar là một trong những hệ mã hóa được biết đến sớm nhất, do Julius Caesar sáng tạo và lần đầu tiên được sử dụng trong quân sự. Phương pháp mã hóa này rất đơn giản: mỗi chữ trong bản rõ được thay thế bằng chữ cái đứng thứ ba tiếp theo trong bảng chữ cái. Ví dụ, câu \"Meet me after the toga party\" sẽ được mã hóa thành \"PHHW PH DIWHU WKH WRJD SDUWB\". Ở đây, chữ \"m\" được thay bằng chữ \"p\" (m, n, o, p), chữ \"e\" được thay bằng chữ \"h\" (e, f, g, h), và tiếp tục tương tự với các chữ còn lại. Việc mã hóa có thể được định nghĩa thông qua ánh xạ bảng chữ cái như sau: dòng trên là bản rõ, dòng dưới là bản mã tương ứng: a b c d e f g h i j k l m n o p q r s t u v w x y z – D E F G H I J K L M N O P Q R S T U V W X Y Z A B C. Về mặt toán học, nếu ta gán số thứ tự cho mỗi chữ cái trong bảng chữ cái (a = 0, b = 1, ..., z = 25), thì mã hóa Caesar có thể được biểu diễn bằng phép toán: c = E(p) = (p + k) mod 26, p = D(c) = (c - k) mod 26. Trong đó, p là số thứ tự của chữ trong bản rõ, c là số thứ tự của chữ tương ứng trong bản mã, và k là khóa dịch chuyển. Với mã Caesar, khóa k có thể nhận 26 giá trị khác nhau (từ 0 đến 25), tuy nhiên thực tế chỉ có 25 khóa hiệu dụng, vì k = 0 giữ nguyên văn bản. Vì mọi chữ đều bị tịnh tiến cùng một khoảng cách, độ dài khóa thực tế chỉ là 1. Mã Caesar rất dễ bị bẻ khóa do số lượng khóa có thể có là rất ít. Vì chỉ có 26 giá trị khóa, kẻ tấn công có thể sử dụng phương pháp tìm duyệt tổng thể để thử tất cả các khóa và tìm ra bản rõ đúng. Chỉ cần thử tất cả 26 cách dịch chuyển, kẻ tấn công có thể xác định được bản rõ thông qua nội dung có ý nghĩa. Ngoài ra, phương pháp phân tích tần suất cũng có thể được áp dụng để phá mã, vì trong văn bản tự nhiên, một số chữ cái xuất hiện thường xuyên hơn những chữ cái khác. Nếu kẻ tấn công nhận thấy một chữ cái xuất hiện nhiều lần trong bản mã, họ có thể so sánh với tần suất của các chữ cái trong ngôn ngữ gốc và từ đó suy ra giá trị của khóa k. Do mức độ bảo mật thấp, mã Caesar hầu như không còn được sử dụng trong thực tế, nhưng nó là nền tảng quan trọng cho các hệ thống mã hóa phức tạp hơn.",
        "Summary": "Mã Caesar là một phương pháp mã hóa cổ điển, trong đó mỗi chữ trong bản rõ được thay thế bằng chữ cái đứng sau ba vị trí trong bảng chữ cái. Phương pháp này dễ bị bẻ khóa do chỉ có 26 khóa khả dĩ và có thể bị phá bằng cách thử tất cả các khóa hoặc phân tích tần suất chữ cái. Mặc dù không còn an toàn trong thực tế, mã Caesar vẫn là nền tảng cho các hệ thống mã hóa phức tạp hơn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất về mã Caesar."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó ngắn gọn, chính xác, mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00125",
        "Article": "Các khái niệm cơ sở trong Amazon S3 Đối tượng dữ liệu (Objects): Các đối tượng dữ liệu được coi như khái niệm các tập tin trong hệ thống quản lý tập tin thông thường. Mỗi đối tượng được lưu trữ với siêu dữ liệu đặc tả đi kèm như ngày chỉnh sửa, ngày khởi tạo,… Số lượng các đối tượng mà người sử dụng có thể lưu trữ là vô hạn và mỗi đối tượng có thể chứa 5 TB dữ liệu. Thùng (buckets): Mỗi đối tượng được lưu trữ trong một thùng, được hiểu như là một thư mục trên hệ quản lý tập tin. Tuy nhiên, khác với hệ quản lý tập tin, các thùng chỉ chứa các đối tượng dữ liệu, không chứa các thùng con. Khóa (keys): Mối đối tượng dữ liệu trong Amazon S3 được định danh bởi một khóa duy nhất ứng với thùng có chứa đối tượng đó. S3 hỗ trợ tính phiên bản, do vậy định danh của mỗi một phiên bản (version) của đối tượng dữ liệu được xây dựng từ tên thùng, khóa và mã phiên bản. Vùng địa lý kho lưu trữ (Regions): Người sử dụng S3 khởi tạo thùng theo khu vực địa lý nơi triển khai hệ thống S3. Việc cho phép lựa chọn vùng lưu trữ là để tối ưu độ trễ đường truyền tăng tốc độ truy cập. S3 hiện nay được triển khai trên các vùng địa lý như Mỹ, châu Âu, khu vực châu Á,… Thiết kế Amazon không công bố thông tin chi tiết thiết kế của S3. Theo Amazon, thiết kế của S3 nhằm mục đích cung cấp khả năng mở rộng, tính sẵn sàng cao và độ trễ thấp với chi phí. S3 lưu trữ các đối tượng hay thực thể dữ liệu kích thước lên đến 5 terabyte. Các đối tượng được tổ chức thành các thùng bucket (mỗi thùng thuộc sở hữu của một dịch vụ Web Amazon hoặc tài khoản AWS). Mỗi thực thể được định danh trong mỗi nhóm bằng một khóa duy nhất gán với người sử dụng. Các thùng và các đối tượng có thể được tạo ra, được liệt kê và lấy ra bằng cách sử dụng hoặc một giao diện HTTP kiểu REST hoặc giao diện SOAP. Ngoài ra, các đối tượng có thể được tải về bằng cách sử dụng giao diện giao thức BitTorrent. S3 hỗ trợ các giao thức bảo mật, chính sách quyền truy cập đến các đối tượng và các thùng. Tên và khóa thùng được lựa chọn nên các đối tượng có thể được đánh địa chỉ thông qua URL: http://s3.amazonaws.com/bucket/key http://bucket.s3.amazonaws.com/key Vì các đối tượng có thể truy cập qua giao thức HTTP, S3 có thể được sử dụng để thay thế đáng kể cơ sở hạ tầng lưu trữ web tĩnh hiện có. Cơ chế xác thực AWS Amazon cho phép chủ sở hữu nhóm tạo ra một URL xác thực với thời gian tồn tại được định sẵn. Ví dụ như, người sử dụng có thể xây dựng một URL mà có thể được giao cho một bên thứ ba để truy cập trong một Mỗi mục trong một thùng cũng có thể được phục vụ như là một nguồn cấp dữ liệu BitTorrent. Các kho dữ liệu của S3 có thể hoạt động như một máy chủ lưu trữ nguồn cho một torrent và client BitTorrent bất kỳ có thể lấy lại tập tin qua giao thức BitTorrent. Điều này làm giảm đáng kể chi phí băng thông cho việc tải xuống của các thực thể phổ biến vì các client BitTorrent trong quá trình tải về đối tượng dữ liệu cũng đóng góp vào việc làm trung gian đưa dữ liệu tới các client khác.",
        "Summary": "\"Amazon S3 lưu trữ dữ liệu dưới dạng đối tượng (tương tự như tập tin) trong các thùng (tương tự như thư mục), mỗi đối tượng có khóa duy nhất. S3 hỗ trợ tính phiên bản, định danh phiên bản được xây dựng từ tên thùng, khóa và mã phiên bản. Người dùng có thể chọn vùng địa lý lưu trữ để tối ưu tốc độ truy cập. S3 cung cấp khả năng mở rộng, tính sẵn sàng cao và độ trễ thấp, cho phép truy cập đối tượng qua HTTP (dùng thay thế hạ tầng lưu trữ web tĩnh) hoặc BitTorrent (giảm chi phí băng thông cho tải xuống). S3 cũng hỗ trợ các giao thức bảo mật và chính sách quyền truy cập, cho phép tạo URL xác thực có thời gian tồn tại nhất định.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, giúp người đọc dễ dàng nắm bắt được nội dung chính của văn bản gốc. Các câu liên kết với nhau một cách trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các khái niệm cơ bản của Amazon S3, cách tổ chức dữ liệu, các tính năng quan trọng và lợi ích của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ và chính xác về Amazon S3. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00126",
        "Article": "2.1.3.2 Thẻ ghi nợ\n ü Khái niệm\n Thẻ ghi nợ là loại thẻ cho phép chủ sở hữu thẻ chi tiêu trực tiếp trên tài khoản tiền gửi\n của mình tại ngân hàng phát hành thẻ. Với loại thẻ này, chủ thẻ có thể chi trả tiền hàng hoá,\n dịch vụ dựa trên số dư tài khoản tiền gửi của mình tại ngân hàng phát hành thẻ. Thẻ thanh\n toán không có hạn mức tín dụng vì nó phụ thuộc vào số dư hiện hữu trên tài khoản của chủ\n thẻ. Số tiền chủ thẻ chi tiêu sẽ được khấu trừ ngay vào tài khoản của chủ thẻ thông qua những\n thiết bị điện tử đặt tại cơ sở chấp nhận thẻ. Trong một số trường hợp, chủ thẻ cũng có thể\n được ngân hàng cấp cho một mức thấu chi, tuỳ theo sự thoả thuận giữa chủ thẻ và ngân hàng.31\n Đó là một khoản tín dụng ngắn hạn mà ngân hàng cấp cho chủ thẻ.\n ü Phân loại thẻ ghi nợ\n Phân loại theo phương thức khấu trừ tài khoản\n - Thẻ ghi nợ trực tuyến (online): Là loại thẻ mà giá trị những giao dịch được khấu trừ\n ngay lập tức vào tài khoản của chủ thẻ. Những thông tin về giao dịch được kết nối trực tiếp từ\n thiết bị điện tử đặt tại cơ sở chấp nhận thẻ hoặc điểm rút tiền mặt tới ngân hàng phát hành.\n Giá trị những giao dịch được khấu trừ trực tiếp và lập tức vào tài khoản của chủ thẻ. Với thẻ\n ghi nợ online thì khi thanh toán đòi hỏi được cấp phép ngay lập tức.\n - Thẻ ghi nợ ngoại tuyến (offline): Là loại thẻ mà giá trị những giao dịch được khấu\n trừ vào tài khoản chủ thẻ sau đó vài ngày. Thông tin giao dịch được lưu tại máy điện tử của cơ\n sở chấp nhận thẻ và được chuyển đến ngân hàng phát hành muộn hơn (không có kết nối trực\n tiếp vào thời điểm thanh toán). Giá trị những giao dịch sẽ được khấu trừ vào tài khoản của chủ\n thẻ sau đó vài ngày, thường là từ hai đến ba ngày.\n Phân loại theo phạm vi khu vực\n - Thẻ ghi nợ nội địa: Là loại thẻ được sử dụng để giao dịch ở trong nước, hiện nay đa\n phần chúng ta đều sử dụng thẻ ghi nợ nội địa. Các thẻ nội địa ở Việt Nam đa phần vẫn được\n làm bằng công nghệ thẻ từ.\n - Thẻ ghi nợ quốc tế : Là loại thẻ được sử dụng để giao dịch ở nước ngoài, số lượng\n người sử dụng thẻ ghi nợ quốc tế thì ít hơn. Hiện nay tất cả các thẻ ghi nợ quốc tế ở Việt Nam\n đều sử dụng công nghệ chip thông minh.\n ü Đặc điểm của thẻ ghi nợ\n Chi tiêu tới đâu, khấu trừ tài khoản luôn tới đó\n Thẻ ghi nợ đơn giản là một tài khoản tiền gửi của khách hàng tại ngân hàng, khách\n hàng chi tiêu dựa trên chính số dư của mình vì thế đối với thẻ ghi nợ khách hàng chi tiêu tới\n đâu sẽ bị khấu trừ tiền luôn tới đó.\n Chi tiêu bằng tất cả các loại tiền\n Đây là đặc điểm đối với thẻ ghi nợ quốc tế, đối với thẻ ghi nợ quốc tế chủ thẻ có thể\n chi tiêu bằng tất cả các loại tiền, tuy nhiên sẽ phải mất phí chuyển đổi ngoại tệ.\n Không phải mất phí hoặc mất một khoản phí rất nhỏ khi rút tiền\n Đó là sự khác biệt rất lớn giữa thẻ tín dụng và thẻ ghi nợ, thẻ tín dụng sẽ phải mất phí\n cao do tiền chủ thẻ sử dụng chính là tiền đi vay của ngân hàng, còn đối với thẻ ghi nợ, chủ thẻ\n sẽ chi tiêu bằng chính số dư trên tài khoản tiền gửi của mình.\n Số dư trong tài khoản được hưởng lãi suất không kỳ hạn",
        "Summary": "Thẻ ghi nợ cho phép chủ thẻ chi tiêu trực tiếp từ tài khoản tiền gửi tại ngân hàng phát hành, không có hạn mức tín dụng mà phụ thuộc vào số dư tài khoản. Có hai loại thẻ ghi nợ theo phương thức khấu trừ: trực tuyến (khấu trừ ngay lập tức) và ngoại tuyến (khấu trừ sau vài ngày). Theo phạm vi khu vực, có thẻ ghi nợ nội địa (dùng trong nước) và quốc tế (dùng ở nước ngoài). Đặc điểm của thẻ ghi nợ là chi tiêu đến đâu khấu trừ đến đó, thẻ quốc tế có thể chi tiêu bằng nhiều loại tiền (mất phí chuyển đổi), phí rút tiền thấp hoặc không mất, và số dư trong tài khoản được hưởng lãi suất không kỳ hạn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa, phân loại và đặc điểm của thẻ ghi nợ, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Đảm bảo tính trung thực, mạch lạc và liên quan. Tóm tắt bao quát được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00127",
        "Article": "Khả năng chịu tải nâng cao: Về lý thuyết, tài nguyên tính toán trên đám mây là vô hạn. Việc thêm vào năng lực tính toán để chịu tải cao có thể được thực hiện chỉ bằng các thao tác kích chuột hoặc đã được tự động hoá. Độ tin cậy: Người sử dụng điện toán đám mây được ký hợp đồng sử dụng với điều khoản chất lượng dịch vụ rất cao ghi sẵn trong hợp đồng. Chất lượng dịch vụ đám mây đơn giản được đánh giá ổn định hơn hệ thống tự triển khai do nền tảng đám mây được thiết kế và bảo trì bởi đội ngũ chuyên gia nhiều kinh nghiệm về hệ thống. Hơn nữa, việc luôn làm việc với hệ thống lớn và gặp nhiều lỗi tương tự nhau nên quá trình khôi phục hệ thống sau thảm họa thông thường là nhanh chóng. Tính co giãn linh động: Tính co giãn thể hiện sự linh động trong việc cung cấp tài nguyên tính toán theo nhu cầu thực tế của người dùng hoặc các ứng dụng dịch vụ. Theo đó tài nguyên sẽ được đáp ứng một cách tự động sát với nhu cầu tại thời gian thực mà không cần người dùng phải có kỹ năng cho quá trình điều khiển này. Bảo mật: Tính bảo mật trong điện toán đám mây từ trước đến nay vẫn là câu hỏi lớn cho người dùng tiềm năng. Tuy nhiên, hiện nay, khả năng bảo mật trong môi trường đám mây đã được cải thiện đáng kể, nhờ vào một số lý do chính sau đây: do dữ liệu tập trung trong các đám mây ngày càng lớn nên các nhà cung cấp luôn chú trọng nâng cao công nghệ và đặt ra những rào cản để tăng tính an toàn cho dữ liệu. Bên cạnh đó, các nhà cung cấp đám mây có khả năng dành nhiều nguồn lực cho việc giải quyết các vấn đề bảo mật mà nhiều khách hàng không có đủ chi phí để thực hiện. Các nhà cung cấp sẽ ghi nhớ các nhật ký truy cập, nhưng việc truy cập vào chính bản thân các nhật ký truy cập này có thể cũng rất khó khăn do chính sách của nhà cung cấp đám mây khi người dùng tự mình muốn xác minh rõ hệ thống của mình có an toàn không. Mặc dù vậy, mối quan tâm lo ngại về việc mất quyền điều khiển dữ liệu nhạy cảm cũng ngày càng tăng cao.",
        "Summary": "Điện toán đám mây cung cấp khả năng chịu tải cao, độ tin cậy và tính co giãn linh động nhờ vào việc tự động hóa và quản lý bởi các chuyên gia. Mặc dù tính bảo mật đã được cải thiện với các công nghệ tiên tiến và nguồn lực từ nhà cung cấp, người dùng vẫn lo ngại về việc mất quyền kiểm soát dữ liệu nhạy cảm.\n",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic. Câu mở đầu giới thiệu các ưu điểm của điện toán đám mây, sau đó đề cập đến vấn đề bảo mật và nỗi lo của người dùng, tạo nên một dòng chảy thông tin liền mạch."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm khả năng chịu tải, độ tin cậy, tính co giãn, bảo mật và nỗi lo của người dùng. Các chi tiết không quan trọng đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Điểm mạnh là khả năng tóm gọn các ý chính một cách hiệu quả và trình bày chúng một cách rõ ràng. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00128",
        "Article": "a) Hãy xây dựng cây quyết định sử dụng thuật toán ID3. Trong trường hợp có hai thuộc tính tốt tương đương thì chọn theo thứ tự bảng chữ cái. b) Giả sử không biết nhãn phân loại của ví dụ cuối cùng, hãy xác định nhãn cho ví dụ đó bằng phương pháp Bayes đơn giản (chỉ rõ các xác suất điều kiện thành phần) và k láng giềng gần nhất với k = 5. 2. Cho dữ liệu huấn luyện dưới đây với 16 ví dụ. Sử dụng phân loại Bayes để tính giá trị của C nếu biết A = 0, B = 1. Yêu cầu viết chi tiết 3. Cho dữ liệu huấn luyện như trong bảng (f là nhãn phân loại). a) Hãy xác định nhãn cho ví dụ (Màu: Trắng, Hình dạng: Tròn, KL: Nặng) bằng phương pháp Bayes đơn giản (chỉ rõ các xác suất điều kiện thành phần) b) Hãy xác định nút gốc cho cây quyết định sử dụng thuật toán ID3 4. Cho dữ liệu huấn luyện như trong bảng sau, trong đó mỗi cột (trừ cột ngoài cùng bên trái) ứng với một mẫu, dòng dưới cùng (T) chứa giá trị đích: Hãy thực hiện thuật toán giảm gradient cho hồi quy tuyến tính với dữ liệu trên, ghi lại giá trị trọng số sau mỗi bước. Xây dựng cây quyết định cho dữ liệu trong bảng. 5. Hãy vẽ cây quyết định để biểu diễn các biểu thức logic sau: b) A ∨ (B ∧ C) d) (A ∧ B) ∧ (C ∧ D) S. Russell, P. Norvig. Artificial intelligence: a modern approach. 3nd edition. Prentice T. M. Jones. Artificial intelligence a system approach. Infinity science press. 2008. Đinh Mạnh Tường. Trí tuệ nhân tạo. Nhà xuất bản Khoa học kỹ thuật.",
        "Summary": "b Giả sử không biết nhãn phân loại của ví dụ cuối cùng, hãy xác định nhãn cho ví dụ đó bằng phương pháp Bayes đơn giản chỉ rõ các xác suất điều kiện thành phần và k láng giềng gần nhất với k 5. Yêu cầu viết chi tiết 3. a Hãy xác định nhãn cho ví dụ Màu Trắng, Hình dạng Tròn, KL Nặng bằng phương pháp Bayes đơn giản chỉ rõ các xác suất điều kiện thành phần b Hãy xác định nút gốc cho cây quyết định sử dụng thuật toán ID3 4.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt trích dẫn trực tiếp các yêu cầu từ văn bản gốc. Tuy nhiên, việc trích dẫn không đầy đủ các câu hỏi (ví dụ, câu 3 chỉ còn 'a Hãy xác định nhãn cho ví dụ Màu Trắng, Hình dạng Tròn, KL Nặng bằng phương pháp Bayes đơn giản chỉ rõ các xác suất điều kiện thành phần b Hãy xác định nút gốc cho cây quyết định sử dụng thuật toán ID3 4.') có thể gây khó hiểu nếu người đọc không có văn bản gốc để đối chiếu."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt liệt kê các yêu cầu từ văn bản gốc, nhưng thiếu sự liên kết giữa chúng. Các câu không được kết nối một cách logic, và việc thiếu ngữ cảnh khiến cho bản tóm tắt trở nên khó hiểu nếu đọc độc lập."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tập trung vào một số yêu cầu cụ thể từ văn bản gốc, nhưng bỏ qua các phần khác. Mặc dù các yêu cầu được chọn có vẻ quan trọng, nhưng việc thiếu các thông tin khác có thể làm giảm giá trị của bản tóm tắt. Ví dụ, bỏ qua các yêu cầu liên quan đến xây dựng cây quyết định đầy đủ."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt này chỉ đơn giản là trích xuất một số câu hỏi từ văn bản gốc mà không có sự chỉnh sửa hay sắp xếp lại để tạo thành một bản tóm tắt mạch lạc và dễ hiểu. Để cải thiện, cần chọn lọc các ý chính, diễn đạt lại bằng ngôn ngữ ngắn gọn hơn, và đảm bảo có sự liên kết logic giữa các ý. Cần tránh việc chỉ đơn thuần copy-paste các phần của văn bản gốc."
            }
        }
    },
    {
        "Index": "00129",
        "Article": "Trong hệ điều hành, việc lập trình cấp thấp và tiếp cận tài nguyên phần cứng thường được thực hiện thông qua các trình điều khiển thiết bị (device driver) và lời gọi hệ thống (system call), tuy nhiên với các ứng dụng đặc biệt, lập trình viên có thể cần sử dụng các cơ chế như ioctl (input/output control) để thao tác nâng cao với thiết bị. Lệnh ioctl cho phép người dùng gửi các lệnh điều khiển đặc biệt đến driver thông qua một file descriptor, thường là các thiết bị trong /dev, nhằm thực hiện các thao tác ngoài phạm vi đọc/ghi thông thường như thay đổi cấu hình, truy vấn trạng thái hoặc thực hiện hành động chuyên biệt. Mỗi ioctl có một mã lệnh riêng được định nghĩa trong các header hệ thống, và driver phải xử lý đúng các mã này thông qua hàm ioctl trong mã nguồn kernel. Các thao tác ioctl thường không thể đoán trước được hành vi nếu không có tài liệu chính xác từ nhà sản xuất hoặc mã nguồn mở, do đó đòi hỏi lập trình viên có kinh nghiệm và hiểu rõ kiến trúc thiết bị. Hệ điều hành cung cấp các macro như _IO, _IOR, _IOW, _IOWR để định nghĩa lệnh ioctl một cách nhất quán. Việc sử dụng ioctl sai cách có thể gây treo hệ thống, rò rỉ tài nguyên hoặc lỗi bảo mật nghiêm trọng, do đó cần kiểm tra kỹ đầu vào, quyền truy cập và xử lý lỗi đúng cách. Ioctl là cầu nối quan trọng giữa không gian người dùng và không gian kernel trong các ứng dụng cần kiểm soát sâu thiết bị như hệ thống nhúng, driver đồ họa, card mạng hoặc thiết bị ngoại vi đặc biệt. Đây là một trong những minh chứng rõ ràng nhất cho thấy sức mạnh và tính phức tạp của việc lập trình hệ điều hành ở cấp thấp.",
        "Summary": "Lập trình cấp thấp trong hệ điều hành giữ vai trò quan trọng trong việc điều khiển phần cứng và tối ưu hiệu suất. Các ngôn ngữ như C hoặc Assembly thường được sử dụng để phát triển các thành phần lõi, do khả năng kiểm soát trực tiếp bộ nhớ và tài nguyên. Việc lập trình ở mức thấp đòi hỏi kiến thức chuyên sâu, đồng thời tăng rủi ro lỗi hệ thống nếu không được kiểm soát kỹ lưỡng. Tuy nhiên, nó mang lại hiệu năng tối đa và khả năng tương tác sâu với phần cứng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chứa thông tin không có trong văn bản gốc và diễn giải sai lệch ý nghĩa ban đầu. Văn bản gốc tập trung vào cơ chế ioctl, trong khi bản tóm tắt lại nói chung về lập trình cấp thấp và các ngôn ngữ lập trình, điều này không chính xác và không phản ánh đúng nội dung của văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có tính mạch lạc tương đối, các câu liên kết với nhau một cách logic. Tuy nhiên, do nội dung không liên quan đến văn bản gốc nên tính mạch lạc không mang nhiều ý nghĩa."
            },
            "Tính liên quan": {
                "Điểm": 1,
                "Đánh giá": "Bản tóm tắt hoàn toàn không liên quan đến văn bản gốc. Văn bản gốc nói về ioctl, một cơ chế cụ thể trong lập trình hệ điều hành, trong khi bản tóm tắt lại nói về lập trình cấp thấp nói chung và các ngôn ngữ lập trình. Các chi tiết trong bản tóm tắt không phù hợp và không phản ánh trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất kém. Nó không trung thực, không liên quan và mặc dù có tính mạch lạc tương đối, nhưng điều này không có giá trị do nội dung sai lệch. Bản tóm tắt cần được viết lại hoàn toàn, tập trung vào cơ chế ioctl và các khía cạnh liên quan như mục đích, cách sử dụng, và rủi ro của nó."
            }
        }
    },
    {
        "Index": "00130",
        "Article": "Mạng riêng ảo (VPN – Virtual Private Network) là một giải pháp bảo mật phổ biến giúp thiết lập một kết nối an toàn giữa người dùng và hệ thống qua mạng Internet. VPN mã hóa toàn bộ dữ liệu truyền đi, từ đó bảo vệ thông tin khỏi bị nghe lén, giả mạo hoặc đánh cắp trong quá trình truyền. Điều này đặc biệt quan trọng khi người dùng truy cập từ mạng không đáng tin cậy như Wi-Fi công cộng, khách sạn hoặc quán cà phê. Có nhiều loại VPN như VPN truy cập từ xa (Remote Access VPN), VPN site-to-site (kết nối giữa các chi nhánh), hoặc VPN SSL tích hợp trên trình duyệt. Về mặt kỹ thuật, VPN sử dụng các giao thức bảo mật như IPsec, SSL/TLS, L2TP hoặc OpenVPN để thiết lập kênh truyền mã hóa. Ngoài việc bảo vệ dữ liệu, VPN còn giúp người dùng truy cập tài nguyên nội bộ từ xa như email, file server hoặc hệ thống ứng dụng, từ đó hỗ trợ mô hình làm việc linh hoạt. Trong môi trường doanh nghiệp, việc triển khai VPN cần kết hợp với các biện pháp xác thực mạnh (như xác thực hai yếu tố) và kiểm soát truy cập để đảm bảo chỉ những người dùng hợp lệ mới được kết nối. Một thách thức khi sử dụng VPN là hiệu suất truyền tải có thể bị ảnh hưởng do dữ liệu phải mã hóa và định tuyến lại. Vì vậy, hệ thống VPN cần được thiết kế có tính chịu tải cao, phân phối máy chủ phù hợp với vị trí địa lý và tích hợp với cơ chế giám sát để phát hiện truy cập bất thường. Ngoài ra, tổ chức cần có chính sách sử dụng VPN rõ ràng, hướng dẫn người dùng và ngăn chặn việc sử dụng các dịch vụ VPN không được kiểm soát, vốn có thể tạo ra lỗ hổng an ninh. Trong bối cảnh ngày càng nhiều người làm việc từ xa và hệ thống trở nên phân tán, VPN tiếp tục đóng vai trò quan trọng trong việc đảm bảo an toàn truy cập và bảo vệ dữ liệu nhạy cảm.",
        "Summary": "Mạng riêng ảo (VPN) giúp bảo vệ dữ liệu khi truyền tải qua Internet bằng cách mã hóa kết nối giữa thiết bị người dùng và hệ thống mạng. VPN đặc biệt hữu ích trong môi trường làm việc từ xa hoặc khi truy cập các mạng công cộng không an toàn. Tuy nhiên, việc sử dụng VPN cần đảm bảo cấu hình đúng, lựa chọn nhà cung cấp uy tín và giám sát truy cập để ngăn chặn lạm dụng. Đây là một trong những công cụ thiết yếu trong chiến lược bảo mật tổng thể của tổ chức.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Các ý chính về chức năng bảo vệ dữ liệu của VPN, tính hữu ích trong môi trường làm việc từ xa và tầm quan trọng của việc cấu hình, lựa chọn nhà cung cấp, giám sát truy cập đều được phản ánh chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn được liên kết chặt chẽ, tạo thành một dòng chảy thông tin logic và dễ hiểu. Ý về bảo vệ dữ liệu dẫn đến tính hữu ích trong môi trường làm việc từ xa, và sau đó là tầm quan trọng của việc cấu hình và giám sát, tạo nên một trình tự hợp lý."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm chức năng bảo vệ dữ liệu, ứng dụng trong môi trường làm việc từ xa và tầm quan trọng của việc quản lý VPN. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00131",
        "Article": "Quản lý dự án là việc áp dụng các tri thức, các kỹ năng, các công cụ và các kỹ thuật tới các hoạt động dự án để đạt được những yêu cầu của dự án Nhắc lại các hoạt động điển hình của dự án công nghệ thông tin nói chung và hệ thống phần mềm nói riêng • Thiết kế một giao diện đồ họa với người sử dụng • Cài đặt một mạng địa phương • Kiểm thử tích hợp của các thành phần trong hệ thống • Huấn luyện người sử dụng dùng ứng dụng mới • Cài đặt một tập các lớp của java • Lập tài liệu về các quyết định thiết kế và mã nguồn • Giao tiếp với đội dự án, khách hàng và đội ngũ quản lý • Ước lượng công sức cần thiết thực hiện • Các hoạt động lên kế hoạch và phân phối tài nguyên • So sánh năng suất làm việc trên thực tế với theo kế hoạch • Phân tích rủi ro • Thương lượng với khách hàng thứ cấp • Phân bổ nhân viên Quản lý dự án khác với quản lý chương trình bởi vì một chương trình thường bao gồm nhiều dự án liên quan đến nhau. Điều đó có nghĩa là một chương trình có kích cỡ lớn hơn rất nhiều một dự án, có thời gian hoạt động dài hơn. Ví dụ quản lý một chương trình MS Word gồm nhiều dự án khác nhau, mỗi dự án là một chức năng của chương trình đó. Khái niệm những người tham gia và liên quan đến dự án (Stakeholders): Đó chính là những người liên quan mà một giám đốc dự án cần làm việc và phối hợp để hoàn thành các công việc của dự án. Những người đó bao gồm: nhà tài trợ tài chính cho dự án thực hiện, người điều hành các công việc của dự án hay các chức năng trong tổ chức dự án, đội ngũ nhân viên tham gia quá trình phát triển dự án, khách hàng của dự án, người ký hợp đồng cho dự án, và quản lý của các nhóm chức năng trong công ty.",
        "Summary": "Quản lý dự án là việc áp dụng kiến thức, kỹ năng, công cụ và kỹ thuật để đáp ứng yêu cầu dự án, bao gồm các hoạt động như thiết kế giao diện, cài đặt mạng, kiểm thử, huấn luyện, lập trình, lập tài liệu, giao tiếp, ước lượng, lên kế hoạch, phân tích rủi ro, thương lượng và phân bổ nhân viên. Quản lý dự án khác quản lý chương trình ở quy mô và thời gian. Stakeholders là những người liên quan cần phối hợp, bao gồm nhà tài trợ, người điều hành, nhân viên, khách hàng, người ký hợp đồng và quản lý các nhóm chức năng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ nguyên và trình bày một cách chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Chỉ giữ lại các ý chính và loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa quản lý dự án, sự khác biệt với quản lý chương trình và khái niệm stakeholders, là những điểm quan trọng nhất của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Đảm bảo tính trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày các ý chính một cách hiệu quả, giúp người đọc nhanh chóng nắm bắt được nội dung cốt lõi của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00132",
        "Article": "Các chính sách nhằm khuyến khích doanh nghiệp đầu tƣ, phát triển ứng dụng, giải pháp tích hợp TTNT đã đƣợc quan tâm, chỉ đạo từ các cấp lãnh đạo cao nhất trong thời gian gần đây. Tuy nhiên, nhận thức của các cấp, các ngành trong những năm qua về vai trò của TTNT còn chƣa đầy đủ. Đầu tƣ của Nhà nƣớc về TTNT còn hạn chế, thiếu tập trung, hiệu quả chƣa cao. Việt Nam chƣa có chiến lƣợc phát triển dữ liệu quốc gia, chƣa có chính sách quốc gia và lộ trình phát triển TTNT. Hiện tại, Việt Nam cũng chƣa có khung pháp lý riêng cho TTNT, chƣa có cơ quan chỉ đạo quản lý, bộ phận công tác tƣ vấn, phối hợp hoạt động phát triển và triển khai TTNT ở cấp trung ƣơng và địa phƣơng, thiếu chính sách quốc gia và khung pháp lý về phát triển, ứng dụng và hợp tác quốc tế trong lĩnh vực TTNT. V. Kết luận Qua các phân tích trên có thể thấy ứng dụng TTNT đã đi vào rất nhiều lĩnh vực, ngành nghề trên thế giới nói chung và Việt Nam nói riêng. TTNT đã trở thành một trong các động lực mới của kinh tế xã hội, đem lại doanh thu và tăng trƣởng cho các ngành nghề truyền thống và cơ hội đột phá, phát triển các giải pháp mới, ngành nghề mới. Thị trƣờng ứng dụng TTNT đã hình thành với các lớp dịch vụ từ nền tảng nghiên cứu, phát triển đến cài đặt, tích hợp, triển khai, bảo trì và hỗ trợ các hệ thống ứng dụng sử dụng TTNT. Việt Nam cần xây dựng các tiêu chuẩn, quy chuẩn kỹ thuật, yêu cầu về đạo đức đối với TTNT để quản lý cũng nhƣ tạo hành lang phát triển bền vững cho thị trƣờng ứng dụng TTNT. Các khung pháp lý rõ ràng nhƣ vậy sẽ góp phần khuyến khích các doanh nghiệp, tổ chức và cá nhân đầu tƣ, phát triển ứng dụng TTNT.",
        "Summary": "Hiện tại, Việt Nam cũng chƣa có khung pháp lý riêng cho TTNT, chƣa có cơ quan chỉ đạo quản lý, bộ phận công tác tƣ vấn, phối hợp hoạt động phát triển và triển khai TTNT ở cấp trung ƣơng và địa phƣơng, thiếu chính sách quốc gia và khung pháp lý về phát triển, ứng dụng và hợp tác quốc tế trong lĩnh vực TTNT. Việt Nam cần xây dựng các tiêu chuẩn, quy chuẩn kỹ thuật, yêu cầu về đạo đức đối với TTNT để quản lý cũng nhƣ tạo hành lang phát triển bền vững cho thị trƣờng ứng dụng TTNT.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt mạch lạc, các câu văn liên kết chặt chẽ và dễ hiểu. Các ý được trình bày một cách rõ ràng và logic."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Các ý được chọn lọc đều là những điểm quan trọng trong văn bản gốc, tập trung vào thực trạng thiếu khung pháp lý và sự cần thiết xây dựng các tiêu chuẩn cho TTNT ở Việt Nam."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt, đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Bản tóm tắt đã chọn lọc và trình bày những ý chính của văn bản gốc một cách hiệu quả."
            }
        }
    },
    {
        "Index": "00133",
        "Article": "2.2.3. Các phép toán trên véctơ và m trận 2.2.3.1. Các phép toán số học Chúng ta có thể tiến hành một số phép toán số học nhất định (cộng, trừ) với các véctơ hoặc ma trận cùng kích thƣớc. MATLAB sẽ báo lỗi khi ta thực hiện các phép toán này với các ma trận có kích thƣớc (chiều dài) khác nhau. Ví dụ: >>v1 = [1 2 3] >>v2 = [ 4 5 6] Một véc tơ cũng có thể nhân đƣợc với một đại lƣợng vô hƣớng (một số), thao tác đƣợc MATLAB tiến hành với từng phần tử. Ví dụ: Để tiến hành các tính toán cùng loại (tính toán với từng phần tử): nhân, chia và lũy thừa, MATLAB đƣa ra các toán tử \".*\" , \"./\" và \".^\". Ví dụ: >> a = [1 2 3; 2 4 1; 2 7 2]; >> b = [1 3 1; 2 7 1; 1 2 3]; Nhân hai ma trân a và b theo cách thông thƣờng: Nhân từng phần tử của ma trân a với các phần tử tƣơng ứng của ma trận b (sử dụng dấu Tƣơng tự nhƣ thế đối với các phép toán chia (./) và lũy thừa (.^). Ví dụ: >>c = [1 3; 5 2]; % ươ g đươ g * % Bì h hươ g hầ ử ủa . Tất cả các hàm số học dựng s n của MATLAB đƣợc thiết kế để hoạt động với các véctơ (và ma trận), vì vậy chúng ta có thể xây dựng các diễn giải đại số hoạt động với từ ng phần tử Ví dụ: đoạn mã lệnh dƣới đây tính toán giá trị biểu thức: phần tử. Tính với mỗi một phần tử trong véctơ x và y: >> x = [1 2 3]; y = [4 5 6]; >> s = x.^2 + sqrt(x.*y) – 3*y Lƣu ý các phép tính của các đại lƣợng vô hƣớng trên các véctơ khác nhƣ thế nào với cách làm việc phần tử với phần tử, ví dụ: 3*y rõ ràng là nhân số vô hƣớng với véctơ, trong khi x*y thì khác, vì vậy ở đây ta cần phải sử dụng x.*y Chú ý: Các phép cộng và trừ phần tử với phần tử lẽ ra cũng phải sử dụng \".+\" và \".-\", tuy nhiên trong ví dụ này thì không cần thiết.",
        "Summary": "Tất cả các hàm số học dựng s n của MATLAB đƣợc thiết kế để hoạt động với các véctơ và ma trận, vì vậy chúng ta có thể xây dựng các diễn giải đại số hoạt động với từ ng phần tử Ví dụ đoạn mã lệnh dƣới đây tính toán giá trị biểu thức phần tử. Tính với mỗi một phần tử trong véctơ x và y x 1 2 3 y 4 5 6 s x. 2 + sqrtx.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một phần là trích dẫn nguyên văn từ văn bản gốc, tuy nhiên, phần trích dẫn này bị cắt xén và không đầy đủ. Ngoài ra, có một vài kí tự bị lỗi font chữ."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc. Các câu cú rời rạc và không có sự liên kết rõ ràng. Việc trích dẫn một đoạn văn bản rồi đột ngột kết thúc khiến người đọc khó hiểu ý nghĩa."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chỉ tập trung vào một phần nhỏ của văn bản gốc và bỏ qua nhiều ý chính quan trọng khác. Phần được tóm tắt không thể hiện được đầy đủ nội dung về các phép toán trên vector và ma trận trong MATLAB."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng kém. Nó không trung thực, thiếu mạch lạc và không liên quan đến nội dung chính của văn bản gốc. Cần cải thiện đáng kể bằng cách tóm tắt đầy đủ các ý chính, đảm bảo tính logic và rõ ràng trong trình bày."
            }
        }
    },
    {
        "Index": "00134",
        "Article": "Tín hiệu (signal) là một cơ chế trong hệ điều hành UNIX/Linux dùng để giao tiếp bất đồng bộ giữa các tiến trình hoặc giữa nhân hệ điều hành và tiến trình người dùng. Khi một sự kiện bất thường xảy ra như chia cho 0, lỗi bộ nhớ, người dùng nhấn Ctrl+C, hoặc tiến trình con kết thúc, hệ điều hành sẽ gửi một tín hiệu đến tiến trình liên quan. Mỗi tín hiệu có mã số và tên định danh, ví dụ SIGINT (ngắt từ bàn phím), SIGKILL (kết thúc cưỡng bức), SIGTERM (yêu cầu kết thúc), SIGCHLD (tiến trình con kết thúc). Khi nhận tín hiệu, tiến trình có thể xử lý theo mặc định, bỏ qua, hoặc định nghĩa một hàm xử lý tùy chỉnh (signal handler) thông qua lời gọi hệ thống signal() hoặc sigaction(). Một số tín hiệu như SIGKILL và SIGSTOP không thể bị chặn hoặc xử lý, do được hệ điều hành dùng để kiểm soát tiến trình tuyệt đối. Việc xử lý tín hiệu giúp tiến trình phản ứng linh hoạt với các sự kiện như thoát an toàn, ghi log, đóng kết nối mạng, giải phóng tài nguyên trước khi kết thúc. Ngoài ra, tín hiệu còn được dùng để đồng bộ hóa tiến trình, ví dụ tiến trình cha dùng SIGUSR1 để báo cho tiến trình con bắt đầu thực hiện công việc. Trong môi trường đa luồng, mỗi luồng có thể bị ảnh hưởng khác nhau bởi tín hiệu, tùy cách hệ điều hành định tuyến tín hiệu. Lập trình với tín hiệu đòi hỏi cẩn trọng để tránh điều kiện tranh chấp hoặc lỗi không xác định do xử lý bất đồng bộ. Hệ điều hành hiện đại hỗ trợ nhiều công cụ để giám sát và gửi tín hiệu như kill, pkill, killall, hoặc thư viện lập trình C chuẩn.",
        "Summary": "Tín hiệu (signal) là cơ chế trong hệ điều hành dùng để gửi thông báo bất đồng bộ đến tiến trình, thường để điều khiển hoặc thông báo sự kiện. Ví dụ, tín hiệu SIGKILL dùng để kết thúc tiến trình, SIGINT để ngắt tiến trình từ bàn phím. Tiến trình có thể xử lý tín hiệu thông qua trình xử lý (signal handler) hoặc bỏ qua. Cơ chế này giúp hệ điều hành kiểm soát hành vi tiến trình và phản ứng kịp thời với các sự kiện không mong muốn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn được liên kết chặt chẽ, tạo thành một dòng chảy thông tin logic và dễ hiểu. Cách trình bày rõ ràng, giúp người đọc nắm bắt ý chính một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ nội dung cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00135",
        "Article": "SGA đƣợc cấp phát khi tiến trình Oracle đƣợc kích hoạt và nó là một thành phần cơ bản của tiến trình Oracle. PGA đƣợc cấp phát khi máy chủ đƣợc kích hoạt. Các tiến trình ngầm là các tiến trình hỗ trợ ghi cơ sở dữ liệu, ghi log, giám sát hệ thống, giám sát tiến trình... Ngoài ra, hệ quản trị cơ sở dữ liệu Oracle còn có 1 tiến trình ngƣời dùng (User process) và 1 tiến trình máy chủ (Server process). Tiến trình ngƣời dùng đƣợc kích hoạt khi ngƣời dùng cơ sở dữ liệu tạo kết nối đến máy chủ Oracle và tiến trình máy chủ đƣợc kích hoạt và kết nối đến Oracle Instance khi ngƣời dùng thiết lập 1 phiên làm việc, nhƣ mô tả trên Hình 6.15. Hình 6.15. Mô hình người dùng kết nối đến Oracle Server 6.5.3.2. Các biện pháp bảo mật cơ sở dữ liệu Oracle Hình 6.16. Các biện pháp bảo mật cơ sở dữ liệu Oracle Tƣơng tự nhƣ các hệ quản trị cơ sở dữ liệu khác, Oracle cũng hỗ trợ hầu hết các biện pháp bảo mật truyền thống, bao gồm quản lý tài khoản ngƣời dùng, xác thực và trao quyền, vai trò và quản lý quyền truy nhập đến các đối tƣợng trong cơ sở dữ liệu. Ngoài ra, Oracle còn cung cấp một số biện pháp bảo mật nâng cao, nhƣ liệt kê trên Hình 6.16. Theo đó, các biện pháp bảo mật nâng cao đƣợc chia thành 3 nhóm: giám sát (Monitoring), điều khiển truy nhập (Access control), mã hóa và đặt mặt nạ (Encryption and Masking). Phần tiếp theo trình bày một số biện pháp bảo mật tiêu biểu thuộc 3 nhóm Hình 6.17 mô tả phƣơng thức làm việc của công nghệ mã hóa toàn bộ cơ sở dữ liệu (TDE) hỗ trợ bởi máy chủ Oracle. Theo đó, dữ liệu đƣợc mã hóa ở mức cơ sở dữ liệu, hoàn toàn trong suốt với ngƣời dùng.",
        "Summary": "Tiến trình ngƣời dùng đƣợc kích hoạt khi ngƣời dùng cơ sở dữ liệu tạo kết nối đến máy chủ Oracle và tiến trình máy chủ đƣợc kích hoạt và kết nối đến Oracle Instance khi ngƣời dùng thiết lập 1 phiên làm việc, nhƣ mô tả trên Hình 6. 15. Các biện pháp bảo mật cơ sở dữ liệu Oracle Tƣơng tự nhƣ các hệ quản trị cơ sở dữ liệu khác, Oracle cũng hỗ trợ hầu hết các biện pháp bảo mật truyền thống, bao gồm quản lý tài khoản ngƣời dùng, xác thực và trao quyền, vai trò và quản lý quyền truy nhập đến các đối tƣợng trong cơ sở dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt mạch lạc, các câu văn liên kết chặt chẽ với nhau và dễ hiểu. Các ý được trình bày một cách logic."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc. Tuy nhiên, có thể lược bỏ chi tiết 'nhƣ mô tả trên Hình 6.15' vì nó không thực sự cần thiết để hiểu ý chính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt, trung thực và mạch lạc. Tuy nhiên, để tăng tính liên quan, có thể lược bỏ một vài chi tiết nhỏ không quá quan trọng."
            }
        }
    },
    {
        "Index": "00136",
        "Article": "Quy trình xây dựng cơ sở dữ liệu quan hệ là một chuỗi các bước có hệ thống để tạo ra hệ thống hiệu quả, đáp ứng nhu cầu người dùng. Bước đầu tiên là khảo sát và phân tích yêu cầu, xác định thông tin cần lưu trữ và cách sử dụng. Ví dụ, trong quản lý sinh viên, ta cần bảng Sinh viên (MASV, HOTEN), Môn học (MAMH, TENMH) và Kết quả (MASV, MAMH, DIEMTHI), dựa trên phỏng vấn giảng viên, sinh viên và quản lý. Bước thứ hai là thiết kế khái niệm, thường dùng mô hình thực thể - kết hợp (ER Model) để biểu diễn thực thể (Sinh viên, Môn học) và mối quan hệ (Sinh viên học Môn học) bằng sơ đồ trực quan. Bước thứ ba là thiết kế logic, chuyển ER Model thành lược đồ quan hệ, chọn khóa chính như MASV và khóa ngoại như MASV trong Kết quả, đồng thời định nghĩa kiểu dữ liệu (MASV là chuỗi, DIEMTHI là số). Bước thứ tư là chuẩn hóa, áp dụng các dạng chuẩn (1NF, 2NF, 3NF) để loại bỏ dư thừa, như tách HOTEN khỏi Kết quả vì nó chỉ phụ thuộc MASV. Bước cuối cùng là triển khai vật lý, nhập dữ liệu vào hệ quản trị như Microsoft Access, tạo chỉ mục để tăng tốc truy vấn, và kiểm tra tính toàn vẹn (MASV trong Kết quả phải có trong Sinh viên). Quy trình này đòi hỏi sự tỉ mỉ, vì lỗi ở bước đầu (như bỏ sót thuộc tính) có thể dẫn đến hệ thống không tối ưu, khó mở rộng sau này, ví dụ thêm bảng Học bổng mà không sửa lại cấu trúc. Thành công của một CSDL phụ thuộc vào việc phối hợp giữa các bước và sự hiểu biết sâu sắc về nhu cầu thực tế.",
        "Summary": "Quy trình xây dựng cơ sở dữ liệu quan hệ gồm các bước: thu thập và phân tích yêu cầu, xây dựng mô hình thực thể-kết hợp (ER), chuyển đổi sang mô hình quan hệ, chuẩn hóa bảng và triển khai trên hệ quản trị. Mỗi bước đều quan trọng để đảm bảo hệ thống hoạt động hiệu quả, dễ bảo trì và mở rộng. Thiết kế đúng ngay từ đầu giúp tiết kiệm chi phí, giảm lỗi và đáp ứng tốt yêu cầu của người dùng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các bước trong quy trình được liệt kê theo đúng thứ tự và có sự liên kết chặt chẽ với nhau."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, lược bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất về quy trình xây dựng cơ sở dữ liệu quan hệ."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về quy trình xây dựng cơ sở dữ liệu quan hệ. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00137",
        "Article": "Các yêu cầu thiết kế LAN về mặt cấu trúc tương tự như thiết kế WAN, bao gồm: yêu cầu kỹ thuật, yêu cầu về hiệu năng, yêu cầu về ứng dụng, yêu cầu về quản lý mạng, yêu cầu về an ninh - an toàn mạng, cùng với các ràng buộc về tài chính, thời gian thực hiện, yêu cầu chính trị của dự án, xác định nguồn nhân lực và tài nguyên có thể tái sử dụng. Quá trình thiết kế mạng LAN bao gồm các bước sau: Phân tích yêu cầu, bao gồm xác định số lượng nút mạng (rất lớn trên 1000 nút, vừa trên 100 nút và nhỏ dưới 10 nút), từ đó lựa chọn phương thức phân cấp, kỹ thuật chuyển mạch và thiết bị phù hợp. Cần phân đoạn mạng dựa trên mô hình phòng ban để đảm bảo an ninh và chất lượng dịch vụ, đồng thời lựa chọn công nghệ đi cáp dựa trên mô hình topo và dự báo nhu cầu mở rộng trong tương lai. Lựa chọn phần cứng, bao gồm thiết bị, cáp, công nghệ kết nối phù hợp với yêu cầu kỹ thuật và kinh phí dự kiến, lựa chọn nhà cung cấp uy tín như Cisco, Nortel, 3COM, Intel... Lựa chọn phần mềm, bao gồm hệ điều hành (Unix, Linux, Windows) tùy theo nhu cầu xử lý giao dịch, thời gian thực và bảo mật; phần mềm quản trị cơ sở dữ liệu (Oracle, Informix, SQL, Lotus Notes...); phần mềm mạng như thư điện tử (Sendmail, PostOffice, Netscape...), Web server (Apache, IIS...); phần mềm bảo mật như tường lửa (PIX, Checkpoint, Netfilter...), chống virus (VirusWall, NAV...) và phần mềm chống đột nhập, quét lỗ hổng an ninh. Đánh giá khả năng, dựa trên thông tin từ các hãng uy tín, thử nghiệm trong phòng thí nghiệm và mô hình thử nghiệm. Tính toán giá thành, đảm bảo chi phí thấp nhưng đáp ứng các chỉ tiêu kỹ thuật, yêu cầu ứng dụng và khả năng mở rộng. Triển khai pilot, thực hiện trên quy mô nhỏ nhưng mô phỏng toàn bộ yêu cầu kỹ thuật và ứng dụng để đánh giá hiệu quả trước khi triển khai trên diện rộng.",
        "Summary": "Thiết kế mạng LAN yêu cầu xem xét các yếu tố kỹ thuật, hiệu năng, an ninh, quản lý mạng và tài chính. Quá trình thiết kế bao gồm phân tích yêu cầu, lựa chọn phần cứng, phần mềm phù hợp, đánh giá khả năng, tính toán chi phí và triển khai thử nghiệm trước khi áp dụng trên diện rộng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất về yêu cầu và quy trình thiết kế mạng LAN."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan ngắn gọn và chính xác về văn bản gốc. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00138",
        "Article": "Một kỹ thuật thường được sử dụng kết hợp với thuật toán đổi trang là sử dụng đệm trang (page-buffering). Hệ điều hành dành ra một số khung trống được kết nối thành danh sách liên kết gọi là các trang đệm. Khi có yêu cầu đổi trang, một trang bị đổi như bình thường nhưng nội dung trang này không bị xóa ngay khỏi bộ nhớ để nhường cho trang mới. Thay vào đó, khung chứa trang được đánh dấu là khung trống và thêm vào cuối danh sách trang đệm. Thay vì nạp vào khung chứa trang vừa bị đổi, trang mới sẽ được nạp vào khung đứng đầu trong danh sách trang đệm. Tới thời điểm thích hợp, hệ thống sẽ ghi nội dung các trang trong danh sách đệm ra đĩa. Kỹ thuật đệm trang cho phép cải tiến tốc độ do một số lý do sau: Thứ nhất, nếu trang bị đổi có nội dung cần ghi ra đĩa, hệ điều hành vẫn có thể nạp trang mới vào ngay, việc ghi ra đĩa sẽ được lùi lại tới một thời điểm muộn hơn. Thao tác ghi ra đĩa có thể thực hiện đồng thời với nhiều trang nằm trong danh sách được đánh dấu trống. Việc ghi nhiều trang đồng thời như vậy thường tiết kiệm thời gian hơn do thao tác ghi đĩa được tiến hành theo khối lớn. Thứ hai, trang bị đổi vẫn được giữ trong bộ nhớ một thời gian. Trong thời gian này, nếu có yêu cầu truy cập, trang sẽ được lấy ra từ danh sách đệm và sử dụng ngay mà không cần nạp lại từ đĩa. Vùng đệm khi đó đóng vai trò giống như bộ nhớ cache giúp giảm độ trễ trong quá trình truy xuất dữ liệu. Bên cạnh đó, đệm trang còn giúp hệ thống tận dụng tốt hơn các chu kỳ CPU và thiết bị I/O bằng cách tách biệt thời gian nạp trang và thời gian ghi đĩa, giúp hạn chế tình trạng hệ thống bị nghẽn do quá nhiều thao tác I/O diễn ra đồng thời. Do đó, việc sử dụng đệm trang là một giải pháp tối ưu giúp giảm số lần truy cập đĩa không cần thiết, tăng tốc độ xử lý và cải thiện hiệu suất hệ thống.",
        "Summary": "Kỹ thuật đệm trang (page-buffering) cải thiện hiệu suất hệ thống bằng cách giữ các trang bị đổi trong bộ nhớ và thêm vào danh sách đệm thay vì xóa chúng ngay lập tức. Khi cần ghi dữ liệu ra đĩa, hệ điều hành có thể thực hiện đồng thời việc ghi nhiều trang, tiết kiệm thời gian. Thêm vào đó, việc giữ trang trong bộ nhớ giúp giảm độ trễ và tăng tốc độ truy xuất, đồng thời tối ưu hóa chu kỳ CPU và thiết bị I/O.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào lợi ích của kỹ thuật đệm trang, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00139",
        "Article": "Việc sử dụng cú pháp tìm kiếm chính xác giúp bạn tìm thấy thông tin một cách hiệu quả hơn trên Google. Để tìm đúng cụm từ mong muốn, đặt nội dung tìm kiếm trong dấu nháy kép, ví dụ: \"hướng dẫn làm SEO web\". Nếu muốn loại trừ một từ khỏi kết quả tìm kiếm, thêm dấu - trước từ đó, ví dụ: inbound marketing -advertising. Dùng OR (viết hoa) để tìm kết quả chứa một trong hai từ khóa, ví dụ: inbound marketing OR advertising. Để tìm một trang có tất cả các từ khóa xuất hiện trong nội dung văn bản (không nhất thiết phải cạnh nhau), sử dụng allintext:, ví dụ: allintext:Quy trình SEO. Nếu muốn tìm một từ trong nội dung văn bản và một từ khác trong tiêu đề hoặc URL, hãy dùng intext:, ví dụ: neil diamond intext:red sox. Để tìm các trang có từ khóa trong tiêu đề, dùng allintitle:, ví dụ: allintitle:wine club, hoặc intitle: nếu muốn kết hợp từ trong tiêu đề và từ khác trong văn bản, ví dụ: flu shot intitle:advise. Nếu bạn muốn tìm các trang có từ khóa trong URL, hãy dùng allinurl:, ví dụ: allinurl:blog hubspot. Khi cần tìm kiếm một nội dung cụ thể trong một trang web, ngay cả khi trang đó không hỗ trợ tìm kiếm, bạn có thể sử dụng Google với cú pháp site:, ví dụ: site:seothetop.com \"tài liệu học seo\". Nếu muốn tìm các trang web có nội dung tương tự với một trang bạn đã biết, hãy dùng related:, ví dụ: related:lichngaytot.com. Ngoài ra, nếu bạn muốn tìm mọi trang web trích dẫn hoặc liên kết đến một trang cụ thể, sử dụng link:, ví dụ: link:buzzfeed.com. Bằng cách áp dụng các cú pháp trên, bạn có thể tối ưu hóa tìm kiếm trên Google và tìm thông tin một cách nhanh chóng, chính xác hơn",
        "Summary": "Sử dụng cú pháp tìm kiếm trên Google giúp tìm thông tin nhanh và chính xác hơn. Một số cú pháp quan trọng gồm đặt cụm từ trong dấu nháy kép để tìm chính xác, dùng dấu \"-\" để loại trừ từ khóa, \"OR\" để tìm một trong hai từ, \"allintitle:\", \"allintext:\", \"allinurl:\" để tìm từ khóa trong tiêu đề, nội dung hoặc URL. Ngoài ra, có thể dùng \"site:\" để tìm nội dung trong một trang web cụ thể hoặc \"related:\" để tìm các trang tương tự.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, giúp người đọc dễ dàng nắm bắt thông tin chính. Các cú pháp tìm kiếm được liệt kê một cách có hệ thống."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các cú pháp tìm kiếm quan trọng nhất trên Google, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin cốt lõi."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về các cú pháp tìm kiếm trên Google một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00140",
        "Article": "Nguyên nhân chủ quan - Sự cố do sai sót kỹ thuật trong khảo sát, thiết kế trạm, tuyến Sai sót kỹ thuật ở đây thuộc về các khâu khảo sát, thiết kế, hoạch định trạm tuyến. Đó là sự thiếu tỷ mỷ chính xác trong khảo sát, thiết kế tuyến, thiết kế nhà trạm, cơ sở hạ tầng, hệ thống nguồn điện, đặc điểm thời tiết khí hậu từng vùng, mạng cáp và hệ thống an toàn… Ngoài ra còn phải kể đến tính hợp lý trong để không vượt quá tính năng kỹ thuật của thiees bị. Chẳng hạn như cự ly đường cáp tối đa từ các bộ ghép kênh đến thuê bao xa là bao nhiêu thì đảm bảo. Đồng thời sai sót kỹ thuật còn có thể xảy ra ngay trong quá trình thử tuyến khi chưa lường hết được những biến động của thời tiết, địa hình, địa vật, nhất là đối với các tuyến triển khai dã chiến. - Sự cố do sai sót trong quá trình lắp đặt trạm tuyến Trước tiên phải kể đến nhứng sai sót kỹ thuật trong lắp đặt các cấu kiện ngoài trời và trên cột ăng ten lắp không đạt yêu cầu kỹ thuật, đương cáp bị gấp khúc, xoắn, gẫy, không chống thấm nước, không đấu tiếp đất cho các thiết bị. Những sai sót dễ gặp khi lắp đặt thiết bị trong phòng máy bao gồm: chọn vị trí lắp máy sai, như quá gần cửa sổ dễ bị mưa hắt, hoặc ngay ở nơi cửa gió của máy lạnh dễ bị đọng nước; sai sót thường gặp khác là việc đấu đất cho các thiết bị không đúng, dây tiếp đất vòng vèo qua nhiều thiết bị, không đấu trực tiếp vào bảng nối đất; lắp đặt các thiết bị chống sét không đảm bảo yêu cầu kỹ thuật, đấu nối các đường tín hiệu không đảm bảo tiếp xúc tốt. Ngoài ra còn có các sai sót trong việc đấu nối sử dụng nguồn điện trong trạm, hay bố trí sử dụng tần số không hợp lý, chưa thực hiện đo đạc các chỉ tiêu kỹ thuật khi thông tuyến và so sánh với thiết kế để kịp thời phát hiện và khắc phục triệt để sự cố trước khi quyết định đưa vào sử dụng. - Sự cố do sử dụng nguồn điện không đúng yêu cầu kỹ thuật Điển hình là việc sử dụng nguồn điện AC tù các tổ máy phát điện không đảm bảo điện áp, tần số, độ méo cho các thiết bị nguồn SWITCHING, UPS, có trạm đã cháy một lúc 2 bộ nguồn do sử dụng nguồn chất lượng thấp. Các thao tác cấp nguồn vaax còn sai sót như khi trạm mất điện vào giờ cao điểm ổn áp đang ở chế độ tăng áp, nếu không ngắt điện từ ổn áp vào thiết bị thì khi có điện trở lại vào giờ thấp điểm đầu ra ổn áp điện áp sẽ tăng vọt và phải có một thời gian trễ thì điện áp mới trở lại mức danh định, trong thời gian trễ đó thiết bị của chúng ta đã bị hỏng; hay như điện áp và tần số máy nổ chưa ổn định đã đóng cầu dao cấp điện cho thiết bị.",
        "Summary": "Các nguyên nhân chủ quan gây sự cố trạm tuyến bao gồm sai sót kỹ thuật trong khảo sát, thiết kế (ví dụ: thiếu chính xác trong khảo sát, thiết kế tuyến, trạm, hệ thống điện, mạng cáp), sai sót trong lắp đặt (ví dụ: lắp đặt cấu kiện ngoài trời không đạt chuẩn, đấu đất sai quy cách, đấu nối tín hiệu kém), và sử dụng nguồn điện không đúng yêu cầu kỹ thuật (ví dụ: điện áp không ổn định từ máy phát điện, thao tác cấp nguồn sai quy trình khi mất điện).",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Các ví dụ được đưa ra đều chính xác và phù hợp với nội dung gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, với sự liên kết chặt chẽ giữa các câu. Cách sử dụng từ ngữ dễ hiểu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Nó tập trung vào các nguyên nhân chủ quan gây sự cố trạm tuyến, là trọng tâm của đoạn văn. Các chi tiết được chọn lọc kỹ càng, loại bỏ những thông tin không cần thiết, giúp bản tóm tắt ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin chính xác và trình bày một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00141",
        "Article": "1.3.1.Java và ứng dụng ConsoleỨng dụng Console là ứng dụng nhập xuất ở chế độ văn bảntương tự như màn hình Console của hệ điều hành MS-DOS.Lọai chương trình ứng dụng này thích hợp với những ai bướcđầu làm quen với ngôn ngữ lập trình java.Các ứng dụng kiểu Console thường được dùng để minh họa cácví dụ cơ bản liên quan đến cú pháp ngôn ngữ, các thuật toán, vàcác chương trình ứng dụng không cần thiết đến giao diện ngườidùng đồ họa.class HelloWorld{ public static void main(String[] args)11{System.out.println(\"\\nHello World\");}}1.3.2.Java và ứng dụng AppletJava Applet là loại ứng dụng có thể nhúng và chạy trong trangweb của một trình duyệt web. Từ khi internet mới ra đời, JavaApplet cung cấp một khả năng lập trình mạnh mẽ cho các trangweb. Nhưng gần đây khi các chương trình duyệt web đã pháttriển với khả năng lập trình bằng VB Script, Java Script,HTML, DHTML, XML, … cùng với sự canh tranh khốc liệtcủa Microsoft và Sun đã làm cho Java Applet lu mờ. Và chođến bây giờ gần như các lập trình viên đều không còn “mặnmà” với Java Applet nữa. (trình duyệt IE đi kèm trong phiênbản Windows 2000 đã không còn mặc nhiên hỗ trợ thực thi mộtứng dụng Java Applet). Hình bên dưới minh họa một chươngtrình java applet thực thi trong một trang web.121.3.3.Java và phát triển ứng dụng Desktop dùng AWT vàJFCViệc phát triển các chương trình ứng dụng có giao diện ngườidùng đồ họa trực quan giống như những chương trình được viếtdùng ngôn ngữ lập trình VC++ hay Visual Basic đã được javagiải quyết bằng thư viện AWT và JFC. JFC là thư viện rấtphong phú và hỗ trợ mạnh mẽ hơn nhiều so với AWT. JFC giúpcho người lập trình có thể tạo ra một giao diện trực quan của bấtkỳ ứng dụng nào. Liên quan đến việc phát triển các ứng dụngcó giao diện người dùng đồ họa trực quan chúng ta sẽ tìm hiểuchi tiết trong chương 4.Minh họa thiết kế giao diện người dùng sử dụng JFC131.3.4.Java và phát triển ứng dụng WebJava hỗ trợ mạnh mẽ đối với việc phát triển các ứng dụng Webthông qua công nghệ J2EE (Java 2 Enterprise Edition). Côngnghệ J2EE hoàn toàn có thể tạo ra các ứng dụng Web một cáchhiệu quả không thua kém công nghệ .NET mà Microsft đangquảng cáo.Hiện nay có rất nhiều trang Web nổi tiếng ở Việt Nam cũngnhư khắp nơi trên thế giới được xây dựng và phát triển dựa trênnền công nghệ Java. Số ứng dụng Web được xây dựng dùngcông nghệ Java chắc chắn không ai có thể biết được con sốchính xác là bao nhiêu, nhưng chúng tôi đưa ra đây vài ví dụ đểthấy rằng công nghệ Java của Sun là một “đối thủ đáng gờm”của Microsoft.14http://java.sun.com/http://e-docs.bea.com/http://www.macromedia.com/software/jrun/http://tomcat.apache.org/index.htmlChắc không ít người trong chúng ta biết đến trang web thông tinnhà đất nổi tiếng ở TPHCM đó là: http://www.nhadat.com/.Ứng dụng Web này cũng được xây dựng dựa trên nền côngnghệ java.Bạn có thể tìm hiểu chi tiết hơn về công nghệ J2EE tạo địa chỉ:http://java.sun.com/j2ee/1.3.5.Java và phát triển các ứng dụng nhúngJava Sun đưa ra công nghệ J2ME (The Java 2 Platform, MicroEdition J2ME) hỗ trợ phát triển các chương trình, phần mềmnhúng. J2ME cung cấp một môi trường cho những chương trìnhứng dụng có thể chạy được trên các thiết bị cá nhân như: điệnthọai di động, máy tính bỏ túi PDA hay Palm, cũng như cácthiết bị nhúng khác.Bạn có thể tìm hiểu chi tiết hơn về công nghệ J2ME tại địa chỉ:http://java.sun.com/j2me/",
        "Summary": "Văn bản mô tả các ứng dụng của Java trong nhiều lĩnh vực lập trình. Java được sử dụng để phát triển ứng dụng console đơn giản, applet (hiện nay đã lỗi thời), ứng dụng desktop với AWT và JFC (Swing), và ứng dụng web thông qua J2EE. Ngoài ra, Java còn hỗ trợ phát triển ứng dụng nhúng với J2ME, cho phép chạy trên các thiết bị di động và thiết bị nhúng khác. Tóm lại, Java là một ngôn ngữ lập trình đa năng, được ứng dụng rộng rãi trong nhiều hệ thống và thiết bị khác nhau.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Tóm tắt tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo tính trọng tâm và giá trị của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được các ứng dụng đa dạng của Java trong các lĩnh vực lập trình khác nhau. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00142",
        "Article": "Windows là hệ điều hành hỗ trợ đa luồng, do vậy CPU được điều độ ở mức luồng. Trong các phiên bản đầu, tức là tới trước Win 95, điều độ là không phân phối lại. Các phiên bản từ Win 95 điều độ luồng dựa trên mức ưu tiên và có phân phối lại, tức là luồng có thể bị thu hồi CPU cả khi đang ở trong trạng thái chạy. Mỗi luồng trong Windows được gán một mức ưu tiên dùng cho điều độ. Có tất cả 32 mức ưu tiên nằm trong khoảng từ không (thấp nhất) tới 31 (cao nhất). Chỉ duy nhất một luồng có mức ưu tiên bằng không là luồng của hệ điều hành có nhiệm vụ xóa nội dung tất cả các trang nhớ trống về không và luồng này được thực hiện khi không có luồng nào khác có nhu cầu chạy. Windows xếp các luồng có cùng mức ưu tiên vào cùng một hàng đợi. Các luồng trong cùng hàng đợi được điều độ theo phương pháp quay vòng. Trước tiên, hệ thống phân phối CPU cho các luồng có mức ưu tiên cao nhất. Nếu không có luồng nào trong số đó sẵn sàng để chạy, Windows sẽ chuyển sang cấp CPU cho hàng đợi gồm các luồng với mức ưu tiên cao tiếp theo. Trong lúc một luồng đang chạy, nếu một luồng ở mức ưu tiên cao hơn có yêu cầu CPU, luồng đang chạy sẽ bị ngắt ngay, bất kể lượng tử thời gian của tiến trình đó đã hết chưa, để nhường CPU cho tiến trình có mức ưu tiên cao hơn mới xuất hiện. 32 mức ưu tiên được nhóm thành sáu nhóm, mỗi nhóm bao gồm một dải mức ưu tiên. Mức ưu tiên của luồng được xác định dựa trên hai thông tin: 1) luồng thuộc nhóm ưu tiên nào; và 2) độ ưu tiên của luồng so với trung bình của nhóm. Các nhóm ưu tiên. Windows xác định sáu nhóm ưu tiên như sau: IDLE_PRIORITY_CLASS , BELOW_NORMAL_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, ABOVE_NORMAL_PRIORITY_CLASS, HIGH_PRIORITY_CLASS, REALTIME_PRIORITY_CLASS. Có thể đặt nhóm ưu tiên cho luồng sử dụng lời gọi hệ thống SetPriorityClass, hoặc đặt bằng tay từ giao diện đồ họa của Task Manager. Theo mặc định, luồng thuộc nhóm ưu tiên NORMAL_PRIORITY_CLASS. Luồng có mức ưu tiên IDLE_PRIORITY_CLASS là luồng làm các công việc nền như screen saver. Các luồng không được khuyến cáo đặt mức ưu tiên ở mức REALTIME_PRIORITY_CLASS vì khi có luồng với mức ưu tiên như vậy chạy, các luồng khác sẽ không nhận được CPU để chạy, kể cả các luồng xử lý tín hiệu từ chuột, bàn phím. Mức ưu tiên trong nhóm. Mỗi nhóm bao gồm một số mức ưu tiên. Các luồng thuộc một nhóm ưu tiên có thể thay đổi mức ưu tiên cụ thể tùy vào mức ưu tiên tương đối trong nhóm. Các mức ưu tiên tương đối trong nhóm bao gồm: THREAD_PRIORITY_IDLE, THREAD_PRIORITY_LOWEST, THREAD_PRIORITY_BELOW_NORMAL, THREAD_PRIORITY_NORMAL ,THREAD_PRIORITY_ABOVE_NORMAL, THREAD_PRIORITY_HIGHEST, THREAD_PRIORITY_TIME_CRITICAL. Mức ưu tiên cụ thể của luồng được xác định bằng cách kết hợp mức ưu tiên cơ sở của nhóm với mức ưu tiên tương đối trong nhóm . Bên cạnh việc sử dụng mức ưu tiên, Windows còn phân biệt giữa các tiến trình đang được chọn, tức là tiến trình có cửa sổ nằm trên cùng, với các tiến trình còn lại. Tiến trình đang được chọn sẽ được tăng lượng tử thời gian lên khoảng 3 lần so với các tiến trình khác cùng mức ưu tiên và do vậy sẽ được nhận CPU trong khoảng thời gian dài hơn.",
        "Summary": "Windows là hệ điều hành đa luồng, điều độ CPU ở mức luồng dựa trên mức ưu tiên và có phân phối lại. Mỗi luồng có một mức ưu tiên từ 0 (thấp nhất) đến 31 (cao nhất), được xếp vào hàng đợi theo mức ưu tiên và điều độ theo phương pháp quay vòng. Hệ thống ưu tiên CPU cho luồng có mức ưu tiên cao nhất, và có thể ngắt luồng đang chạy nếu có luồng ưu tiên cao hơn yêu cầu. 32 mức ưu tiên được chia thành sáu nhóm (IDLE, BELOW_NORMAL, NORMAL, ABOVE_NORMAL, HIGH, REALTIME), có thể đặt thông qua SetPriorityClass hoặc Task Manager, mặc định là NORMAL. Các luồng trong cùng nhóm có thể thay đổi mức ưu tiên tương đối. Tiến trình đang được chọn (có cửa sổ trên cùng) được tăng lượng tử thời gian lên gấp 3 lần so với tiến trình khác cùng mức ưu tiên.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các khía cạnh quan trọng của việc điều độ luồng trong Windows."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày một cách hiệu quả những thông tin quan trọng nhất từ văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00143",
        "Article": "Bạn đã học được cách đơn giản để cho người truy cập trang web di chuyển từ trang này sang trang khác. Ví dụ, bạn có thể thêm các liên kết HTML (hoặc điều khiển HyperLink) trong trang của mình để cho phép người dùng lướt qua các trang web. Nếu muốn thực hiện chuyển hướng trang, bạn có thể gọi Response.Redirect() hoặc Server.Transfer() trong mã lệnh của mình. Tuy nhiên, trong các ứng dụng web chuyên nghiệp, yêu cầu chuyển hướng phức tạp hơn. Những ứng dụng này cần một hệ thống cho phép người dùng di chuyển giữa các trang một cách có tổ chức, mà không cần viết mã chuyển hướng thủ công trong từng trang. ASP.NET cung cấp một mô hình chuyển hướng dễ dàng để giúp người dùng lướt qua ứng dụng web của bạn. Trước khi có thể sử dụng mô hình này, bạn cần xác định hệ thống phân cấp của trang web, tức là cách tổ chức các trang thành các nhóm một cách logic. Bạn định nghĩa cấu trúc này trong một tệp chuyên dụng và kết nối thông tin đó để điều hướng với các điều khiển menu như TreeView và Menu. 3.2.1. Site Maps Thực hiện việc tạo một Website SimpleSiteMap: Để tạo trang Web.sitemap, bạn R-Click vào tên Project trong cửa sổ Solution Explorer, chọn Add New Item.., khi hộp thoại xuất hiện, chọn Site Map và nhấn nút Add. Nguyên tắc tạo trang SiteMap: 1. Một trang SiteMap bắt đầu bằng thẻ <siteMap>. 2. Mỗi trang web trong SiteMap được khai báo trong thẻ <siteMapNode>. 3. Một siteMapNode có thể chứa các siteMapNode con. 4. Không được phép lặp lại địa chỉ URL trong các siteMapNode. Tiếp theo, chọn mục Auto Format.., chọn một scheme hiển thị thích hợp trong danh sách và nhấn OK. Sau đó, chọn mục Edit Templates để thiết kế nội dung cho SiteMapPath. SiteMapPath có bốn thành phần thẻ bên trong: RootNodeTemplate, NodeTemplate, CurrentNodeTemplate, PathSeparatorTemplate. Nhập nội dung cho CurrentNodeTemplate để hiển thị thông tin từ các thẻ title và description. Trong đó, <%# Eval(\"title\") %> là một cách viết theo kiểu kết nối dữ liệu đơn giản (simple data binding), được sử dụng để lấy nội dung của title. Nhập nội dung cho RootNodeTemplate: Hiển thị chữ Root in đậm. Đầu tiên, chọn thuộc tính DataSource của TreeView và liên kết nó với SiteMapDataSource. Sau đó, nhấn vào mục Refresh Schema, nội dung TreeView sẽ được cập nhật theo SiteMapDataSource. Tiếp tục, nhấn vào mục Auto Format.. để định dạng hiển thị cho TreeView, rồi nhấn nút Apply để xác nhận việc thay đổi định dạng hiển thị. Các trang thành phần trong Web.sitemap chỉ chứa nội dung đơn giản để minh họa cho bài tập. Chúng sẽ được gọi khi được chọn trên TreeView, theo sự điều hướng của Web.sitemap. Phần mã lệnh trong MasterPage.master cung cấp phương thức GetDescriptionFromTitle(string Title), dùng để hiển thị thông tin của thẻ được chọn trên menu.",
        "Summary": "ASP.NET cung cấp hệ thống điều hướng có tổ chức bằng cách sử dụng SiteMap để xác định cấu trúc phân cấp của trang web trong tệp .sitemap. SiteMap được liên kết với các điều khiển như TreeView hoặc Menu để hiển thị và hỗ trợ người dùng di chuyển giữa các trang. Nội dung SiteMap có thể được định dạng và hiển thị thông qua các template và phương thức hỗ trợ.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Cách sử dụng SiteMap để điều hướng, liên kết với các điều khiển, và định dạng hiển thị được kết nối một cách trơn tru."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về cách ASP.NET cung cấp hệ thống điều hướng có tổ chức thông qua SiteMap, cách SiteMap được sử dụng với các điều khiển điều hướng, và cách nội dung SiteMap có thể được định dạng. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00144",
        "Article": "Isometric được hiểu là phương pháp dựa trên nguyên tắc toán học, dùng để mô tả hình ảnh ba chiều trong không gian hai chiều. Phương pháp mô tả hình ảnh Isometric này tương tự như một phép đo trục, gồm ba trục tọa độ giống nhau và thỏa mãn điều kiện góc giữa bất kỳ của hai trong số các góc xuất hiện, sẽ là 120 độ. [7]\n Isometric là không gian đồi hỏi cần độ chính xác cao để tạo được hiệu quả tốt nhất. Chính vì vậy, để sở hữu bản vẽ Isometric có độ chính xác cao, thì việc đầu tiên cần xác định là hình vẽ khối lập phương với hai cạnh dài và tâm nằm ở gốc. Cách tính toán cụ thể bạn có thể tham khảo theo các bước sau: tính độ dài của đường thăng từ tâm của nó đến giữa bất kỳ cạnh nào là √2 bằng định lý Pythagoras; xoay khối lập phương 45 ° trên trục x, điểm (1, 1, 1) do đó sẽ trở thành (1, 0, √2). Việc luân chuyển thứ hai với mục đích mang lại cùng một điểm dương trục z và bởi vậy cần phải thực hiện một vòng quay của giá trị tương đương với arctangent của 1/√2 đó là khoảng 35,264°.\n Isometric cho người xem nhìn nhận nhiều góc nhìn đa chiều, có thể dễ dàng thấy mặt bên và mặt trên của thiết kế một cách rõ ràng và chi tiết. Isometric cũng tạo dựng được một không gian ba chiều có tỷ lệ hoàn hảo. Chính về đặc điểm này, Isometric tạo ra được sự thảo mãn thị giác cao cho người xem, và đang được ứng dụng phổ biến trong những thiết kế hiện nay.\n Để có thể ứng dụng hiệu quả và dễ dàng không gian Isometric trong thiết kế, hiện nay, nhiều công cụ đã được sử dụng hỗ trợ để hỗ trợ cho việc xây dựng không gian Isometric bao gồm: lưới Isometric và công cụ Isometric trên phần mềm thiết kế của Adobe (Adobe Illustrator).",
        "Summary": "Isometric là phương pháp toán học mô tả hình ảnh ba chiều trên không gian hai chiều, sử dụng ba trục tọa độ đồng đều với góc 120 độ giữa các trục. Để tạo bản vẽ Isometric chính xác, cần xác định khối lập phương và thực hiện các phép xoay cụ thể. Ưu điểm của Isometric là khả năng hiển thị nhiều góc nhìn và tạo ra không gian ba chiều có tỷ lệ hoàn hảo, mang lại sự thỏa mãn thị giác cao. Hiện nay, có nhiều công cụ hỗ trợ thiết kế Isometric như lưới Isometric và công cụ Isometric trên Adobe Illustrator.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất về định nghĩa, cách tạo, ưu điểm và công cụ hỗ trợ của Isometric."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ và chính xác về văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00145",
        "Article": "Phân khúc khách hàng Thành tố Phân khúc khách hàng xác định những tập hợp cá nhân hay tổ chức khác nhau mà doanh nghiệp tiếp cận và phục vụ. Khách hàng là trọng tâm của mọi mô hình kinh doanh. Không công ty nào có thể tồn tại lâu dài mà không có khách hàng (nguồn sản sinh lợi nhuận). Để phục vụ khách hàng tốt hơn, một công ty có thể phân chia phân khúc khách hàng dựa vào các nhu cầu của khách hàng và các sản phẩm/dịch vụ của doanh nghiệp cung cấp. Một số thị trường doanh nghiệp có thể hướng đến như: - Thị trường đại chúng (mass market): Đây là thị trường có lượng khách hàng lớn nhất. Tuy nhiên khi doanh nghiệp quyết định cung cấp sản phẩm cung cấp cho thị trường này, họ sẽ gặp rất nhiều khó khăn vì đối thủ cạnh tranh với họ cũng nhiều không kém. Chỉ những doanh nghiệp sở hữu những sản phẩm cực kỳ chất lượng mới có thể tồn tại được. - Thị trường hỗn hợp (multi-sided market): Một thị trường bao gồm nhiều đặc điểm của các thị trường khác. Nó có thể phục vụ các khách hàng có mối liên kết với nhau. - Thị trường ngách (niche market): Là một phân khúc khách hàng đặc biệt mà chưa được nhiều doanh nghiệp hướng tới. Với phân đoạn thị trường nhỏ và những khách hàng riêng biệt, vì thế khi chọn phân khúc này, doanh nghiệp không phải tốn quá nhiều nguồn lực, chỉ cần tập trung tối đa cho nhóm khách hàng đã chọn. - Thị trường đa dạng (diversify): Một phân khúc mà mang lại rất nhiều khó khăn cho doanh nghiệp. Khi chọn phân khúc thị trường này, bạn phải liên tục thay đổi để có thể đáp ứng được nhu cầu của khách hàng. Tuy nhiên, lợi thế là nếu bạn làm tốt, bạn sẽ làm chủ cuộc chơi vì có rất ít đối thủ cạnh tranh cùng phân khúc với bạn. - Thị trường phân khúc (segmented): Các doanh nghiệp sử dụng hình thức này để phân nhỏ thị trường mà họ hướng tới. Thông thường đây là phương pháp được các doanh nghiệp “trẻ” sử dụng để có thể khai thác tối đa lượng khách hàng tiềm năng. Kênh phân phối Có thể hiểu Kênh phân phối là cầu nối giữa khách hàng và doanh nghiệp. Qua kênh này, khách hàng có thể tiếp nhận được các giá trị mà doanh nghiệp muốn truyền tải. Dựa vào khách hàng mục tiêu mà doanh nghiệp có thể lựa chọn những kênh phù hợp. Có 2 loại kênh thông dụng: - Kênh thuộc quyền sở hữu của doanh nghiệp: Những kênh này do chính doanh nghiệp tạo ra hoặc đã được mua lại. - Kênh đối tác: Doanh nghiệp sẽ không có toàn bộ quyền để quyết định hoạt động trên kênh này. Tất cả sẽ phụ thuộc vào những chính sách mà các đối tác và doanh nghiệp cùng thống nhất. Việc lựa chọn kênh phụ thuộc rất nhiều vào nguồn lực tài chính của doanh nghiệp. Có thể lựa chọn 1 trong 2 hoặc cả 2 tùy vào thực trạng. Một số ví dụ về các kênh: Mạng xã hội, Thư điện tử (email marketing), Internet SEM (Tiếp thị công cụ tìm kiếm), SEO (Tối ưu hóa công cụ tìm kiếm), Digital Marketing, Viral Marketing, Bán hàng và khuyến mãi hoa hồng, Chi nhánh, cửa hàng, Nền tảng hiện có, PR quảng cáo, Triển lãm thương mại, Content Marketing, Xây dựng cộng đồng…",
        "Summary": "Phân khúc khách hàng là yếu tố then chốt trong mô hình kinh doanh, xác định các nhóm khách hàng khác nhau mà doanh nghiệp hướng tới. Các loại thị trường bao gồm thị trường đại chúng, hỗn hợp, ngách, đa dạng và phân khúc, mỗi loại có đặc điểm và thách thức riêng. Kênh phân phối là cầu nối giữa doanh nghiệp và khách hàng, có thể thuộc sở hữu của doanh nghiệp hoặc thông qua đối tác, và việc lựa chọn kênh phụ thuộc vào nguồn lực tài chính cũng như mục tiêu tiếp cận khách hàng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc dễ dàng nắm bắt được nội dung chính mà không gặp khó khăn."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa phân khúc khách hàng, các loại thị trường khác nhau và vai trò của kênh phân phối. Các chi tiết không quan trọng đã được loại bỏ, giúp bản tóm tắt ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00146",
        "Article": "Nhờ quản lý tƣơng tác, quản trị tri thức và nội dung, Inbenta giúp cải thiện trải nghiệm của khách hàng, cho phép khớp truy vấn tìm kiếm ngữ nghĩa bằng ngôn ngữ tự nhiên của ngƣời dùng, có cấu trúc và không có cấu trúc, để sinh câu trả lời có cấu trúc. Nhóm khách hàng lớn bao gồm Groupon, Ticketmaster, Schlage, Blurb CogniCor: CogniCor Technologies là nhà cung cấp nền tảng phần mềm dịch vụ khách hàng hỗ trợ AI cho doanh nghiệp. Nền tảng chatbot hỗ trợ AI nhận thức của CogniCor cho phép các doanh nghiệp xây dựng các chatbot cao cấp, không cần viết kịch bản cho tất cả các luồng công việc. CogniCor cung cấp các tính năng thông minh trong nhập tài liệu, tích hợp quy trinh nghiệp vụ và hỗ trợ giao dịch của khách hàng. Sherpa: Công nghệ của Sherpa đƣợc thiết kế dành cho các sản phẩm và khám phá các mô hình kinh doanh mới của các nhà sản xuất sản phẩm tiêu dùng nhƣ ô tô, tai nghe thông minh, loa gia đình, thiết bị gia dụng và phụ kiện điện tử, dựa trên các công nghệ dịch vụ kỹ thuật số thông minh. Thành công của Sherpa đƣợc chứng minh khi đƣợc cài đặt sẵn trên điện thoại thông minh của tập đoàn Samsung từ năm 2016 và có sản phẩm trên ô tô của tập đoàn Porsche. Các công nghệ TTNT khác Geoblink: cung cấp giải pháp dịch vụ thông minh ứng dụng dựa trên vị trí cho các công ty trong lĩnh vực bán lẻ, bất động sản khi đƣa ra quyết định và thiết lập chiến lƣợc kinh doanh. Geoblink kết hợp các kỹ thuật phân tích nâng cao truyền thống và phi truyền thống trên dữ liệu lớn, cùng với giao diện ngƣời dùng dựa trên bản đồ phong phú để hiển thị nhiều loại thống kê một cách đơn giản, dễ sử dụng và dễ hiểu. Graphext : Graphext cung cấp giải pháp quy trình làm việc end-to-end, làm giàu và tiền xử lý dữ liệu, khai phá và phân tích dữ liệu, tạo lập báo cáo chuyên sâu. Graphext đƣa ra các công nghệ phân tích dữ liệu vƣợt trội so với các phƣơng pháp truyền thống, dựa trên khai phá và phân tích dữ liệu nhanh và dễ thực hiện cho tất cả mọi ngƣời.",
        "Summary": "Nhờ quản lý tƣơng tác, quản trị tri thức và nội dung, Inbenta giúp cải thiện trải nghiệm của khách hàng, cho phép khớp truy vấn tìm kiếm ngữ nghĩa bằng ngôn ngữ tự nhiên của ngƣời dùng, có cấu trúc và không có cấu trúc, để sinh câu trả lời có cấu trúc. Nhóm khách hàng lớn bao gồm Groupon, Ticketmaster, Schlage, Blurb CogniCor CogniCor Technologies là nhà cung cấp nền tảng phần mềm dịch vụ khách hàng hỗ trợ AI cho doanh nghiệp. CogniCor cung cấp các tính năng thông minh trong nhập tài liệu, tích hợp quy trinh nghiệp vụ và hỗ trợ giao dịch của khách hàng. Các công nghệ TTNT khác Geoblink cung cấp giải pháp dịch vụ thông minh ứng dụng dựa trên vị trí cho các công ty trong lĩnh vực bán lẻ, bất động sản khi đƣa ra quyết định và thiết lập chiến lƣợc kinh doanh.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các ý được trình bày theo thứ tự xuất hiện trong văn bản gốc. Tuy nhiên, có thể cải thiện bằng cách thêm các từ nối để tăng tính liên kết giữa các đoạn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào việc giới thiệu các công ty và giải pháp công nghệ mà họ cung cấp. Tuy nhiên, việc lược bỏ thông tin về Sherpa có thể làm giảm tính đầy đủ của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và liên quan. Tuy nhiên, có thể cải thiện bằng cách tăng tính mạch lạc và cân nhắc việc giữ lại thông tin về Sherpa để đảm bảo tính đầy đủ."
            }
        }
    },
    {
        "Index": "00147",
        "Article": "Vào cuối những năm 1960, IBM bắt đầu phát triển một thuật toán mã hóa có tên Lucifer, được lãnh đạo bởi Horst Feistel. Ban đầu, Lucifer sử dụng khối dữ liệu 64 bit và khóa 128 bit, nhằm đảm bảo độ bảo mật cao. Tuy nhiên, khi được phát triển để trở thành một mã hóa thương mại, các yếu tố như tốc độ xử lý và khả năng triển khai thực tế cần được cân nhắc. Đến năm 1973, NBS (Văn phòng Chuẩn Quốc gia Hoa Kỳ) kêu gọi đề xuất một tiêu chuẩn mã hóa quốc gia, nhằm tạo ra một phương pháp bảo mật thống nhất cho chính phủ và các tổ chức quan trọng. IBM đã đề xuất một phiên bản sửa đổi của Lucifer, sau này trở thành DES (Data Encryption Standard). Một trong những điểm gây tranh cãi nhất về DES là độ dài khóa. Ban đầu, nhiều chuyên gia đề xuất sử dụng khóa 128 bit để đảm bảo tính bảo mật cao hơn. Tuy nhiên, để tối ưu hóa tốc độ xử lý và phù hợp với tiêu chuẩn phần cứng thời đó, khóa được rút ngắn xuống còn 56 bit. Điều này dẫn đến các cuộc tranh luận về mức độ an toàn và khả năng chống thám mã của DES. Do chuẩn của DES được công khai, nhiều nhà nghiên cứu đã tham gia phân tích và đánh giá thuật toán. Các nghiên cứu chứng minh rằng thiết kế của DES, với 16 vòng lặp và các phép thế, hoán vị theo mô hình Feistel, đủ mạnh để chống lại hầu hết các loại tấn công mật mã học thời bấy giờ. Nhờ đó, DES nhanh chóng trở thành thuật toán mã hóa đối xứng được sử dụng rộng rãi, đặc biệt trong lĩnh vực tài chính, nơi yêu cầu bảo mật cao trong các giao dịch và truyền dữ liệu. Mặc dù sau này bị thay thế bởi các thuật toán mạnh hơn như 3DES và AES do tiến bộ công nghệ làm giảm khả năng chống lại tấn công brute-force, DES vẫn là một cột mốc quan trọng trong lịch sử mật mã hiện đại.",
        "Summary": "Cuối những năm 1960, IBM phát triển thuật toán mã hóa Lucifer (khóa 128 bit, khối 64 bit). Sau đó, IBM đề xuất phiên bản sửa đổi cho tiêu chuẩn mã hóa quốc gia NBS năm 1973, trở thành DES. Để tối ưu tốc độ, độ dài khóa DES giảm xuống 56 bit, gây tranh cãi về độ an toàn. Tuy nhiên, thiết kế 16 vòng lặp theo mô hình Feistel của DES được chứng minh đủ mạnh để chống lại các tấn công mật mã học thời đó, giúp DES trở nên phổ biến, đặc biệt trong lĩnh vực tài chính, trước khi bị thay thế bởi các thuật toán mạnh hơn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày theo trình tự thời gian và logic, giúp người đọc dễ dàng nắm bắt được quá trình phát triển và tầm quan trọng của DES. Các câu liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin liền mạch."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào quá trình phát triển, đặc điểm kỹ thuật quan trọng, và tầm ảnh hưởng của DES."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ và chính xác về quá trình phát triển và tầm quan trọng của thuật toán DES. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00148",
        "Article": "Phân tích rủi ro trong phát triển hệ thống thông tin là quá trình xác định, đánh giá và đề xuất giải pháp ứng phó với những yếu tố có thể ảnh hưởng tiêu cực đến tiến độ, chất lượng hoặc chi phí dự án. Rủi ro có thể phát sinh từ nhiều nguồn: thay đổi yêu cầu nghiệp vụ, thiếu kinh nghiệm đội ngũ phát triển, công nghệ mới chưa ổn định, lỗi giao tiếp giữa các bên liên quan, hoặc phụ thuộc vào nhà cung cấp bên ngoài. Quá trình phân tích rủi ro bắt đầu từ việc nhận diện rủi ro (risk identification), phân tích xác suất xảy ra và mức độ tác động (impact), sau đó phân loại mức ưu tiên để lên kế hoạch ứng phó. Các công cụ phổ biến như ma trận rủi ro (risk matrix), biểu đồ Pareto, phân tích cây sai hỏng (FTA), hoặc phương pháp Monte Carlo được sử dụng để trực quan hóa và định lượng rủi ro. Một phần quan trọng trong phân tích rủi ro là đánh giá rủi ro còn lại (residual risk) sau khi áp dụng biện pháp xử lý. Các chiến lược ứng phó bao gồm: tránh rủi ro (risk avoidance), giảm thiểu rủi ro (risk mitigation), chuyển giao rủi ro (risk transfer), và chấp nhận rủi ro (risk acceptance). Phân tích rủi ro nên được thực hiện định kỳ trong suốt vòng đời dự án vì rủi ro có thể thay đổi theo thời gian và theo các giai đoạn khác nhau. Ngoài ra, việc ghi chép rủi ro trong sổ đăng ký rủi ro (risk register) giúp theo dõi và cập nhật liên tục. Một quản lý rủi ro hiệu quả không chỉ bảo vệ dự án khỏi thất bại mà còn giúp xây dựng một môi trường phát triển chủ động, phản ứng nhanh và có chiến lược ứng phó phù hợp với bối cảnh thực tế. Điều này đặc biệt quan trọng khi các hệ thống ngày càng phức tạp và tích hợp sâu với nhiều yếu tố bên ngoài.",
        "Summary": "Phân tích rủi ro trong phát triển hệ thống giúp nhận diện, đánh giá và quản lý các yếu tố có thể ảnh hưởng tiêu cực đến tiến độ, chất lượng hoặc chi phí dự án. Các rủi ro có thể đến từ công nghệ, nhân sự, yêu cầu thay đổi hoặc môi trường vận hành. Việc xác định rủi ro sớm giúp đưa ra phương án ứng phó, giảm thiểu thiệt hại và tăng tính linh hoạt cho dự án. Đây là hoạt động quan trọng giúp đảm bảo dự án hệ thống được thực hiện đúng hướng, đúng thời hạn và đáp ứng yêu cầu của tổ chức.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Ý chính được trình bày rõ ràng, không gây khó khăn cho người đọc trong việc nắm bắt nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Bản tóm tắt tập trung vào định nghĩa, nguồn gốc và tầm quan trọng của phân tích rủi ro trong phát triển hệ thống thông tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt. Đảm bảo tính trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00149",
        "Article": "Trong hệ thống mạng, nhiều hoạt động thường xảy ra cùng một lúc như trong một thể thống nhất và những tiến trình riêng lẻ thực thi các chức năng như một phần của hệ thống. Các hệ thống này gọi là các hệ thống tương tranh (concurrent system) hay đồng thời. Mặc dù phát triển hệ thống sẽ dễ dàng hơn nếu xác lập được một hàng đợi có thứ tự dựa vào tất cả người dùng và các tiến trình. Tuy nhiên, trong thực tế chúng ta phải biến hỗn độn này thành thứ tự bằng nỗ lực lập trình của mình. Tính toán tương tranh xem xét một số vấn đề: • Làm sao đảm bảo được rằng thông tin được cập nhật đầy đủ trước khi có người thao tác trên cập nhật đó? Ví dụ, dừng mọi truy nhập vào đăng ký môn học cho tới khi tất cả các chi tiết môn học đã được thêm vào. • Làm sao đảm bảo được rằng thông tin không được cập nhật trong khi nó đang được đọc? Ví dụ, không cập nhật môn học trong khi nó đang được bạn đọc xem. Việc giải quyết các vấn đề này sẽ được xem xét ở hai mức độ khác nhau. Ở mức thấp, các giao dịch cơ sở dữ liệu và điều khiển luồng được sử dụng để bảo vệ dữ liệu bên trong các tiến trình riêng lẻ. Ở mức cao, chúng ta cần sử dụng các quy tắc của hệ thống và quy tắc nghiệp vụ để điều khiển hoạt động tương tranh. Cách dễ dàng nhất để xử lý tương tranh là thêm ràng buộc vào hệ thống hay đưa thêm vào quy tắc nghiệp vụ. Để hiểu rõ hơn về thêm ràng buộc hệ thống, ta hãy xem ví dụ về Hệ quản lý học theo tín chỉ. Thay vì cố cập nhật môn học trong khi sinh viên đang xem, chúng ta có thể cập nhật trong một cơ sở dữ liệu riêng và chuyển lại sau đó. Cách làm này có nghĩa là người sử dụng truy nhập Internet chỉ được phép đọc thôi và điều này sẽ giúp chúng ta dễ dàng viết code hơn. Người ta cũng có thể sử dụng các quy tắc nghiệp vụ để giúp việc phát triển thuận lợi hơn. Để tránh điều này, chúng ta có thể đưa ra thêm quy tắc nghiệp vụ như sau: khi một nhân viên truy vấn số vé còn lại, nếu chỉ còn một vé, nó tạm thời được giữ cho tới khi nhân viên hủy bỏ yêu cầu hoặc thời hạn đặt vé đã hết (ví dụ, việc đặt vé tạm thời được phép kéo dài 10 giây nếu nhân viên không hủy bỏ nó trước). Với quy tắc nghiệp vụ mới này, chúng ta có thể đảm bảo rằng chỉ khách hàng đầu tiên đưa ra yêu cầu tới máy chủ mới mua được vé (máy chủ có thể tích hợp truy vấn và lưu trữ bên trong một dịch vụ nghiệp vụ đơn). Giả sự việc đặt vé cho An thành công. Nhân viên đang phục vụ An có 10 giây để yêu cầu anh ta chi trả cho vé đã giữ, hoặc nhân viên có thể hủy bỏ trong thời gian đó nếu An thay đổi ý định. Nhân viên cũng sẽ hủy bỏ nếu phương thức chi trả của An có lỗi, đó là một lý do cho việc có giữ tạm thời cho người đầu tiên. Ban lúc này nghĩ rằng vé đã được bán hết trước khi cô ấy tới cửa hàng đặt vé, vì thế cô ấy không có lý do gì để tức giận với nhà cung cấp. Nếu cuối cùng An không mua vé và sau đó Ban biết rằng vé chưa bán hết thì cô ấy có thể chỉ đơn giản nghĩ rằng “Ai đó đã hủy bỏ”.",
        "Summary": "Trong hệ thống mạng tương tranh, nhiều tiến trình xảy ra đồng thời. Để đảm bảo tính toàn vẹn dữ liệu và tránh xung đột, cần giải quyết vấn đề cập nhật và truy cập thông tin ở cả mức thấp (giao dịch cơ sở dữ liệu, điều khiển luồng) và mức cao (quy tắc hệ thống, quy tắc nghiệp vụ). Một cách tiếp cận đơn giản là thêm ràng buộc hệ thống hoặc quy tắc nghiệp vụ. Ví dụ, cập nhật thông tin môn học trong cơ sở dữ liệu riêng rồi chuyển lại thay vì cập nhật trực tiếp khi sinh viên đang xem. Hoặc, khi truy vấn số vé còn lại, hệ thống có thể tạm giữ vé đó trong một khoảng thời gian ngắn để người đầu tiên yêu cầu có cơ hội mua vé.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, giúp người đọc dễ dàng nắm bắt được nội dung chính của văn bản gốc. Các câu liên kết với nhau một cách trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về hệ thống tương tranh, các vấn đề liên quan đến cập nhật và truy cập dữ liệu, và các giải pháp như thêm ràng buộc hệ thống hoặc quy tắc nghiệp vụ. Các ví dụ được đưa ra minh họa rõ ràng cho các giải pháp này."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00150",
        "Article": "Hệ thống cáp được chia thành 02 phần, mỗi phần phụ trách cung cấp truy nhập cho các máy tính nằm trong một nửa toà nhà. Do các switch trong một closet đặt cùng với switch phân phối tại Trung tâm điều hành mạng tầng 3 và các switch trong closet còn lại đặt trong một phòng đặt thiết bị trên cùng tầng 3 nên các cáp nối uplink từ các switch trong closet thứ hai sang switch phân phối sử dụng cáp UTP 25 đôi, còn các cáp uplink từ các switch trong closet 1 do nằm cùng với switch phân phối sẽ là cáp nhảy 4 đôi. Tại các phòng đặt các thiết bị switch sẽ có các patch panel AMP với 24 cổng RJ-45/1 patch panel để tập trung đấu nối cho cáp mạng. Cáp UTP nối giữa máy tính và switch truy cập là cáp 4 đôi kéo thẳng từ các patch panel AMP tại một trong hai phòng đặt thiết bị switch đến các outlet riêng rẽ gắn trên tường gần nơi đặt máy tính của người sử dụng. Do dây cáp có 4 đôi nên có thể sử dụng 2 đôi thừa làm dây dự phòng. Mạng máy tính thư viện là mạng máy tính dùng riêng, do vậy sẽ được đánh địa chỉ IP trong dải địa chỉ IP dùng cho mạng dùng riêng quy định tại RFC1918 (bao gồm các địa chỉ từ 10.0.0.0 đến 10.255.255.255, 172.16.0.0 đến 172.31.255.255 và địa chỉ 192.168.0.0 đến 192.168.255.255). Số lượng máy tính cho một segment mạng đông nhất được tính bằng một phần tư số lượng máy tính dự tính sẽ có trong toàn nhà (khoảng vài chục máy tính), do đó có thể gán cho hai segment máy tính bằng các phân lớp class C địa chỉ IP từ 192.168.0.0 đến 192.168.255.0. Hệ thống các máy chủ sẽ nằm trong phân mạng riêng và có địa chỉ IP gán trong phân lớp địa chỉ 172.18.0.0. Để truy cập Internet, một số máy chủ cần có tính năng che dấu địa chỉ như Firewall hay Proxy và các máy chủ này cần có địa chỉ IP thật. Các máy tính bên trong mạng sử dụng địa chỉ của các máy chủ khi kết nối ra Internet, và nếu các máy chủ cần cung cấp thông tin cho người dùng Internet thì cần phải đánh lại địa chỉ IP do IANA cung cấp. Để kết nối với các phân mạng máy tính của trường và mạng quốc gia, cần tuân thủ quy định đánh địa chỉ chặt chẽ để tránh trùng vùng địa chỉ mạng dùng riêng, có thể sử dụng kỹ thuật NAT để tránh xung đột địa chỉ khi kết nối hai mạng. Để thuận tiện cho công tác quản trị hệ thống, các thiết bị switch hỗ trợ DHCP kết hợp với máy chủ DHCP sẽ giúp cấp phát địa chỉ IP cho các máy tính trạm trong tòa nhà một cách tự động và tin cậy.",
        "Summary": "Hệ thống cáp mạng được chia thành hai phần, mỗi phần phục vụ một nửa tòa nhà, với các switch kết nối qua cáp UTP 25 đôi hoặc cáp nhảy 4 đôi tùy theo vị trí. Mạng máy tính thư viện sử dụng địa chỉ IP trong dải mạng riêng theo RFC1918, trong khi hệ thống máy chủ được gán địa chỉ trong phân lớp 172.18.0.0 và cần có cơ chế che giấu địa chỉ để truy cập Internet. Để đảm bảo quản trị hiệu quả, switch hỗ trợ DHCP cùng máy chủ DHCP sẽ tự động cấp phát địa chỉ IP cho các máy tính trong tòa nhà.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất về hệ thống cáp mạng, địa chỉ IP và quản trị mạng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00151",
        "Article": "RAID (Redundant Array of Independent Disks) là một phương pháp kết hợp nhiều ổ đĩa cứng vật lý thành một hệ thống lưu trữ logic nhằm cải thiện hiệu suất, độ tin cậy hoặc cả hai, tùy thuộc vào cấu hình của hệ thống. RAID có thể được triển khai thông qua phần cứng với một card RAID chuyên dụng hoặc thông qua phần mềm trong hệ điều hành. Có bốn cấu hình RAID phổ biến, mỗi cấu hình mang lại các lợi ích và hạn chế khác nhau, phù hợp với các nhu cầu sử dụng khác nhau. RAID 0 phân chia dữ liệu thành các đoạn nhỏ và phân phối trên các ổ đĩa khác nhau, giúp cải thiện tốc độ đọc và ghi dữ liệu nhưng không có tính năng dự phòng, khiến dữ liệu có thể mất nếu ổ đĩa hỏng. RAID 1 sao chép dữ liệu đồng thời trên hai ổ đĩa khác nhau, giúp bảo vệ dữ liệu nhưng không cải thiện hiệu suất nhiều vì phải sao chép đồng thời. RAID 5 phân tán dữ liệu và thông tin kiểm tra (parity) trên nhiều ổ đĩa, cung cấp tính năng dự phòng cao, giúp phục hồi dữ liệu nếu ổ đĩa hỏng nhưng yêu cầu ít nhất ba ổ đĩa vật lý. RAID 10 kết hợp RAID 1 và RAID 0, cung cấp cả hiệu suất và tính bảo mật cao, nhưng yêu cầu số lượng ổ đĩa gấp đôi so với các cấu hình khác. Mỗi loại RAID có những ưu điểm và nhược điểm riêng, tùy vào yêu cầu về hiệu suất, độ tin cậy và khả năng bảo vệ dữ liệu của hệ thống mà người quản trị có thể lựa chọn cấu hình phù hợp. Việc chọn đúng cấu hình RAID sẽ giúp tối ưu hóa hiệu suất và bảo mật dữ liệu của hệ thống lưu trữ.",
        "Summary": "RAID (Redundant Array of Independent Disks) là phương pháp kết hợp nhiều ổ đĩa cứng vật lý thành một hệ thống lưu trữ logic để cải thiện hiệu suất và/hoặc độ tin cậy. Các cấu hình RAID phổ biến bao gồm: RAID 0 (tăng tốc độ, không dự phòng), RAID 1 (sao chép dữ liệu, bảo vệ dữ liệu), RAID 5 (phân tán dữ liệu và parity, dự phòng cao, cần ít nhất 3 ổ đĩa), và RAID 10 (kết hợp hiệu suất và bảo mật cao, cần nhiều ổ đĩa). Lựa chọn cấu hình RAID phù hợp phụ thuộc vào yêu cầu về hiệu suất, độ tin cậy và khả năng bảo vệ dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa RAID, các cấu hình phổ biến và yếu tố lựa chọn cấu hình, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày các ý chính một cách hiệu quả, giúp người đọc nhanh chóng nắm bắt được nội dung cốt lõi của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00152",
        "Article": "Bài 3: Viết hàm tìm vị trí của phần tử lớn nhất trong mảng các số nguyên. Bài 4: Viết hàm in vị trí các phần tử nguyên tố trong mảng các số nguyên. Bài 5: Viết hàm in vị trí các phần tử nguyên tố lớn hơn 23. Bài 6: Viết hàm tìm vị trí phần tử âm đầu tiên trong mảng. Nếu không có phần tử âm trả về -1. Bài 7: Viết hàm tìm vị trí phần tử âm lớn nhất trong mảng. Bài 8: Viết hàm tìm vị trí phần tử dương đầu tiên trong mảng. Nếu không có phần tử âm trả về -1. Bài 9: Viết hàm tìm vị trí phần tử dương bé nhất trong mảng. 49 Chương 5 KIỂU DỮ LIỆU MẢNG MỘT CHIỀU Bài 10: Viết hàm in các phần tử là bội của 3 và 5. Bài 11: Viết hàm tìm số chẵn cuối cùng có trong mảng, nếu không tồn tại số chẵn hàm trả về -1. Bài 12: Viết hàm tìm số lẻ lớn nhất có trong mảng, n ếu không tồn tại số lẻ hàm trả về -1. Bài 13: Viết hàm tìm và đổi chỗ phần tử lớn nhất với phần tử nhỏ nhất trong mảng. Bài 14: Nhập vào x. Viết hàm in ra màn hình những phần tử có giá trị từ 1 đến x có trong mảng. Bài 15: Viết chương trình nhập vào một dãy số a gồm n số thực và dãy số b gồm m số thực (m,n ≤ 100). a) In ra những phần tử chỉ xuất hiện trong dãy a mà không xuất hiện trong dãy b. b) In ra những phần tử xuất hiện ở cả hai dãy. Kỹ thuật đếm phần tử - tần suất Ví dụ 5.8 Viết hàm đếm các phần tử chia hết cho 5 trong mảng các số nguyên. int Dem(int a[], int n) à int dem = 0; for(int i = 0; i < n; i++) if(a[i] % 5 == 0) dem++; return dem; â Bài 1: Viết hàm đếm các phần tử âm, dương trong mảng. Bài 2: Viết hàm đếm các phần tử chẵn, lẻ trong mảng. Bài 3: Viết hàm đếm số lần xuất hiện của phần tử x trong mảng. Bài 4: Viết hàm đếm các phần tử nhỏ hơn x trong mảng.",
        "Summary": "Các bài tập lập trình tập trung vào xử lý mảng một chiều, bao gồm các hàm tìm vị trí phần tử thỏa mãn điều kiện nhất định (lớn nhất, nhỏ nhất, nguyên tố, âm, dương, nằm trong khoảng giá trị cụ thể). Một số bài tập khác liên quan đến việc đếm tần suất xuất hiện của các phần tử thỏa mãn điều kiện (âm, dương, chẵn, lẻ, bội số), tìm phần tử cuối cùng (chẵn, lẻ), và so sánh, tìm phần tử chung hoặc riêng giữa hai mảng. Các hàm được yêu cầu trả về vị trí hoặc số lượng phần tử, hoặc thực hiện thao tác sắp xếp, hoán đổi vị trí phần tử trong mảng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có bất kỳ sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt được trình bày một cách mạch lạc và rõ ràng. Các ý được liên kết logic với nhau, tạo thành một dòng chảy thông tin dễ hiểu. Cách diễn đạt súc tích giúp người đọc nhanh chóng nắm bắt được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Nó tập trung vào các ý chính, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất. Bản tóm tắt đã bao quát được các dạng bài tập khác nhau về mảng một chiều được đề cập trong văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, tính mạch lạc và tính liên quan. Bản tóm tắt đã tóm gọn được nội dung chính của văn bản gốc một cách hiệu quả. Không có đề xuất cải thiện nào."
            }
        }
    },
    {
        "Index": "00153",
        "Article": "Kết nối mạng diện rộng 8.3.2.1 Giao thức PPP PPP là giao thức được sử dụng chủ yếu khi người dùng truy cập Internet từ nhà thông qua đường điện thoại quay số, do đó PPP là một trong những giao thức tầng nên kết dữ liệu được sử dụng nhiều nhất nhất ngày nay. Giao thức quan trọng thứ hai là HDLC (High Level Data Link Control). Giao thức PPP được trình bày tương đối đơn giản với mục đích khảo sát một số tính năng quan trọng nhất của lớp giao thức điểm nối điểm ở tầng liên kết dữ liệu. Giao thức PPP là giao thức tầng liên kết dữ liệu trên kênh truyền nối trực tiếp giữa hai nút - mỗi nút ở một đầu của đường truyền. Đường truyền PPP có thể là đường điện thoại quay số (ví dụ kết nối modem 56k), đường truyền SONET, kết nối X.25 hoặc mạng ISDN. Như đã nói trên, PPP chủ yếu được lựa chọn để kết nối máy tính gia đình đến ISP thông qua đường dây điện thoại. IETF đã đặt ra cho mọi thiết kế của PPP : - Đóng khung dữ liệu (Framing): phía gửi trong giao thức PPP phải có khả năng lấy gói tin ở tầng mạng, đặt nó trong khung dữ liệu tầng liên kết dữ liệu. Phía nhận xác định được vị trí bắt đầu và kết thúc của khung dữ liệu cũng như vị trí gói tin tầng mạng trong khung dữ liệu. Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 179 - Tính trong suốt: Giao thức PPP không được đặt ra bất kỳ hạn chế nào trên gói dữ liệu tầng mạng. Tức là nó có khả năng chuyển đi bất kỳ gói dữ liệu tầng mạng nào.",
        "Summary": "PPP (Point-to-Point Protocol) là một giao thức tầng liên kết dữ liệu phổ biến, chủ yếu được sử dụng để kết nối người dùng từ xa (ví dụ: từ nhà) đến Internet thông qua đường điện thoại quay số. PPP hoạt động trên kênh truyền trực tiếp giữa hai nút và có khả năng đóng khung dữ liệu từ tầng mạng, đảm bảo tính trong suốt bằng cách không hạn chế loại gói dữ liệu nào được truyền đi.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Các ý chính về định nghĩa, mục đích sử dụng và tính năng của PPP đều được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu được liên kết logic với nhau, tạo thành một đoạn văn dễ hiểu. Trình tự thông tin hợp lý, bắt đầu từ định nghĩa, đến mục đích sử dụng và cuối cùng là các tính năng quan trọng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ những ý chính và quan trọng nhất về giao thức PPP được giữ lại, bao gồm định nghĩa, mục đích sử dụng chính và hai tính năng quan trọng (đóng khung dữ liệu và tính trong suốt). Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Các ý chính được trình bày rõ ràng và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00154",
        "Article": "Hệ thống khóa máy chủ tin cậy của MIT (Trường Đại học Kỹ thuật Massachusetts) cung cấp xác thực có bên thứ ba dùng khóa riêng và tập trung, cho phép người sử dụng truy cập vào các dịch vụ phân tán trong mạng mà không cần tin cậy mọi máy trạm, thay vào đó chỉ cần tin cậy máy chủ xác thực trung tâm. Hai phiên bản phổ biến là Kerberos 4 và Kerberos 5. Kerberos yêu cầu đảm bảo an toàn, tin cậy, trong suốt và có thể mở rộng, sử dụng thủ tục xác thực Needham-Schroeder. Kerberos 4 là sơ đồ xác thực dùng bên thứ ba với máy chủ xác thực (AS – Authentication Server), cung cấp sự tin cậy thông qua thẻ cấp thẻ TGT (Ticket Granting Ticket) và máy chủ cung cấp thẻ (TGS – Ticket Granting Server), cho phép người dùng truy cập dịch vụ dựa trên TGT. Trong Kerberos 4, người dùng nhận thẻ cấp từ AS cho từng phiên làm việc, sau đó sử dụng thẻ cấp dịch vụ từ TGS để truy cập các dịch vụ khác nhau. Môi trường Kerberos bao gồm máy chủ Kerberos, các máy trạm đã đăng ký và máy chủ ứng dụng chia sẻ khóa với Kerberos, tạo thành một lãnh địa Kerberos. Nếu có nhiều lãnh địa, các máy chủ Kerberos phải chia sẻ khóa và tin cậy nhau. Kerberos 5 được phát triển vào giữa những năm 1990 theo chuẩn RFC 1510, cải tiến các thuật toán mã hóa, thủ tục mạng, thời gian sử dụng thẻ, xác thực lãnh địa con, hỗ trợ mã kép và cơ chế chống tấn công mật khẩu. Kerberos là giao thức xác thực mạng, cho phép các cá nhân giao tiếp an toàn trên mạng không bảo mật bằng cách xác thực hai chiều giữa người dùng và dịch vụ. Kerberos sử dụng mã hóa khóa đối xứng và một bên thứ ba tin cậy để chứng thực, gọi là Trung tâm phân phối khóa (KDC), bao gồm máy chủ xác thực (AS) và máy chủ cấp thẻ (TGS). Kerberos duy trì cơ sở dữ liệu khóa bí mật cho mỗi thực thể mạng và tạo khóa phiên để bảo mật giao tiếp. Quá trình hoạt động gồm các bước: người dùng nhập mật khẩu, máy trạm băm mật khẩu thành khóa bí mật, gửi yêu cầu đến AS, AS kiểm tra danh tính và gửi lại khóa phiên cùng thẻ TGT. Khi truy cập dịch vụ, máy trạm gửi yêu cầu đến TGS với TGT, nhận lại khóa phiên máy chủ và thẻ truy cập dịch vụ. Máy trạm sau đó gửi thông tin đến máy chủ dịch vụ, nhận xác nhận hợp lệ và bắt đầu sử dụng dịch vụ. Kerberos thích hợp cho xác thực và bảo vệ thông tin trong phạm vi mạng giới hạn nhưng không phù hợp với chữ ký điện tử do không đảm bảo tính không chối cãi. Hạn chế của Kerberos là yêu cầu máy chủ mạng đáng tin cậy, dễ bị tấn công từ điển nếu mật khẩu yếu, và phụ thuộc vào sự an toàn của Trung tâm phân phối khóa. Để đảm bảo toàn vẹn dữ liệu, các thuật toán mã hóa băm, mã xác nhận thông điệp (MAC) và chữ ký điện tử có thể được triển khai, sử dụng hàm một chiều để bảo vệ dữ liệu khỏi bị giải mã ngay cả khi khóa bị lộ.",
        "Summary": "Hệ thống Kerberos của MIT cung cấp xác thực mạng an toàn thông qua máy chủ xác thực trung tâm và sử dụng mã hóa khóa đối xứng. Các phiên bản Kerberos 4 và Kerberos 5 hỗ trợ xác thực với thẻ TGT và thẻ cấp dịch vụ, giúp người dùng truy cập dịch vụ mà không cần tin cậy mọi máy trạm. Kerberos 5 cải tiến các thuật toán mã hóa và thủ tục xác thực, nhưng vẫn có hạn chế về yêu cầu tin cậy vào máy chủ mạng và dễ bị tấn công từ điển nếu mật khẩu yếu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Các ý chính về định nghĩa, mục đích sử dụng và tính năng của PPP đều được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu được liên kết logic với nhau, tạo thành một đoạn văn dễ hiểu. Trình tự thông tin hợp lý, bắt đầu từ định nghĩa, đến mục đích sử dụng và cuối cùng là các tính năng quan trọng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ những ý chính và quan trọng nhất về giao thức PPP được giữ lại, bao gồm định nghĩa, mục đích sử dụng chính và hai tính năng quan trọng (đóng khung dữ liệu và tính trong suốt). Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Các ý chính được trình bày rõ ràng và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00155",
        "Article": "Chúng sẽ làm giảm bớt những mối đe dọa tấn công bằng việc loại bỏ lƣu lƣợng mạng bất hợp pháp, trong khi vẫn cho phép các hoạt động hợp pháp đƣợc tiếp tục. IPS ngăn chặn các cuộc tấn công dƣới những dạng sau: - Ứng dụng không mong muốn và tấn công kiểu “Trojan horse” nhằm vào mạng và ứng dụng cá nhân, qua việc sử dụng các nguyên tắc xác định và danh sách kiểm soát truy - Các tấn công từ chối dịch vụ nhƣ “lụt” các gói tin SYN và ICMP bởi việc dùng các thuật toán dựa trên cơ sở “ngƣỡng”. - Sự lạm dụng các ứng dụng và giao thức qua việc sử dụng những qui tắc giao thức ứng dụng và chữ kí. - Những tấn công quá tải hay lạm dụng ứng dụng bằng việc sử dụng giới hạn tài nguyên dựa trên cơ sở ngƣỡng.  Những hạn chế của IDS /IPS: So với Firewall, IDS/ IPS đã thể hiện đƣợc nhiều tính năng ƣu việt. Nó không chỉ có khả năng phát hiện ra các cuộc tấn công, mà còn chống lại các cuộc tấn công này một cách hữu hiệu. Tuy vậy hệ thống này vẫn không thể nhận biết đƣợc trạng thái tầng ứng dụng (chỉ có thể nhận biết đƣợc các dòng thông tin trên tầng mạng). Do vậy các cuộc tấn công trên tầng ứng dụng sẽ không bị phát hiện và ngăn chặn. Theo Hitachi, Ltd. (sau đây gọi tắt là \"Hitachi\") định nghĩa thông tin cá nhân chính là tất cả các thông tin về cá nhân, bao gồm họ tên, ngày sinh và các mô tả khác, hoặc một số, biểu tƣợng, mã, hình ảnh hoặc âm thanh đƣợc gán cho họ, để nhận biết cá nhân (điều này cũng bao gồm thông tin không thể nhận biết đƣợc cá nhân, nhƣng có thể dễ dàng nhận biết khi kết hợp với các thông tin khác). Ngoài ra, điều này cũng sẽ không giới hạn ở thông tin nhận dạng cá nhân, mà còn bao gồm tất cả các thông tin trình bày một dữ kiện, công nhận và đánh giá tính cách của cá nhân đó, bao gồm hình dáng bề ngoài, tài sản, nghề nghiệp hoặc gia Định nghĩa về thông tin cá nhân của APEC: Thông tin cá nhân là bất kỳ thông tin nào để xác định đƣợc hay có thể xác định đƣợc danh tính của một cá nhân cụ thể.",
        "Summary": "IPS ngăn chặn các cuộc tấn công dƣới những dạng sau - Ứng dụng không mong muốn và tấn công kiểu Trojan horse nhằm vào mạng và ứng dụng cá nhân, qua việc sử dụng các nguyên tắc xác định và danh sách kiểm soát truy - Các tấn công từ chối dịch vụ nhƣ lụt các gói tin SYN và ICMP bởi việc dùng các thuật toán dựa trên cơ sở ngƣỡng. - Sự lạm dụng các ứng dụng và giao thức qua việc sử dụng những qui tắc giao thức ứng dụng và chữ kí. - Những tấn công quá tải hay lạm dụng ứng dụng bằng việc sử dụng giới hạn tài nguyên dựa trên cơ sở ngƣỡng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Các ý chính về định nghĩa, mục đích sử dụng và tính năng của PPP đều được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu được liên kết logic với nhau, tạo thành một đoạn văn dễ hiểu. Trình tự thông tin hợp lý, bắt đầu từ định nghĩa, đến mục đích sử dụng và cuối cùng là các tính năng quan trọng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ những ý chính và quan trọng nhất về giao thức PPP được giữ lại, bao gồm định nghĩa, mục đích sử dụng chính và hai tính năng quan trọng (đóng khung dữ liệu và tính trong suốt). Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Các ý chính được trình bày rõ ràng và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
        {
        "Index": "00156",
        "Article": "Giai đoạn phát triển trong quy trình phần mềm tập trung vào việc xác định cách thức triển khai phần mềm, bao gồm cấu trúc dữ liệu, kiến trúc hệ thống, cài đặt thủ tục, dịch thiết kế sang ngôn ngữ lập trình và thực hiện kiểm thử. Các phương pháp áp dụng trong giai đoạn này có thể thay đổi tùy theo mô hình phát triển phần mềm, nhưng luôn bao gồm ba bước quan trọng. Thứ nhất, thiết kế phần mềm là quá trình chuyển đổi các yêu cầu thành một tập hợp các biểu diễn cụ thể về cấu trúc dữ liệu, kiến trúc, thuật toán và giao diện. Thiết kế phần mềm bao gồm nhiều khía cạnh như đặc tả trừu tượng, thiết kế đối tượng dữ liệu, thiết kế hệ thống, thiết kế kiến trúc, thiết kế giao diện, thiết kế thành phần, thiết kế cấu trúc dữ liệu và thiết kế giải thuật. Thứ hai, mã hóa là bước chuyển đổi các biểu diễn thiết kế thành mã nguồn bằng một hoặc nhiều ngôn ngữ lập trình. Quá trình này có thể sử dụng ngôn ngữ lập trình truyền thống hoặc các ngôn ngữ thế hệ thứ tư (4GT) để tối ưu hóa việc phát triển. Việc lựa chọn ngôn ngữ lập trình phù hợp và tuân thủ các nguyên tắc lập trình tốt là yếu tố quan trọng để đảm bảo chất lượng phần mềm. Cuối cùng, kiểm thử phần mềm là bước thiết yếu để phát hiện lỗi từ giai đoạn phân tích, thiết kế đến cài đặt, đồng thời đánh giá hiệu quả hoạt động của phần mềm. Kiểm thử không chỉ giúp phát hiện lỗi mà còn đảm bảo rằng phần mềm đáp ứng đầy đủ các yêu cầu đã đề ra. Đây là bước quan trọng nhằm đảm bảo chất lượng trước khi phần mềm được đưa vào sử dụng thực tế.",
        "Summary": "Giai đoạn phát triển phần mềm gồm ba bước quan trọng. Đầu tiên, thiết kế phần mềm chuyển đổi yêu cầu thành biểu diễn cụ thể về cấu trúc dữ liệu, kiến trúc và thuật toán. Tiếp theo, mã hóa chuyển các biểu diễn thiết kế thành mã nguồn bằng ngôn ngữ lập trình phù hợp. Cuối cùng, kiểm thử phần mềm giúp phát hiện lỗi và đánh giá hiệu quả hoạt động để đảm bảo chất lượng trước khi triển khai.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày theo trình tự logic, rõ ràng và dễ hiểu. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin liền mạch."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Bản tóm tắt tập trung vào ba bước quan trọng trong giai đoạn phát triển phần mềm, đúng như trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00157",
        "Article": "Tuy nhiên phần mềm nào mới là tốt nhất và tốt ở điểm gì? những thông số dựa vào bảng khảo sát của trang Web uy tín toptenreviews.com. TOP 10 PHẦN MỀM DIỆT VIRUS NĂM 2014 Đứng đầu phải kể đến phần mềm Bitdefender Antivirus Plus đƣợc phát triển và phát hành bởi nhà sản xuất Bitdefender. Với những tính năng vƣợt trội cùng với công nghệ quét chống xâm nhập và nhanh chóng, có khả năng loại bỏ Virus, Trojan, Worm, Rootkit, Spyware..., bảo vệ các giao dịch trực tuyến và thông tin cá nhân của bạn. Bạn có thể sử dụng tiện ích này để bảo vệ các thành phần trên máy tính hoặc sử dụng để bảo vệ ổ đĩa USB, ổ cứng di động... Nằm trong top 10 lần này không thể không nhắc đến Kaspersky Anti-Virus. Tiện ích này có khả năng loại bỏ Virus và các mã độc hại mới nhất xuất hiện trên thị trƣờng, tự động chống lại các khai thác không mong muốn của những Hacker chuyên nghiệp xâm nhập thông qua những lỗ hổng bảo mật máy tính.. và nhiều tính năng khác Đã từng là phần mềm thống trị mọi bảng xếp hạng những phần mềm diệt Virus tốt nhất trƣớc đây, Norton AntiVirus nổi tiếng vì những tính năng đơn giản và an toàn. Với công nghệ ngày càng tiến, phần mềm này có khả năng chống lại mọi xâm nhập bất hợp pháp từ Virus, Spyware cũng nhƣ các mối nguy hại khác làm ảnh hƣởng đến tốc độ và hiệu suất làm F-Secure Anti-Virus là phần mềm giúp bạn bảo vệ máy tính bằng cách phát hiện và loại bỏ Virus, Spyware mà không làm ảnh hƣởng đến tốc độ của hệ thống máy tính. Tiện ích này hoạt động chủ yếu dựa trên công nghệ điện toán đám mây, có khả năng chống lại những mã độc hại mới nhất xuất hiện trên thị trƣờng.",
        "Summary": "Tuy nhiên phần mềm nào mới là tốt nhất và tốt ở điểm gì? TOP 10 PHẦN MỀM DIỆT VIRUS NĂM 2014 Đứng đầu phải kể đến phần mềm Bitdefender Antivirus Plus đƣợc phát triển và phát hành bởi nhà sản xuất Bitdefender. và nhiều tính năng khác Đã từng là phần mềm thống trị mọi bảng xếp hạng những phần mềm diệt Virus tốt nhất trƣớc đây, Norton AntiVirus nổi tiếng vì những tính năng đơn giản và an toàn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt trung thực, tuy nhiên, việc lược bỏ nhiều thông tin khiến cho một số câu trở nên cụt ngủn và thiếu ngữ cảnh. Ví dụ, câu 'và nhiều tính năng khác' không rõ ràng vì thiếu thông tin về các tính năng đó."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt chưa được mạch lạc. Các câu không có sự liên kết rõ ràng, tạo cảm giác rời rạc. Cần có sự kết nối tốt hơn giữa các ý để đảm bảo tính logic và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có chọn lọc một số ý chính, nhưng việc bỏ qua nhiều chi tiết quan trọng khiến cho nội dung trở nên sơ sài. Ví dụ, việc không đề cập đến Kaspersky Anti-Virus và F-Secure Anti-Virus làm giảm tính bao quát của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức trung bình. Điểm mạnh là giữ lại được một số thông tin chính từ văn bản gốc. Tuy nhiên, cần cải thiện về tính mạch lạc và tính liên quan bằng cách kết nối các ý tốt hơn và bao gồm thêm các chi tiết quan trọng khác. Cần tránh việc trích dẫn nguyên văn mà không có sự chỉnh sửa để đảm bảo tính trôi chảy và dễ hiểu."
            }
        }
    },
    {
        "Index": "00158",
        "Article": "Có thể nói những thuật ngữ: kiểu dữ liệu, kiểu đữ liệu trừu tượng và cấu trúc dữ liệu (trong tiếng Anh tương ứng là Data Types, Abstract Data Types, Data Structures) nghe rất giống nhau, nhưng thực ra chúng có ý nghĩa khác nhau. \n Trong ngôn ngữ lập trình, kiểu dữ liệu của biển là tập các giá trị mà biến này cớ thể nhận. Ví dụ, biến kiểu boolean chỉ có thể nhận giá trị đúng hoặc sai. Các kiểu dữ liệu cơ bản có thể thay đỗi từ ngôn ngữ lập trình này sang ngôn ngữ lập trình khác. Ta có thể tạo những kiểu đữ liệu phức hợp từ những kiểu dữ liệu cơ bản. Cách tạo cũng phụ thuộc vào ngôn ngữ lập trình. \n Kiểu dữ liệu trừu tượng là mô hình toản học cùng với những phép toán xác định trên mô hình này. Nó không phụ thuộc vào ngôn ngữ lập trình. \n Để biểu diễn mô hình toán học trong ADT, ta sử dụng cấu trúc dữ liệu. \n Cấu trúc dữ liệu (Data Structures) là một họ các biến, có thể có kiểu dữ liệu khác nhau, được liên kết lại theo một cách thức nào đó. \n Việc cài đặt ADT đòi hỏi lựa chọn cấu trúc dữ liệu để biểu diễn ADT. Ta sẽ xét xem việc làm đó được tiến hành như thế nào? \n Ô là đơn vị cơ sở cấu thành cấu trúc dữ liệu. Có thể hình đung ô như một hộp đựng giá trị phát sinh từ một kiểu dữ liệu cơ bản hay phức hợp. \n Cấu trúc đữ liệu được tạo nhờ đặt tên cho một nhóm các ô và đặt giá trị cho một số ô để mô tả sự liên kết giữa các ô. Ta xét một số cách tạo nhóm. \n Một trong những cách tạo nhóm đơn giản nhất trong các ngôn ngữ lập trình là mảng. Mảng là một dãy các ô có cùng kiểu xác định nào đó.",
        "Summary": "\"Các thuật ngữ kiểu dữ liệu, kiểu dữ liệu trừu tượng (ADT) và cấu trúc dữ liệu có ý nghĩa khác nhau. Kiểu dữ liệu trong lập trình là tập giá trị biến có thể nhận, có thể là cơ bản hoặc phức hợp. ADT là mô hình toán học với các phép toán xác định, không phụ thuộc vào ngôn ngữ. Cấu trúc dữ liệu là họ các biến liên kết, được dùng để biểu diễn mô hình toán học trong ADT. Cài đặt ADT đòi hỏi lựa chọn cấu trúc dữ liệu phù hợp, cấu trúc dữ liệu được tạo thành từ các ô (đơn vị cơ sở), và mảng là một trong những cách tạo nhóm đơn giản nhất.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa và mối quan hệ giữa các khái niệm: kiểu dữ liệu, kiểu dữ liệu trừu tượng và cấu trúc dữ liệu."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Tóm tắt đã làm nổi bật được các ý chính và quan trọng nhất của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00159",
        "Article": "Kiểm tra chéo với tập kiểm tra tách riêng (hold-out cross validation), hay có thể gọi là kiểm tra chéo đơn giản, là phương pháp kiểm tra chéo đơn giản nhất và được thực hiện như e. Chia tập dữ liệu huấn luyện S ban đầu một cách ngẫu nhiên thành hai tập con: tập thứ nhất Shl được gọi là tập huấn luyện, và tập thứ hai (phần còn lại) Skt gọi là tập kiểm tra. Thông thường, Shl gồm 70% tập dữ liệu ban đầu và Skt gồm f. Huấn luyện mô hình cần đánh giá hi trên tập Shl. g. Đánh giá độ chính xác của mô hình hi trên tập kiểm tra Skt. h. Chọn mô hình có độ chính xác cao nhất trên tập kiểm tra để sử dụng (nếu mục đích là lựa chọn mô hình). Do mô hình được đánh giá trên tập dữ liệu kiểm tra Skt , là dữ liệu chưa được dùng khi huấn luyện nên độ chính xác của mô hình trong trường hợp dữ liệu mới được ước lượng chính xác hơn. Thông thường, tập dữ liệu huấn luyện có kích thước bằng 1/4 đến 1/3 tập dữ liệu ban đầu, hay khoảng 30% tập dữ liệu ban đầu. Trong trường hợp lựa chọn mô hình, mô hình tốt nhất được chọn sau đó được huấn luyện lại trên toàn bộ tập dữ liệu ban đầu. Nói chung, việc huấn luyện lại mô hình trên tập dữ liệu lớn hơn như vậy cho phép tăng độ chính xác. Một nhược điểm của phương pháp sử dụng bộ dữ liệu kiểm tra riêng là phần dùng để huấn luyện (tập Shl) chỉ còn khoảng 70% tập ban đầu và do vậy bỏ phí quá nhiều dữ liệu dùng để kiểm tra. Dưới đây là phương pháp kiểm tra chéo khác cho phép sử dụng ít dữ liệu kiểm tra Kiểm tra chéo k-fold (k-fold cross validation).",
        "Summary": "Kiểm tra chéo với tập kiểm tra tách riêng hold-out cross validation, hay có thể gọi là kiểm tra chéo đơn giản, là phương pháp kiểm tra chéo đơn giản nhất và được thực hiện như e. Một nhược điểm của phương pháp sử dụng bộ dữ liệu kiểm tra riêng là phần dùng để huấn luyện tập Shl chỉ còn khoảng 70% tập ban đầu và do vậy bỏ phí quá nhiều dữ liệu dùng để kiểm tra. Dưới đây là phương pháp kiểm tra chéo khác cho phép sử dụng ít dữ liệu kiểm tra Kiểm tra chéo k-fold k-fold cross validation.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt mạch lạc, các câu được liên kết một cách logic và dễ hiểu. Các ý được trình bày rõ ràng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính của văn bản gốc, đặc biệt là định nghĩa, nhược điểm của phương pháp kiểm tra chéo hold-out và giới thiệu về phương pháp kiểm tra chéo k-fold. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt, đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Bản tóm tắt đã chọn lọc và trình bày các ý chính một cách hiệu quả."
            }
        }
    },
    {
        "Index": "00160",
        "Article": "So với phƣơng pháp từ trên xuống thì phƣơng pháp này tốn thời gian hơn. 3. Dùng phán đoán của chuyên gia Đây là phƣơng pháp dùng một ngƣời có kinh nghiệm đối với dự án tƣơng tự nhƣ dự án đang cần thực hiện và đƣợc thực hiện gần đây. Ngƣời đó sẽ cung cấp những kinh nghiệm và đƣa ra những ƣớc lƣợng tƣơng tự nhƣ dự án trƣớc đó. Độ chính các của việc ƣớc lƣợng theo phƣơng pháp này phụ thuộc vào độ chuyên gia, hiểu biết thực sự của họ về lĩnh vực tri thức và dự án trƣớc đó. Với phƣơng pháp này, việc lựa chọn các ứng dụng tƣơng tự phải chính xác, và có tính hệ thống. Có thể sử dụng một hệ thống đánh trọng số để lựa chọn dự án tƣơng tự nếu nhƣ có nhiều dự án làm ứng cử viên. 4. Phƣơng pháp dựa trên tham số Phƣơng pháp này ƣớc lƣợng dựa trên một số tham số và một số mô hình toán học hoặc mô hình xác suất thống kê. Chúng ta tìm hiểu một số đơnvị đo lƣờng thuật toán đƣợc coi là tham số cho + Số dòng lệnh- LOC: là tổng số dòng lệnh, mã nguồn của tất cả các chức năng của dự án +Điểm chức năng-FPs: là tổng số điểm mốc chức năng của các công việc trong dự án, ở đây kích cỡ của dự án không đƣợc đo bằng số dòng lệnh bởi một số chức năng khó thì khi cài đặt tuy số dòng mã nguồn có thể lớn nhƣng công viết ra nó có thể rất ít, ngƣợc lại những chức năng có độ phức tạp lớn thì khá tốn công viết tuy rằng số lƣợng dòng lệnh + Các đơn vị khác có thể là số lƣợng “bọt nổi” trong một cây tìm kiếm theo chiều sâu, tìm kiếm theo thuật toán nổi bọt hay số lƣợng thực thể của mô hình thực thể liên kết hay số lƣợng các tiến trình trên một biểu đồ cấu trúc. Hai đơn vị hay đƣợc sử dụng nhất là LOC và FPs và đƣợc sử dụng theo các cách tiếp cận thuật Ƣớc lƣợng dựa trên LOC có + Ƣu điểm là đơn vị đo lƣờng nhìn chung dễ hiểu, cho phép so sánh cụ thể và rõ ràng, dễ đo đạc + Nhƣợc điểm của LOC là khó ƣớc lƣợng sớm trong chu trình phát triển dự án bởi lúc đó chƣa có thiết kế và lập trình nên chƣa biết số lƣợng mã nguồn là bao nhiêu.",
        "Summary": "Dùng phán đoán của chuyên gia Đây là phƣơng pháp dùng một ngƣời có kinh nghiệm đối với dự án tƣơng tự nhƣ dự án đang cần thực hiện và đƣợc thực hiện gần đây. Ngƣời đó sẽ cung cấp những kinh nghiệm và đƣa ra những ƣớc lƣợng tƣơng tự nhƣ dự án trƣớc đó. Hai đơn vị hay đƣợc sử dụng nhất là LOC và FPs và đƣợc sử dụng theo các cách tiếp cận thuật Ƣớc lƣợng dựa trên LOC có + Ƣu điểm là đơn vị đo lƣờng nhìn chung dễ hiểu, cho phép so sánh cụ thể và rõ ràng, dễ đo đạc + Nhƣợc điểm của LOC là khó ƣớc lƣợng sớm trong chu trình phát triển dự án bởi lúc đó chƣa có thiết kế và lập trình nên chƣa biết số lƣợng mã nguồn là bao nhiêu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu liên kết với nhau một cách logic. Tuy nhiên, có thể cải thiện bằng cách thêm một câu giới thiệu ngắn gọn về các phương pháp ước lượng để tạo sự liền mạch hơn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào phương pháp dùng phán đoán của chuyên gia và ước lượng dựa trên LOC. Tuy nhiên, việc bỏ qua phương pháp dựa trên tham số có thể làm giảm tính bao quát của tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, trung thực và mạch lạc. Tuy nhiên, để cải thiện, nên cân nhắc thêm một câu ngắn gọn giới thiệu về các phương pháp ước lượng và đảm bảo tính bao quát hơn bằng cách đề cập đến phương pháp dựa trên tham số."
            }
        }
    },
    {
        "Index": "00161",
        "Article": "Tài liệu xác định yêu cầu là mô tả hướng khách hàng và được viết bởi ngôn ngữ của khách hàng. Khi đó có thể dùng ngôn ngữ tự nhiên và các khái niệm trừu tượng. Tài liệu dặc tả yêu cầu (đặc tả chức năng) là mô tả hướng người phát triển, là cơ sở của hợp đồng làm phần mềm. Nó không được phép mơ hồ, nếu không sẽ dẫn đến sự hiểu nhầm bởi khách hàng hoặc người phát triển. Với một yêu cầu mơ hồ thì người phát triển sẽ thực hiện nó một cách rẻ nhất còn khách hàng thì không muốn vậy. Do đó khách hàng có thể đòi hỏi sửa đổi chức năng phần mềm khi nó đã gần hoàn thiện khiến cho chi phí tăng và chậm thời điểm bàn giao. Chi phí cho sửa các sai sót trong phát biểu yêu cầu là rất lớn, đặc biệt là khi các sai sót này được phát hiện khi đã bắt đầu xây dựng hệ thống. Theo một số thống kê thì 85% mã phải viết lại do thay đổi yêu cầu và 12% lỗi phát hiện trong 3 năm đầu sử dụng là do đặc tả yêu cầu không chính xác. Do đó, việc đặc tả chính xác yêu cầu là mối quan tâm được đặt lên hàng đầu. Có hai phương pháp đặc tả là Đặc tả phi hình thức: là cách đặc tả bằng ngôn ngữ tự nhiên; Đặc tả hình thức: là cách đặc tả bằng các ngôn ngữ nhân tạo (ngôn ngữ đặc tả), các công thức và biểu đồ. Đặc tả phi hình thức (ngôn ngữ tự nhiên) thuận tiện cho việc xác định yêu cầu nhưng nhiều khi không thích hợp với đặc tả yêu cầu vì: Không phải lúc nào người đọc và người viết đặc tả bằng ngôn ngữ tự nhiên cũng hiều các từ như nhau; Ngôn ngữ tự nhiên quá mềm dẻo do đó các yêu cầu liên quan đến nhau có thể được biểu diễn bằng các hình thức hoàn toàn khác nhau và người phát triển không nhận ra các mối liên quan này; Các yêu cầu khó được phân hoạch một cách hữu hiệu do đó hiệu quả của việc đổi thay chỉ có thể xác định được bằng cách kiểm tra tất cả các yêu cầu chứ không phải một nhóm các yêu cầu liên quan. Các ngôn ngữ đặc tả (đặc tả hình thức) khắc phục được các hạn chế trên, tuy nhiên đa số khách hàng lại không thông thạo các ngôn ngữ này. Thêm nữa mỗi ngôn ngữ đặc tả hình thức thường chỉ phục vụ cho một nhóm lĩnh vực riêng biệt và việc đặc tả hình thức là một công việc tốn kém thời gian. Một cách tiếp cận là bên cạnh các đặc tả hình thức người ta viết các chú giải bằng ngôn ngữ tự nhiên để giúp khách hành dễ hiểu.",
        "Summary": "Tài liệu xác định yêu cầu được viết bằng ngôn ngữ của khách hàng, trong khi tài liệu đặc tả yêu cầu hướng đến người phát triển và phải chính xác để tránh hiểu nhầm, giảm chi phí sửa đổi và đảm bảo tiến độ. Đặc tả yêu cầu có thể sử dụng phương pháp phi hình thức (ngôn ngữ tự nhiên) hoặc hình thức (ngôn ngữ đặc tả), mỗi phương pháp có ưu và nhược điểm riêng. Một cách tiếp cận hiệu quả là kết hợp đặc tả hình thức với chú giải bằng ngôn ngữ tự nhiên để khách hàng dễ hiểu hơn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Tóm tắt đã chọn lọc và giữ lại những ý chính, quan trọng nhất từ văn bản gốc, đồng thời loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào sự khác biệt giữa tài liệu xác định yêu cầu và tài liệu đặc tả yêu cầu, các phương pháp đặc tả và cách tiếp cận hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00162",
        "Article": "Khả năng quản lý và hoạt động của dịch vụ được đơn giản hóa khi dịch vụ hoạt động trong các môi trường có quản lý và xác định. Một hệ sinh thái quản lý hỗ trợ tập hợp quá trình và hoạt động cần thiết để chuyển giao dịch vụ và vận hành chúng nhằm đáp ứng một số mục tiêu của dịch vụ. Trong một hệ sinh thái quản lý, có ít nhất một tác nhân làm người quản lý và ít nhất một tác nhân khác là tác nhân được quản lý. Người quản lý yêu cầu thông tin hoặc thực hiện một số hành động. Người quản lý tác nhân tạo điều kiện thuận lợi cho việc thực hiện yêu cầu bằng cách tương tác với tác nhân bị quản lý thông qua một liên kết giữa tác nhân quản lý và tác nhân được quản lý. Trong hệ sinh thái quản lý, tác nhân có thể giả định vai trò người quản lý hoặc vai trò tác nhân được quản lý. Các tác nhân cho phép các dịch vụ kinh doanh tương tác với tác nhân thực hiện các yếu tố của dịch vụ và làm cho nó có thể đồng bộ hóa nhiều sự kiện khác hoặc hoạt động có thể áp dụng. Tác nhân cho phép việc thực hiện các hoạt động phức tạp trên nhóm tác nhân hoạt động và đa dạng và kiểm soát các hành vi thay đổi trong khi hoạt động. Khả năng hoạt động là khả năng vận hành hệ thống khi thực hiện các chức năng đã dự định trong khoảng thời gian của nó. Nó bao gồm độ tin cậy, tính bảo trì, khả năng hỗ trợ, tính linh hoạt, an toàn, chi phí hoạt động và tính dễ sử dụng. Độ tin cậy là tổng hợp của tính sẵn có và khả năng khôi phục nhanh chóng, đầy đủ trạng thái hệ thống. Khả năng hỗ trợ là khả năng hoạt động hệ thống và thích ứng với nhu cầu thay đổi. Khả năng bảo trì là khả năng nhanh chóng thay đổi dịch vụ và giữ những thứ không cung cấp của dịch vụ ở mức tối thiểu. Khả năng hoạt động xác định các chi phí bao gồm chi phí cho hỗ trợ, bảo trì, đào tạo, các ấn phẩm kỹ thuật, phụ tùng, thiết bị hỗ trợ và một số các tiện ích.",
        "Summary": "Dịch vụ hoạt động hiệu quả hơn trong môi trường được quản lý và xác định rõ. Hệ sinh thái quản lý bao gồm các quy trình và hoạt động cần thiết để triển khai và vận hành dịch vụ, với ít nhất một tác nhân quản lý và một tác nhân được quản lý. Các tác nhân này có thể tương tác với nhau để thực hiện các yêu cầu và đồng bộ hóa các sự kiện. Khả năng hoạt động, bao gồm độ tin cậy, khả năng bảo trì, khả năng hỗ trợ, tính linh hoạt, an toàn, chi phí hoạt động và tính dễ sử dụng, là khả năng vận hành hệ thống một cách ổn định và thích ứng với các nhu cầu thay đổi, đồng thời kiểm soát chi phí liên quan đến hoạt động.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có bất kỳ sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Nhờ đó, bản tóm tắt tập trung vào trọng tâm và truyền tải thông tin hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin chính xác và trình bày một cách súc tích, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00163",
        "Article": "Trong quá trình triển khai ứng dụng công nghệ thông tin (CNTT), người sử dụng đóng vai trò then chốt, không chỉ là người trực tiếp sử dụng hệ thống mà còn là người định hình yêu cầu, tham gia vào quá trình mua sắm, thử nghiệm và đánh giá, đào tạo và hỗ trợ, đảm bảo sự thành công của dự án. Họ là những người hiểu rõ nhất về nhu cầu công việc, từ đó đưa ra các yêu cầu chi tiết và cụ thể cho hệ thống. Sự tham gia của người sử dụng trong quá trình mua sắm phần cứng và phần mềm là vô cùng quan trọng. Họ có thể đưa ra các ý kiến chuyên môn, đánh giá các giải pháp và lựa chọn những sản phẩm phù hợp nhất với nhu cầu của tổ chức. Trong quá trình thử nghiệm và đánh giá, người sử dụng cung cấp những phản hồi quan trọng về tính khả dụng, hiệu suất và tính phù hợp của hệ thống. Đào tạo và hỗ trợ người sử dụng là một bước không thể thiếu để đảm bảo họ có thể khai thác tối đa tiềm năng của hệ thống mới. Sự hỗ trợ này có thể dưới hình thức các khóa đào tạo, tài liệu hướng dẫn hoặc hỗ trợ trực tiếp từ đội ngũ CNTT. Sự tham gia tích cực và sự ủng hộ của người sử dụng là yếu tố then chốt đảm bảo sự thành công của dự án CNTT. Họ giúp đảm bảo rằng hệ thống mới được chấp nhận và sử dụng hiệu quả, mang lại giá trị cho tổ chức. Tuy nhiên, việc triển khai dự án CNTT cũng tiềm ẩn nhiều rủi ro, đặc biệt là khi dự án có quy mô lớn và phức tạp. Chất lượng quản lý dự án và chất lượng đào tạo người sử dụng là hai yếu tố quan trọng giúp giảm thiểu rủi ro và đảm bảo dự án thành công. Doanh nghiệp cần có kế hoạch chi tiết, phân bổ nguồn lực hợp lý và quản lý rủi ro hiệu quả để đảm bảo dự án được thực hiện đúng tiến độ, ngân sách và đạt được các mục tiêu đề ra.",
        "Summary": "\"Trong triển khai ứng dụng CNTT, người sử dụng đóng vai trò quan trọng trong mọi giai đoạn, từ định hình yêu cầu, mua sắm, thử nghiệm, đánh giá đến đào tạo và hỗ trợ. Sự tham gia của họ đảm bảo hệ thống đáp ứng nhu cầu thực tế và được sử dụng hiệu quả. Quản lý dự án chất lượng và đào tạo người dùng tốt là yếu tố then chốt để giảm thiểu rủi ro và đảm bảo thành công của dự án.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic chặt chẽ. Câu văn trôi chảy, dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào vai trò của người sử dụng trong dự án CNTT và tầm quan trọng của quản lý dự án và đào tạo."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó ngắn gọn, chính xác, mạch lạc và bao quát được các ý chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00164",
        "Article": "Việc xử lý sự kiện các sự kiện như vậy được thực hiện nhờ cơ chế ngắt (interrupt). Thiết bị phần cứng có thể yêu cầu thực hiện ngắt bằng cách gửi tín hiệu qua bus. Phần mềm, tức là chương trình đang thực hiện, cũng có thể yêu cầu ngắt bằng cách sử dụng lời gọi hệ thống (system call). Chẳng hạn khi cần ghi ra file, chương trình có thể gửi yêu cầu ngắt dưới dạng lời gọi hệ thống ghi ra file. Hệ thống sẽ chuyển sang xử lý ngắt trước khi quay lại thực hiện tiếp chương trình theo thứ tự thông thường. Xử lý ngắt. Khi có ngắt, CPU sẽ tạm dừng công việc đang thực hiện và chuyển sang thực hiện hàm xử lý ngắt. Sau khi thực hiện xong hàm xử lý ngắt, hệ thống sẽ quay lại điểm tạm dừng và thực hiện tiếp công việc bị ngắt. Cơ chế xử lý ngắt cụ thể phụ thuộc vào từng dòng máy tính và hệ điều hành, tuy nhiên thông thường các máy tính sử dụng cơ chế xử lý ngắt như sau. Các hàm xử lý ngắt được lưu trong bộ nhớ. Các hàm xử lý ngắt do phần cứng đảm nhiệm được lưu trong bộ nhớ ROM hoặc EPROM như một thành phần của phần cứng, ví dụ như một thành phần của BIOS trên PC. Hàm xử lý ngắt của hệ điều hành được tải vào và lưu trong bộ nhớ RAM. Địa chỉ các hàm xử lý ngắt được lưu trong một mảng gọi là vec tơ ngắt, nằm ở phần địa chỉ thấp của bộ nhớ, bắt đầu từ địa chỉ 0. Mỗi phần tử của vec tơ ngắt có kích thước cố định và chứa con trỏ tới hàm xử lý ngắt tương ứng.",
        "Summary": "Thiết bị phần cứng có thể yêu cầu thực hiện ngắt bằng cách gửi tín hiệu qua bus. Phần mềm, tức là chương trình đang thực hiện, cũng có thể yêu cầu ngắt bằng cách sử dụng lời gọi hệ thống system call. Chẳng hạn khi cần ghi ra file, chương trình có thể gửi yêu cầu ngắt dưới dạng lời gọi hệ thống ghi ra file.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt mạch lạc. Các câu được liên kết logic với nhau và trình bày một cách rõ ràng, dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào cách phần cứng và phần mềm yêu cầu ngắt. Tuy nhiên, bản tóm tắt có thể bao gồm thêm thông tin về cách CPU xử lý ngắt để làm rõ hơn về cơ chế ngắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt, trung thực và mạch lạc. Tuy nhiên, để tăng tính liên quan, có thể bổ sung thêm một vài chi tiết quan trọng về cách CPU xử lý ngắt sau khi nhận được yêu cầu."
            }
        }
    },
    {
        "Index": "00165",
        "Article": "Trong quá trình thực hiện, các chương trình và người dùng có thể cần thực hiện thao tác vào/ra dữ liệu (I/O) với đĩa cứng, ổ SSD, bàn phím, chuột, máy in, hoặc các thiết bị ngoại vi khác. Các thao tác vào/ra đóng vai trò quan trọng vì chúng giúp máy tính giao tiếp với môi trường bên ngoài và truy xuất dữ liệu từ bộ nhớ ngoài. Tuy nhiên, việc điều khiển trực tiếp phần cứng để thực hiện các thao tác này là rất phức tạp và không phù hợp với đa số người dùng cũng như các chương trình ứng dụng. Do đó, hệ điều hành đảm nhận vai trò trung gian, quản lý và thực hiện các thao tác vào/ra một cách hiệu quả. Để một chương trình thực hiện thao tác vào/ra, nó cần gửi các lệnh nhất định đến bộ điều khiển thiết bị ngoại vi thông qua các cổng vào/ra. Cụ thể, chương trình sẽ ghi lệnh vào các thanh ghi điều khiển của thiết bị, sau đó chờ phản hồi từ thiết bị để biết thao tác đã hoàn thành hay chưa. Quá trình này thường bao gồm nhiều bước phức tạp như kiểm tra trạng thái thiết bị, xử lý lỗi, đồng bộ hóa dữ liệu và quản lý quyền truy cập tài nguyên. Nếu chương trình phải tự mình thực hiện tất cả các bước này, nó sẽ trở nên rất cồng kềnh và khó lập trình. Hệ điều hành giúp đơn giản hóa việc vào/ra bằng cách cung cấp một giao diện lập trình ứng dụng (API) cho các thao tác I/O. Thay vì thao tác trực tiếp với phần cứng, các chương trình chỉ cần gọi các hàm hệ thống do hệ điều hành cung cấp. Ví dụ, trong hệ điều hành Windows, lập trình viên có thể sử dụng các hàm như ReadFile() và WriteFile() để thực hiện thao tác đọc và ghi dữ liệu. Trên Linux, các hàm tương ứng như read(), write(), hoặc fopen() được sử dụng. Những hàm này giúp lập trình viên không cần quan tâm đến cách thức hoạt động cụ thể của từng thiết bị mà vẫn có thể thực hiện các thao tác vào/ra một cách dễ dàng. Hệ điều hành còn tối ưu hóa quá trình vào/ra bằng cách sử dụng bộ đệm (buffer) để giảm số lần truy cập trực tiếp vào thiết bị, từ đó tăng hiệu suất. Ví dụ, khi đọc một tệp từ đĩa cứng, hệ điều hành có thể tải trước một phần lớn dữ liệu vào bộ nhớ đệm để giảm thời gian chờ đợi của chương trình. Ngoài ra, hệ điều hành còn hỗ trợ các kỹ thuật như vào/ra không đồng bộ (asynchronous I/O) để cho phép chương trình tiếp tục thực hiện công việc khác trong khi thao tác vào/ra đang được xử lý. Nhờ có hệ điều hành, việc thực hiện thao tác vào/ra trở nên dễ dàng hơn cho các chương trình và người dùng. Họ không cần quan tâm đến các chi tiết kỹ thuật phức tạp của từng thiết bị mà chỉ cần sử dụng các lệnh hoặc hàm API do hệ điều hành cung cấp. Điều này giúp hệ thống hoạt động ổn định hơn, tăng hiệu suất và đảm bảo tính tương thích giữa các thiết bị phần cứng khác nhau.",
        "Summary": "Hệ điều hành quản lý các thao tác vào/ra (I/O) bằng cách cung cấp API như ReadFile(), write(), hoặc fopen(), giúp chương trình thực hiện I/O dễ dàng mà không cần thao tác trực tiếp với phần cứng. Hệ điều hành tối ưu hóa I/O qua bộ đệm và hỗ trợ I/O không đồng bộ, tăng hiệu suất và đảm bảo tính tương thích giữa các thiết bị phần cứng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic. Câu văn dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào vai trò của hệ điều hành trong việc quản lý và tối ưu hóa các thao tác I/O."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00166",
        "Article": "• suspend(): phương thức làm tạm dừng hoạt động của 1 luồng nào đó bằng các ngưng cung cấp CPU cho luồng này. Để cung cấp lại CPU cho luồng ta sử dụng phương thức resume(). Cần lưu ý là ta không thể dừng ngay hoạt động của luồng bằng phương thức này. Phương thức suspend() không dừng ngay tức thì hoạt động của luồng mà sau khi luồng này trả CPU về cho hệ điều hành thì không cấp CPU cho luồng nữa. \n • resume(): phương thức làm cho luồng chạy lại khi luồng bị dừng do phương thức suspend() bên trên. Phương thức này sẽ đưa luồng vào lại lịch điều phối CPU để luồng được cấp CPU chạy lại bình thường. \n • stop(): phương thức này sẽ kết thúc phương thức run() bằng cách ném ra 1 ngoại lệ ThreadDeath, điều này cũng sẽ làm luồng kết thúc 1 cách ép buộc. Nếu giả sử, trước khi gọi stop() mà luồng đang nắm giữa 1 đối tượng nào đó hoặc 1 tài nguyên nào đó mà luồng khác đang chờ thì có thể dẫn tới việc xảy ra deadlock. \n • destroy(): dừng hẳn luồng. \n • isAlive(): phương thức này kiểm tra xem luồng còn active hay không. Phương thức sẽ trả về true nếu luồng đã được start() và chưa rơi vào trạng thái dead. Nếu phương thức trả về false thì luồng đang ở trạng thái New Thread hoặc là đang ở trạng thái dead. \n • yeild() : hệ điều hành đa nhiệm sẽ phân phối CPU cho các tiến trình, các luồng theo vòng xoay. Mỗi luồng sẽ được cấp CPU trong 1 khoảng thời gian nhất định, sau đó trả lại CPU cho hệ điều hành, hệ điều hành sẽ cấp CPU cho luồng khác. Khi gọi phương thức này luồng sẽ bị ngừng cấp CPU và nhường cho luồng tiếp theo trong hàng chờ Ready. Luồng không phải ngưng cấp CPU như suspend() mà chỉ ngưng cấp trong lần nhận CPU đó mà thôi. \n • sleep(long): tạm dừng luồng trong một khoảng thời gian tính bằng mili giây. \n • join(): thông báo rằng hãy chờ luồng này hoàn thành rồi luồng cha mới được tiếp tục chạy. \n • join(long): luồng cha cần phải đợi sau mili giây mới được tiếp tục chạy, kể từ lúc gọi join(long). Nếu tham số bằng 0 nghĩa là đợi cho tới khi luồng này kết thúc. \n • getName(): trả về tên của luồng. \n • setName(String name): thay đổi tên của luồng. \n • getId(): trả về id của luồng. \n • getState(): trả về trạng thái của luồng. \n • currentThread(): trả về tham chiếu của luồngđang được thi hành. \n • getPriority(): trả về mức độ ưu tiên của luồng. \n • setPriority(int): thay đổi mức độ ưu tiên của luồng. \n • isDaemon(): kiểm tra nếu luồnglà một luồng Daemon. \n • setDaemon(boolean): thiết lập luồnglà một luồng Daemon hay không. \n • interrupt(): làm gián đoạn một luồng trong Java. Nếu luồng nằm trong trạng thái sleep hoặc wait, nghĩa là sleep() hoặc wait() được gọi ra. Việc gọi phương thức interrupt() trên luồng đó sẽ phá vỡ trạng thái sleep hoặc wait và ném ra ngoại lệ InterruptedException. Nếu luồng không ở trong trạng thái sleep hoặc wait, việc gọi phương thức interrupt() thực hiện hành vi bình thường và không làm gián đoạn luồng nhưng đặt cờ interrupt thành true. \n • isInterrupted(): kiểm tra luồng nào đó đã bị ngắt hay không. \n • interrupted(): kiểm tra xem luồng hiện tại đã bị ngắt hay không.",
        "Summary": "Văn bản mô tả các phương thức quan trọng liên quan đến quản lý luồng (thread) trong Java. Các phương thức này bao gồm: `suspend()` (tạm dừng luồng), `resume()` (khôi phục luồng), `stop()` (kết thúc luồng cưỡng bức), `destroy()` (dừng hẳn luồng), `isAlive()` (kiểm tra trạng thái hoạt động), `yield()` (nhường CPU), `sleep(long)` (tạm dừng trong khoảng thời gian), `join()` (chờ luồng hoàn thành), `getName()`/`setName()` (lấy/đặt tên luồng), `getId()` (lấy ID luồng), `getState()` (lấy trạng thái luồng), `currentThread()` (lấy tham chiếu luồng hiện tại), `getPriority()`/`setPriority()` (lấy/đặt độ ưu tiên luồng), `isDaemon()`/`setDaemon()` (kiểm tra/thiết lập luồng daemon), `interrupt()` (làm gián đoạn luồng) và `isInterrupted()`/`interrupted()` (kiểm tra trạng thái gián đoạn). Các phương thức này cho phép kiểm soát vòng đời, trạng thái và hành vi của luồng, cũng như tương tác giữa các luồng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả các phương thức được liệt kê đều xuất hiện trong văn bản gốc và được mô tả chính xác. Không có thông tin nào bị thêm hoặc diễn giải sai."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic. Câu mở đầu giới thiệu chủ đề, sau đó liệt kê các phương thức một cách có hệ thống, và cuối cùng tóm tắt mục đích chung của các phương thức này."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các phương thức quan trọng liên quan đến quản lý luồng trong Java, là trọng tâm của văn bản gốc. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã chọn lọc và trình bày một cách hiệu quả các thông tin quan trọng nhất từ văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00167",
        "Article": "Những đặc tính có lẽ quan trọng nhất khi lựa chọn một giao thức đó là tính tin cậy và đúng trật tự. Tính tin cậy trong một giao thức thể hiện ở việc nó sẽ đảm bảo chính xác từng byte được gửi mỗi bên, những giao thức không tin cậy sẽ không đảm bảo tính chất này. Giao thức đúng trật tự đảm bảo chính xác trật tự dữ liệu giữa bên gửi và bên nhận. Byte nào gửi trước sẽ được nhận trước, byte gửi sau sẽ được nhận sau. Giao thức hướng kết nối thường đảm bảo tính tin cậy và trật tự của dữ liệu, tuy nhiên chi phí xử lý sẽ tăng cao. Ngược lại, giao thức không kết nối thường không đảm bảo hai tính chất này, nhưng bù lại tốc độ và tính đáp ứng được đảm bảo, những loại ứng dụng thời gian thực và chấp nhận sai sót có thể sử dụng giao thức loại này. Việc thực hiện đóng kết nối chỉ xảy ra trong các giao thức hướng kết nối. Trong trường hợp của TCP, bên A muốn hủy phiên truyền, bên A sẽ gửi một đoạn tin với cờ FIN, bên B nhận được cờ FIN liền gửi đoạn tin trả lại A với cờ ACK để báo đã nhận được, lúc này A sẽ không thể gửi tin, nhưng vẫn có thể nhận tin, cho đến khi B gửi đoạn tin có cờ FIN, khi đó kết nối đã được đóng hoàn toàn. Winsock cũng hỗ trợ khả năng quảng bá dữ liệu của các giao thức. Với cơ chế này, một máy trạm gửi thông điệp tới tất cả các máy trạm khác trên LAN, giao thức không kết nối sẽ được sử dụng để truyền tin, hạn chế của phương pháp này là mỗi máy tính trong mạng sẽ mất thêm chi phí xử lý thông điệp dù muốn hay không muốn. Multicast là cơ chế gửi dữ liệu đến một hoặc nhiều máy trong mạng (không phải tất cả) thông qua một quá trình gọi là tham gia nhóm multicast. Thí dụ, với giao thức IP, các máy tính muốn nhận dữ liệu sẽ tham gia vào một nhóm multicast, bộ lọc sẽ được thực hiện trên phần cứng của card điều hợp mạng để chỉ xử lý dữ liệu liên quan đến nhóm multicast đó. Dữ liệu sau đó sẽ được đẩy ngược lên các tầng trên và chuyển cho ứng dụng thích hợp. Chất lượng dịch vụ (QoS) là cơ chế cho phép ứng dụng yêu cầu một băng thông dành riêng để sử dụng. Thí dụ, dịch vụ truyền hình thời gian thực, để ứng dụng bên nhận nhận được hình ảnh rõ ràng, liên tục thì bên gửi phải đáp ứng một vài tiêu chí về thời gian truyền và tốc độ truyền. QoS cho phép dành riêng một phần băng thông trên mạng cho mục đích này, do đó dữ liệu truyền đi sẽ nhanh và đáp ứng kịp việc hiển thị ở bên nhận.",
        "Summary": "Tính tin cậy và đúng trật tự là hai đặc tính quan trọng của giao thức, thường được đảm bảo bởi giao thức hướng kết nối nhưng làm tăng chi phí xử lý. Winsock còn hỗ trợ cơ chế broadcast, multicast và QoS để truyền dữ liệu hiệu quả và đáp ứng yêu cầu chất lượng dịch vụ của ứng dụng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic với nhau, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tính súc tích và tập trung vào trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt ngắn gọn, đầy đủ các ý chính và mạch lạc."
            }
        }
    },
    {
        "Index": "00168",
        "Article": "9) Chuột - Mouse. https://thuviensach.vn z Là thiết bị nhập bằng các giao diện đồ hoạ như hệ điều hành Window và một số phần mềm khác, trình điều khiển chuột do hệ điều hành Window nắm giữ . 10) Card Video z Card Video là thiết bị trung gian giữa máy tính và màn hình, trên Card Video có bốn thành phần chính . + Ram : Lưu dữ liệu video trước khi hiển thị trên màn hình, bộ nhớ Ram của Card Video càng lớn thì cho hình ảnh có độ phân giải càng cao . + IC : DAC ( Digital Analog Conveter ) đây là IC đổi tín hiệu ảnh từ dạng số của máy tính sang thành tín hiệu tương tự . + IC giải mã Video + BIOS : Là trình điều khiển Card Video khi Window chưa khởi động . z Card Video có thể được tích hợp trực tiếp trên Mainboard 11) Màn hình Monitor https://thuviensach.vn Monitor CRT Monitor LCD z Màn hình Monitor hiển thị các thông tin về hình ảnh, ký tự giúp cho người sử dụng nhận được các kết quả xử lý của máy tính , đồng thời thông qua màn hình người sử dụng giao tiếp với máy tính để đưa ra các điều khiển tương ứng. z Hiện nay có hai loại màn hình phổ biến là CRT và màn hình LCD 4. Khái niệm về phần mềm z Phần mềm là tập hợp của tất cả các câu lệnh do các nhà lập trình viết ra để hướng máy tính làm một số việc cụ thể nào đó , không như các thiết bị điện tử khác, máy vi tính mà không có phần mềm thì nó không hoạt động gì cả . z Để có được phần mềm, các nhà lập trình phải sử dụng các ngôn ngữ lập trình để viết, ngôn ngữ lập trình là ngôn ngữ trung gian giữa ngôn ngữ giao tiếp của con người với ngôn ngữ máy, ngôn ngữ càng gần với ngôn ngữ con người thì gọi là ngôn ngữ bậc cao, càng gần ngôn ngữ máy gọi là ngôn ngữ bậ",
        "Summary": "Bản tóm tắt:\n  \n  Chuột (Mouse) là thiết bị nhập liệu cho giao diện đồ họa, được điều khiển bởi hệ điều hành. Card Video là thiết bị trung gian giữa máy tính và màn hình, gồm RAM (lưu trữ dữ liệu video), IC DAC (chuyển đổi tín hiệu số sang tương tự), IC giải mã Video và BIOS (điều khiển card video trước khi Windows khởi động). Màn hình (Monitor) hiển thị thông tin và cho phép người dùng giao tiếp với máy tính; có hai loại phổ biến là CRT và LCD. Phần mềm là tập hợp các câu lệnh hướng dẫn máy tính thực hiện công việc, được viết bằng ngôn ngữ lập trình (trung gian giữa ngôn ngữ người và ngôn ngữ máy).",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Nhờ đó, bản tóm tắt tập trung vào trọng tâm và truyền tải thông tin hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00169",
        "Article": "Thông thường trong mỗi PLC có một đơn vị xử lý trung tâm, ngoài ra một số loại lớn có tới hai đơn vị xử lý trung tâm dùng để thực hiện những chức năng điều khiển phức tạp và quan trọng gọi là hot standby hay redundant.\n a. Đơn vị xử lý \"một – bit\" \n Thích hợp cho những ứng dụng nhỏ, chỉ đơn thuần là logic ON/OFF, thời gian xử lý chậm nhưng kết cấu đơn giản, giá thành rẻ nên vẫn được thị trường chấp nhận. Một số đặc điểm chính: \n – Xử lý trực tiếp các tín hiệu vào (địa chỉ đơn). \n – Cung cấp lệnh nhỏ thông thường chỉ một quyết định có/không. \n – Ngôn ngữ đầu vào đơn giản, không cần kiến thức tính toán. \n – Khả năng hạn chế trong việc xử lý tín hiệu số (không có chức năng toán học cũng như logic). \n – Chương trình thực hiện liên tiếp, không bị gián đoạn, thời gian của chu trình tương đối dài.\n – Chi phối được với máy tính đơn giản. \n – Khả năng xử lý các tín hiệu tương tự bị hạn chế. \n b. Đơn vị xử lý \"từ – ngữ\" \n Xử lý nhanh chóng các thông tin số, văn bản, phép tính, đo lường, đánh giá, kiểm tra. Cấu trúc phần cứng phức tạp, giá thành cao. Nguyên lý hoạt động: \n – Thông tin lưu trữ trong bộ nhớ chương trình → gọi tuần tự (do đã được điều khiển và kiểm soát bởi bộ đếm chương trình do đơn vị xử lý trung tâm khống chế). \n – Bộ xử lý liên kết các tín hiệu (dữ liệu) đơn lẻ (theo một quy định nào đó – do thuật toán điều khiển) → rút ra kết quả là lệnh cho đầu ra. \n – Sự thao tác tuần tự của chương trình đi qua một chu trình đầy đủ rồi sau đó lại bắt đầu lại từ đầu → thời gian đó gọi là \"thời gian quét\". \n – Đo thời gian mà bộ xử lý 1 KB (kilobyte) chương trình để làm chỉ tiêu đánh giá giữa các PLC. Như vậy bộ vi xử lý quyết định khả năng và chức năng của PLC. \n Một số đặc điểm chính: \n – Các tín hiệu vào/ra chỉ có thể được địa chỉ hoá thông qua ngôn ngữ. \n – Cung cấp tập lệnh lớn hơn, đòi hỏi phải có kiến thức về máy tính. \n – Ngôn ngữ đầu vào phức tạp dùng cho việc cung cấp lệnh lớn. \n – Thu thập và xử lý dữ liệu số. \n – Quá trình thời gian tới hạn được địa chỉ hoá qua các lệnh gián đoạn hoặc chuyển đổi điều khiển khẩn cấp.\n – Phối ghép với máy tính hoặc hệ thống máy tính. \n – Xử lý tín hiệu tương tự ở cả đầu vào và đầu ra.",
        "Summary": "PLC thường có một hoặc hai đơn vị xử lý trung tâm (CPU), trong đó loại hai CPU dùng cho các ứng dụng phức tạp (hot standby/redundant). CPU \"một-bit\" phù hợp cho ứng dụng ON/OFF đơn giản, giá rẻ, xử lý trực tiếp tín hiệu vào, lệnh đơn giản và chương trình thực hiện liên tục. CPU \"từ-ngữ\" xử lý nhanh thông tin số, văn bản, phép tính, có cấu trúc phức tạp và giá thành cao. CPU này lưu trữ thông tin trong bộ nhớ chương trình, xử lý tín hiệu theo thuật toán và lặp lại chu trình quét. CPU \"từ-ngữ\" có tập lệnh lớn, xử lý dữ liệu số, phối ghép với máy tính và xử lý tín hiệu tương tự.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách trình bày theo từng loại CPU giúp người đọc dễ dàng nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào đặc điểm và ứng dụng của từng loại CPU, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được những ý chính của văn bản gốc một cách hiệu quả. Không có đề xuất cải thiện nào."
            }
        }
    },
    {
        "Index": "00170",
        "Article": "Hiện nay, trong giai đoạn đầu của dữ liệu lớn, những ý tưởng và kỹ năng dường như có giá trị lớn nhất. Nhưng cuối cùng hầu hết giá trị sẽ ở trong chính dữ liệu. Bởi vì chúng ta có thể làm được nhiều hơn với thông tin, và cũng bởi vì những người sở hữu dữ liệu sẽ biết đánh giá đúng hơn giá trị tiềm năng của tài sản họ sở hữu, nên họ sẽ giữ nó chặt hơn bao giờ hết, và sẽ tính mức giá cao khi những người ngoài truy cập. Quay lại phép ẩn dụ ở trên, xét cho cùng, bản thân vàng mới là quan trọng nhất. Tuy nhiên, có một khía cạnh quan trọng đối với sự lớn mạnh lâu dài của các chủ sở hữu dữ liệu. Trong một số trường hợp, “các https://thuviensach.vn trung gian dữ liệu” sẽ xuất hiện để có thể thu thập dữ liệu từ nhiều nguồn, tập hợp lại, và sáng tạo với nó. Chủ sở hữu dữ liệu sẽ cho phép các trung gian thực hiện vai trò này bởi vì một số giá trị của dữ liệu chỉ có thể được thu hoạch thông qua họ. Một ví dụ là Inrix, công ty phân tích giao thông ở bên ngoài Seattle. Nó biên dịch dữ liệu vị trí địa lý theo thời gian thực từ 100 triệu xe ở Bắc Mỹ và châu Âu. Dữ liệu đến từ những chiếc xe của BMW, Ford, Toyota, và những hãng khác, cũng như từ các đội xe thương mại như taxi và xe tải giao hàng. Nó cũng lấy dữ liệu từ điện thoại di động của những người lái xe (ở đây ứng dụng điện thoại thông minh miễn phí của Inrix có vai trò quan trọng: người dùng có được tin tức giao thông, đổi lại Inrix có được tọa độ của họ). Inrix kết hợp thông tin này với dữ liệu về các khuôn mẫu giao thông trong quá khứ, thời tiết, và những thứ khác như các sự kiện địa phương để dự đoán xem giao thông sẽ lưu chuyển như thế nào. Sản phẩm từ dây chuyền dữ liệu này được chuyển tiếp đến hệ thống định vị của xe, và được sử dụng bởi chính phủ và các đội xe thương mại.",
        "Summary": "Trong giai đoạn đầu của dữ liệu lớn, kỹ năng và ý tưởng có giá trị, nhưng giá trị cốt lõi cuối cùng nằm ở chính dữ liệu. Các chủ sở hữu dữ liệu sẽ ngày càng giữ chặt và định giá cao dữ liệu của mình. Tuy nhiên, các \"trung gian dữ liệu\" sẽ xuất hiện để thu thập, tập hợp và sáng tạo với dữ liệu từ nhiều nguồn, vì một số giá trị chỉ có thể được khai thác thông qua họ. Ví dụ, Inrix thu thập dữ liệu vị trí từ xe hơi, điện thoại di động và các nguồn khác để dự đoán lưu lượng giao thông, cung cấp thông tin cho hệ thống định vị và chính phủ.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Ví dụ về Inrix được sử dụng hiệu quả để minh họa cho vai trò của 'trung gian dữ liệu'."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00171",
        "Article": "Bảng 7. 3 Một số phương thức của TextArea Nút bấm được tạo ra bằng một trong các phương thức sau : Tạo một nút bấm trắng : Tạo một nút bấm với nhãn cho trước : Thiết lập và truy xuất nhãn của nút bấm : setLabel(), getLabel(). Checkbox được sử dụng trong trường hợp cho người dùng có thể chọn nhiều trường hợp. Người dùng chọn hoặc hủy chọn một hoặc nhiều checkbox. Radiobutton tương tự như checkbox. Tuy nhiên, người dùng chỉ có thể chọn một trong các radiobutton trong Các hàm khởi tạo dùng để tạo ra các checkbox : Để tạo ra radiobutton, trước hết ta phải tạo đối tượng CheckboxGroup : CheckboxGroup fruitGroup = new CheckboxGroup() ; Sau đó ta tạo ra các checkbox lẻ trong nhóm checkboxgroup trên : Checkbox apple = new Checkbox(‘‘Apple’’,fruitGroup,true) ; Checkbox orange = new Checkbox(‘‘Orange’’,fruitGroup, false) ; Checkbox peer = new Checkbox(‘‘Peer’’,fruitGroup, false) ; Để thiết lập và lấy ra trạng thái của checkbox, ta dùng phương thức setState() và Thành phần đồ họa Choice hiển thị một danh sách các lựa chọn và cho phép người dùng lựa chọn một mục trong danh sách đó. Để tạo ra danh sách lựa chọn, ta thực hiện Tạo một đối tượng Choice : Choice color = new Choice() ; Thêm các mục vào cho danh sách : Mỗi Container có một lớp có chức năng quản lý cách bố trí sắp xếp các thành phần giao diện trong Container đó gọi là Layout Manager. AWT hỗ trợ các lớp Layout Manager bao gồm : FlowLayout, GridLayout, BorderLayout, GridBagLayour, Container có một phương thức dùng để xác định loại Layout Manager mà Container sử dụng. Phương thức đó là setLayout(). FlowLayout là cách sắp xếp mặc định cho các ứng dụng Applet và container Panel.",
        "Summary": "Để tạo ra danh sách lựa chọn, ta thực hiện Tạo một đối tượng Choice Choice color new Choice Thêm các mục vào cho danh sách Mỗi Container có một lớp có chức năng quản lý cách bố trí sắp xếp các thành phần giao diện trong Container đó gọi là Layout Manager.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực, mọi thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt mạch lạc, các câu liên kết với nhau một cách logic và dễ hiểu. Các ý được trình bày rõ ràng."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến văn bản gốc, tập trung vào các ý chính về cách tạo danh sách lựa chọn và quản lý bố cục giao diện. Tuy nhiên, có thể lược bỏ bớt chi tiết nhỏ để tập trung hơn vào ý chính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và mạch lạc. Tuy nhiên, để tăng tính liên quan, nên tập trung hơn vào các ý chính và lược bỏ các chi tiết không quá quan trọng."
            }
        }
    },
    {
        "Index": "00172",
        "Article": "Bây giờ chúng ta viết lại chương trình hiển thị dòng chữ: “Chao mung den voi lop hoc Java” bằng môi trường lập trình tích hợp Eclipse – một công cụ phổ biến, tiện lợi và mạnh mẽ được sử dụng rộng rãi trong lập trình Java chuyên nghiệp.Các bước thực hiện như sau:Khởi động Eclipse: Đầu tiên, bạn cần mở phần mềm Eclipse đã cài đặt trên máy tính. Khi khởi động, Eclipse có thể yêu cầu bạn chọn workspace – đó là thư mục dùng để lưu trữ các dự án Java. Bạn có thể giữ nguyên mặc định hoặc chọn thư mục khác tùy ý.Tạo dự án mới: Vào File > New > Java Project để tạo một dự án mới. Trong hộp thoại xuất hiện, nhập tên dự án là Xinchao vào mục Project Name rồi nhấn Next. Bạn có thể để nguyên các thiết lập mặc định khác. Nhấn Finish để hoàn tất việc tạo dự án.Tạo lớp trong dự án: Trong cửa sổ làm việc, ở khung bên trái (gọi là Package Explorer), bạn sẽ thấy dự án Xinchao. Nhấp chuột phải vào dự án này, chọn New > Class để tạo một lớp mới.Trong hộp thoại tạo lớp, nhập Xinchao vào mục Name. Đánh dấu chọn vào ô public static void main(String[] args) để Eclipse tự động tạo phương thức main – là điểm bắt đầu của chương trình. Nhấn Finish để hoàn tất.Viết lệnh chương trình: Trong cửa sổ soạn thảo mã nguồn, thay nội dung mặc định bằng đoạn mã sau:javaSao chépChỉnh sửapublic class Xinchao { public static void main(String[] args) { System.out.println(\"Chao mung den voi lop hoc Java\"); }}Biên dịch và chạy chương trình: Bạn chỉ cần nhấn Ctrl + F11 hoặc vào menu Run > Run. Eclipse sẽ tự động kết nối đến JDK, biên dịch và chạy chương trình. Kết quả sẽ được hiển thị ở cửa sổ Console bên dưới, với nội dung:nginxSao chépChỉnh sửaChao mung den voi lop hoc JavaNếu chương trình bị lỗi: Eclipse sẽ hiển thị thông báo lỗi ngay tại dòng có lỗi, đồng thời mô tả lỗi ở phần dưới cùng (cửa sổ Problems hoặc Console). Dựa vào đó, bạn có thể sửa lại mã nguồn và chạy lại chương trình.Cấu trúc lưu trữ của dự án: Eclipse sẽ tạo thư mục làm việc cho dự án tại đường dẫn:makefileSao chépChỉnh sửaC:\\Users\\user\\workspace\\Xinchao(Đường dẫn này có thể thay đổi tùy vào cấu hình máy tính và cách bạn thiết lập workspace ban đầu).Trong thư mục dự án:Thư mục src sẽ chứa tập tin mã nguồn Xinchao.java.Thư mục bin sẽ chứa tập tin biên dịch Xinchao.class sau khi chương trình được biên dịch thành công.Ghi chú thêm:Sử dụng Eclipse giúp bạn tiết kiệm rất nhiều thời gian trong quá trình lập trình, nhờ vào khả năng hỗ trợ tự động hoàn thành lệnh, kiểm tra lỗi theo thời gian thực, quản lý dự án rõ ràng, và tích hợp dễ dàng với JDK. Đây là công cụ rất thích hợp cho người mới học Java cũng như các lập trình viên chuyên nghiệp.",
        "Summary": "Bài viết hướng dẫn sử dụng môi trường lập trình tích hợp Eclipse để tạo và chạy chương trình Java đơn giản in ra dòng chữ \"Chao mung den voi lop hoc Java\". Quá trình bao gồm tạo một dự án mới, tạo lớp chứa phương thức `main()`, viết mã nguồn, và biên dịch/chạy chương trình thông qua Eclipse. Eclipse tự động quản lý quá trình biên dịch và hiển thị kết quả, cũng như thông báo lỗi nếu có. Cuối cùng, bài viết mô tả cấu trúc thư mục dự án được tạo ra bởi Eclipse, bao gồm thư mục `src` chứa mã nguồn và thư mục `bin` chứa file `.class` đã biên dịch.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, theo đúng trình tự các bước thực hiện trong văn bản gốc. Các câu liên kết với nhau một cách trôi chảy, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm mục đích của hướng dẫn, các bước thực hiện chính, và cấu trúc thư mục dự án. Không có chi tiết nào thừa hoặc không liên quan được đưa vào."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00173",
        "Article": "2.5 DỮ LIỆU KIỂU CHUỖI TRONG GÓI TIN\n 2.5.1 Định nghĩa\n Dữ liệu kiểu chuỗi trong gói tin (Packet String Data - PSTR) là một thuật ngữ được xác định\n theo cách chọn để sử dụng nó. Đơn giản, nó là một lựa chọn dữ liệu mà con người có thể đọc\n được, lấy từ dữ liệu FPC. Dữ liệu này có thể xuất hiện dưới nhiều hình thức khác nhau. Ví dụ, tạo\n ra dữ liệu PSTR với định dạng cụ thể để diễn tả tiêu đề dữ liệu từ các giao thức tầng ứng dụng\n phổ biến (như HTTP hoặc SMTP), mà không có tải dữ liệu. Một ví dụ của loại hình dữ liệu PSTR\n được thể hiện trong Hình 2.19.\n PTIT\n 54\n Hình 2.19 Log dữ liệu kiểu PSTR cho HTTP request và response\n Hình 2.20 là ví dụ chỉ có một trường duy nhất được lưu trữ.\n Hình 2.20 Log dữ liệu kiểu PSTR chỉ ra một HTTP URL được yêu cầu\n Trong ví dụ này, dữ liệu PSTR chỉ chứa các yêu cầu HTTP URL. Trong khi nhiều tổ chức\n lựa chọn lưu trữ dữ liệu PSTR cho phân tích hồi cứu, ví dụ này đại diện cho dữ liệu được thu thập\n trên cơ sở thời gian thực. Điều này cho phép dữ liệu được sử dụng nhiều hơn, bao gồm cả việc sử\n dụng hiệu quả hơn theo cơ chế phát hiện danh tiếng tự động (được thảo luận trong chương sau).\n Một hình thức khác của dữ liệu PSTR là tập trung vào tải của gói tin sau tiêu đề của giao thức\n ứng dụng. Những thông tin này bao gồm một số lượng giới hạn các byte không phải là nhị phân\n từ tải của gói tin, có thể cho biết mục đích của gói tin. Hình 2.21 là một ví dụ của kiểu dữ liệu.\n Các số liệu trong hình 2.21 thể hiện bản sao của dữ liệu có thể đọc, lấy từ trình duyệt web của\n người dùng. Cụ thể, có thể xem nội dung của trang web được truy cập mà không cần quá nhiều\n chi tiết bổ sung. Cách này hiệu quả cho việc lưu trữ dữ liệu vì không cần phải lưu trữ ký tự không\n đọc được. Bất lợi của việc sử dụng dữ liệu PSTR kiểu tải là chi phí cần thiết để tạo ra nó. Ngoài\n ra cũng cần có một lượng hợp lý các dữ liệu thừa đi cùng với nó.",
        "Summary": "\"Dữ liệu kiểu chuỗi trong gói tin (PSTR) là dữ liệu mà con người có thể đọc được, trích xuất từ dữ liệu FPC. PSTR có thể được sử dụng để diễn tả tiêu đề dữ liệu từ các giao thức tầng ứng dụng (ví dụ: HTTP, SMTP) hoặc chứa các yêu cầu HTTP URL. Một hình thức khác của PSTR là tập trung vào tải của gói tin, chỉ lưu trữ các byte không phải nhị phân, cho biết mục đích của gói tin và nội dung trang web được truy cập. Ưu điểm của PSTR là không cần lưu trữ ký tự không đọc được, nhưng nhược điểm là chi phí tạo ra nó cao và có thể chứa dữ liệu thừa.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ví dụ được đề cập (HTTP, SMTP, HTTP URL) đều được lấy từ văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic, từ định nghĩa PSTR, các ví dụ sử dụng, đến ưu và nhược điểm. Các câu liên kết với nhau một cách trôi chảy, tạo thành một đoạn văn dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc: định nghĩa, các loại dữ liệu PSTR, ưu điểm và nhược điểm. Không có chi tiết nào không cần thiết hoặc dư thừa."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, bao quát đầy đủ các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00174",
        "Article": "Đồng thời, Bộ đẩy mạnh phát triển nguồn nhân lực với việc năm 2018 đánh dấu sự kiện thành lập mạng lƣới đổi mới sáng tạo Việt Nam, quy tụ các chuyên gia công nghệ và cộng đồng AI. Thời gian tới, Bộ sẽ mở rộng và phát triển mạng lƣới tri thức AI ngƣời Việt tại một số quốc gia khác, cũng nhƣ thành lập quỹ Global Fund nhằm đào tạo nguồn nhân lực chất lƣợng cao, đƣa tri thức ngƣời Việt ra thế giới. Đặc biệt, Bộ sẽ hoàn chỉnh hệ sinh thái đổi mới sáng tạo với mục tiêu thành lập Trung tâm khởi nghiệp đổi mới sáng tạo quốc gia tại Khu công nghệ cao Hòa Lạc. Cộng đồng AI Việt Nam trẻ và nhiều tiềm năng phát triển. Cách đây 3 năm, các chuyên gia trong lĩnh vực công nghệ của Việt Nam từ nƣớc ngoài bắt đầu trở về Việt Nam đặt ra yêu cầu phải phát triển trí tuệ AI Việt Nam, đặc biệt là giúp cho cộng đồng AI trẻ đi nhanh hơn, tiếp xúc nhiều hơn với nền trí tuệ nhân tạo thế giới. Trên thế giới, cộng đồng AI đƣợc phát triển khá tự nhiên, gồm 4 trụ cột: những ngƣời làm nghiên cứu, nhà khoa học trong trƣờng, viện nghiên cứu; nhà phát triển công nghệ đến từ các tập đoàn công nghiệp, đội ngũ triển khai ứng dụng và đặc biệt là ngƣời sử dụng các sản phẩm AI. Phân tích về cộng đồng triển khai ứng dụng AI trong các lĩnh vực khác nhau, cứ 30 ngƣời làm về phần cứng và phần mềm thì có một ngƣời làm về AI (chiếm tỷ lệ 3,3%), đội ngũ nhà nghiên cứu, phát triển chỉ chiếm 6%, còn lực lƣợng những ngƣời triển khai ứng dụng và sử dụng trực tiếp chiếm 94%. Tại Việt Nam, đội ngũ tham gia phát triển công nghệ, triển khai ứng dụng có khoảng 700 ngƣời, trong đó nhân lực sử dụng trực tiếp ở mức 650 ngƣời. Nhƣ vậy tổng số hiện có mới chỉ đạt 1.350, trong đó có 300 thạc sĩ trở lên. Nếu so với 180.000 ngƣời làm trong lĩnh vực CNTT thì tỷ lệ rất nhỏ, chỉ khoảng 1/1000 và so với thế giới (3,3%) con số này là quá ít. Tuy nhiên thực trạng này đang dần đƣợc cải thiện.",
        "Summary": "Đặc biệt, Bộ sẽ hoàn chỉnh hệ sinh thái đổi mới sáng tạo với mục tiêu thành lập Trung tâm khởi nghiệp đổi mới sáng tạo quốc gia tại Khu công nghệ cao Hòa Lạc. Cách đây 3 năm, các chuyên gia trong lĩnh vực công nghệ của Việt Nam từ nƣớc ngoài bắt đầu trở về Việt Nam đặt ra yêu cầu phải phát triển trí tuệ AI Việt Nam, đặc biệt là giúp cho cộng đồng AI trẻ đi nhanh hơn, tiếp xúc nhiều hơn với nền trí tuệ nhân tạo thế giới. Phân tích về cộng đồng triển khai ứng dụng AI trong các lĩnh vực khác nhau, cứ 30 ngƣời làm về phần cứng và phần mềm thì có một ngƣời làm về AI chiếm tỷ lệ 3,3%, đội ngũ nhà nghiên cứu, phát triển chỉ chiếm 6%, còn lực lƣợng những ngƣời triển khai ứng dụng và sử dụng trực tiếp chiếm 94%.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được trích dẫn từ văn bản gốc và ghép lại với nhau. Tuy nhiên, vì là trích dẫn nên có thể thiếu sự liên kết chặt chẽ giữa các ý, làm giảm đi một chút tính mạch lạc tổng thể."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào việc phát triển hệ sinh thái đổi mới sáng tạo và tình hình nhân lực AI tại Việt Nam. Tuy nhiên, có thể lược bỏ chi tiết về tỷ lệ người làm AI so với phần cứng/phần mềm để tăng tính súc tích."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và liên quan. Tuy nhiên, để cải thiện, nên tập trung hơn vào việc diễn đạt lại các ý chính thay vì chỉ trích dẫn nguyên văn, và lược bỏ một số chi tiết không quá quan trọng để tăng tính súc tích và mạch lạc."
            }
        }
    },
    {
        "Index": "00175",
        "Article": "AES (Advanced Encryption Standard) là một chuẩn mã hóa dữ liệu được Viện Tiêu chuẩn và Công nghệ Mỹ (NIST) công nhận năm 2001. AES được xây dựng dựa trên Rijndael cipher phát triển và công bố năm 1998 bởi 2 nhà mật mã học người Bỉ là Joan Daemen và Vincent Rijmen. AES là dạng mã hóa khối, với khối dữ liệu vào có kích thước là 128 bit và khóa bí mật với kích thước có thể là 128, 192, hoặc 256 bit. AESđược thiết kế dựa trên mạng hoán vị-thay thế (Substitution-permutation network) và nó có thể cho tốc độ thực thi cao khi cài đặt bằng cả phần mềm và phần cứng. Đặc biệt, giải thuật AES đã được tích hợp vào các bộ vi xử lý gần đây của hãng Intel dưới dạng tập lệnh AES-NI, giúp tăng đáng kể tốc độ thực thi các thao tác mã hóa và giải mã dựa trên AES. AES vận hành dựa trên một ma trận vuông 4x4, được gọi là state (trạng thái). Ma trận này gồm 16 phần tử, mỗi phần tử là 1 byte dữ liệu. State được khởi trị là khối 128 bit bản rõ và qua quá trình biến đổi sẽ chứa khối 128 bit bản mã ở đầu ra. Như đã đề cập, AES hỗ trợ 3 kích thước khóa và kích thước của khóa quyết định số vòng lặp chuyển đổi cần thực hiện để chuyển bản rõ thành bản mã như sau: 10 vòng lặp với khóa 128 bit; 12 vòng lặp với khóa 192 bit; 14 vòng lặp với khóa 256 bit.Mô tả khái quát giải thuật: Giải thuật AES cho mã hóa dữ liệu gồm các bước xử lý chính như sau. Mở rộng khóa (Key Expansion): các khóa vòng (Round key) dùng trong các vòng lặp được sinh ra từ khóa chính AES sử dụng thủ tục sinh khóa Rijndael. Vòng khởi tạo (Initial Round): Thực hiện hàm AddRoundKey, trong đó mỗi byte trong state được kết hợp với khóa vòng sử dụng phép XOR. Các vòng lặp chính (Rounds) Có 4 hàm biến đổi dữ liệu được thực hiện trong mỗi vòng, gồm: SubBytes: hàm thay thế phi tuyến tính, trong đó mỗi byte trong state được thay thế bằng một byte khác sử dụng bảng tham chiếu S-box; ShiftRows: hàm đổi chỗ, trong đó mỗi dòng trong state được dịch một số bước theo chu kỳ; MixColumns: trộn các cột trong state, kết hợp 4 bytes trong mỗi cột; AddRoundKey. Vòng cuối (Final Round): Tương tự các vòng lặp chính, nhưng chỉ thực hiện 3 hàm biến đổi dữ liệu, gồm: SubBytes; ShiftRows; AddRoundKey.",
        "Summary": "AES (Advanced Encryption Standard) là chuẩn mã hóa dữ liệu được NIST công nhận năm 2001, dựa trên Rijndael cipher, với khối dữ liệu 128 bit và khóa bí mật 128, 192 hoặc 256 bit. Giải thuật AES sử dụng mạng hoán vị-thay thế, vận hành qua các vòng lặp gồm các bước: mở rộng khóa, vòng khởi tạo, các vòng lặp chính (SubBytes, ShiftRows, MixColumns, AddRoundKey) và vòng cuối. AES được tối ưu hóa cho cả phần mềm và phần cứng, với tập lệnh AES-NI tích hợp trên vi xử lý Intel để tăng tốc độ thực thi.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ và chính xác nội dung quan trọng nhất về AES."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng cô đọng thông tin một cách hiệu quả, đồng thời vẫn giữ được sự rõ ràng và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00176",
        "Article": "Phương pháp phân vùng (Partition method): Cho một tập hợp n đối tượng, phương pháp phân vùng sẽ xây dựng k phân vùng dữ liệu, trong đó mỗi phân vùng đại diện cho một cụm và k ≤ n. Tức là nó chia dữ liệu thành k nhóm sao cho mỗi nhóm chứa ít nhất một đối tượng. Hầu hết các phương pháp phân vùng đều dựa trên khoảng cách. Cho số lượng k phân vùng, phương pháp phân vùng sẽ tạo ra k phân vùng ban đầu. Sau đó, nó sử dụng kỹ thuật tái định vị, lặp đi lặp lại nhằm cải thiện việc phân vùng bằng cách di chuyển các đối tượng từ nhóm này sang nhóm khác. Tiêu chí chung của một phân vùng tốt là các đối tượng trong cùng một cụm là “gần” hoặc có liên quan với nhau, trong khi các đối tượng trong các cụm khác nhau là “cách xa nhau” hoặc rất khác nhau. Việc đạt được mức tối ưu toàn cục trong phân cụm dựa trên phân vùng thường bị hạn chế về mặt tính toán do không thể xem xét đầy đủ tất cả các khả năng phân vùng có thể. Thay vào đó, hầu hết các ứng dụng đều áp dụng các phương pháp heuristic phổ biến, chẳng hạn như các phương pháp tham lam như giải thuật k-means và k-medoids, giúp cải thiện dần chất lượng phân cụm và đạt đến mức tối ưu cục bộ. Các phương pháp phân cụm heuristic này hoạt động tốt để tìm các cụm hình cầu (spherical-shaped) và với cơ sở dữ liệu có kích thước vừa và nhỏ. pháp phân cụm phân vùng như sau: • Tìm các cụm hình cầu loại trừ lẫn nhau (mỗi điểm dữ liệu thuộc về một cụm) • Dựa trên khoảng cách • Có thể sử dụng giá trị trung bình hoặc medoid để biểu diễn trung tâm cụm • Hiệu quả đối với các tập dữ liệu có kích thước vừa và nhỏ",
        "Summary": "Phương pháp phân vùng chia dữ liệu thành k cụm sao cho các đối tượng trong cùng cụm gần nhau và khác biệt với các cụm khác, thường dựa trên khoảng cách. Các thuật toán heuristic như k-means và k-medoids được sử dụng để cải thiện dần chất lượng phân cụm, đạt tối ưu cục bộ, và hoạt động tốt với dữ liệu kích thước vừa và nhỏ, đặc biệt khi các cụm có dạng hình cầu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc dễ dàng nắm bắt được nội dung chính của phương pháp phân vùng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất của văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, nguyên tắc hoạt động, các thuật toán phổ biến và ưu điểm của phương pháp phân vùng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã chọn lọc và trình bày một cách hiệu quả những thông tin quan trọng nhất từ văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00177",
        "Article": "Quản trị rủi ro là một trong những thành phần quan trọng trong quản lý an toàn thông tin, giúp tổ chức nhận diện, đánh giá và xử lý các nguy cơ có thể ảnh hưởng đến tài sản thông tin. Quá trình quản trị rủi ro bắt đầu bằng việc xác định tài sản thông tin, bao gồm dữ liệu, phần mềm, phần cứng, nhân sự và quy trình. Sau đó, đánh giá các mối đe dọa tiềm ẩn như tấn công mạng, lỗi phần mềm, hành vi người dùng, thiên tai, và xác định lỗ hổng có thể bị khai thác. Mức độ rủi ro được xác định bằng xác suất xảy ra và mức độ ảnh hưởng nếu xảy ra. Các biện pháp xử lý rủi ro có thể gồm: chấp nhận rủi ro nếu ảnh hưởng thấp, giảm thiểu rủi ro bằng biện pháp kỹ thuật hoặc quy trình, chuyển giao rủi ro thông qua bảo hiểm, hoặc tránh rủi ro bằng cách không triển khai hoạt động đó. Việc đánh giá rủi ro nên được thực hiện định kỳ và khi có thay đổi lớn về công nghệ, nhân sự hoặc quy trình. Tổ chức cần xây dựng ma trận rủi ro, phân loại theo mức độ ưu tiên và theo dõi quá trình xử lý. Các tiêu chuẩn như ISO/IEC 27005 cung cấp hướng dẫn chi tiết về đánh giá và quản lý rủi ro trong lĩnh vực an toàn thông tin. Ngoài ra, cần đào tạo nhận thức về rủi ro cho nhân viên, vì hành vi con người là nguyên nhân chính dẫn đến nhiều rủi ro khó kiểm soát. Kết hợp giữa công nghệ, chính sách và quản lý sẽ tạo nên một mô hình quản trị rủi ro hiệu quả, giúp tổ chức phòng ngừa, phản ứng và phục hồi nhanh chóng khi sự cố xảy ra.",
        "Summary": "Quản trị rủi ro là một phần quan trọng trong hệ thống quản lý an toàn thông tin. Nó bao gồm việc xác định, đánh giá và xử lý các mối đe dọa có thể ảnh hưởng đến tài sản thông tin của tổ chức. Mục tiêu là giảm thiểu thiệt hại, đảm bảo hoạt động liên tục và tuân thủ quy định. Quản trị rủi ro hiệu quả cần có sự tham gia của nhiều bộ phận, sử dụng các công cụ đánh giá định lượng và định tính để lập kế hoạch ứng phó phù hợp trong mọi tình huống.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt nhìn chung trung thực, tuy nhiên có một vài chi tiết được diễn giải lại mà không hoàn toàn khớp với văn bản gốc. Ví dụ, bản tóm tắt đề cập đến 'mục tiêu là giảm thiểu thiệt hại, đảm bảo hoạt động liên tục và tuân thủ quy định', trong khi văn bản gốc không trực tiếp đề cập đến việc 'tuân thủ quy định' như một mục tiêu cụ thể của quản trị rủi ro. Ngoài ra, việc 'sử dụng các công cụ đánh giá định lượng và định tính' không được đề cập trực tiếp trong văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu văn liên kết với nhau một cách logic và dễ hiểu. Tuy nhiên, có thể cải thiện bằng cách làm rõ hơn mối liên hệ giữa các ý, ví dụ như giải thích cụ thể hơn về cách các công cụ đánh giá định lượng và định tính được sử dụng để lập kế hoạch ứng phó."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính của văn bản gốc, như định nghĩa quản trị rủi ro, mục tiêu và các bước cơ bản. Tuy nhiên, có một vài chi tiết có thể được coi là ít liên quan hơn, ví dụ như việc nhấn mạnh 'sự tham gia của nhiều bộ phận' mà không giải thích rõ vai trò của họ trong quá trình quản trị rủi ro."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, đã nắm bắt được các ý chính của văn bản gốc. Tuy nhiên, cần chú ý hơn đến tính trung thực bằng cách đảm bảo mọi thông tin đều có nguồn gốc rõ ràng từ văn bản gốc. Đồng thời, có thể cải thiện tính mạch lạc bằng cách làm rõ hơn mối liên hệ giữa các ý và loại bỏ một số chi tiết ít liên quan để tập trung vào những điểm quan trọng nhất."
            }
        }
    },
    {
        "Index": "00178",
        "Article": "Chẳng hạn, chuỗi token phiên đƣợc biểu diễn dƣới dạng số hexa nhƣ sau: Sau khi chuyển thành mã ASCII trở thành: Các token phiên dễ đoán thƣờng gặp bao gồm các token đƣợc che dấu thứ tự, token phụ thuộc thời gian và token đƣợc tạo sử dụng số ngẫu nhiên yếu. Các token thuộc các dạng trên đều dễ dàng bị tìm ra quy luật, hoặc giải thuật sinh thông qua một số bƣớc phân tích. Khi tin tặc nắm đƣợc giải thuật sinh token, hắn có thể tạo nhiều token và đƣa vào yêu cầu gửi lên máy chủ để chiếm phiên làm việc của ngƣời dùng. Hình 3.9 minh họa một token phiên dễ đoán phụ thuộc thời gian, trong đó token là một chuỗi ghép từ 2 thành phần: một chỉ số tuần tự và thời gian hiện tại của hệ thống tính Hình 3.9. Một token dễ đoán phụ thuộc thời gian c. Các điểm yếu trong sử dụng token phiên Rò rỉ token trên mạng Các token phiên đƣợc truyền từ máy chủ đến trình duyệt và ngƣợc lại nếu không đƣợc mã hóa có thể bị nghe trộm, đánh cắp dễ dàng, nhƣ minh họa trên Hình 3.10. Ngoài ra, một số trang sử dụng giao thức HTTPS, nhƣng vẫn có nhúng một số thành phần liên kết đến các địa chỉ sử dụng HTTP, tin tặc vẫn có thể chặn bắt token của phiên thông qua các thành phần giao tiếp thông qua HTTP. Do vậy, lời khuyên là nên sử dụng tất cả các thành phần từ các địa chỉ URL trên giao thức HTTPS. Hình 3.10. Token phiên có thể bị rò rỉ trên mạng khi không được mã hóa Rò rỉ token trong ghi log Token phiên cũng có thể bị rò rỉ trong quá trình ghi log của các thành phần trong ứng dụng web. Một số ứng dụng web ghi log truy nhập gồm cả token của phiên nếu nhƣ token đƣợc đƣa vào URL của trang. Log có thể đƣợc ghi ở phía trình duyệt, ở phía máy chủ web, hoặc log của proxy đứng giữa máy chủ và trình duyệt web.",
        "Summary": "Khi tin tặc nắm đƣợc giải thuật sinh token, hắn có thể tạo nhiều token và đƣa vào yêu cầu gửi lên máy chủ để chiếm phiên làm việc của ngƣời dùng. Token phiên có thể bị rò rỉ trên mạng khi không được mã hóa Rò rỉ token trong ghi log Token phiên cũng có thể bị rò rỉ trong quá trình ghi log của các thành phần trong ứng dụng web. Một số ứng dụng web ghi log truy nhập gồm cả token của phiên nếu nhƣ token đƣợc đƣa vào URL của trang.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu liên kết với nhau một cách logic. Tuy nhiên, có thể cải thiện bằng cách thêm một câu giới thiệu ngắn gọn về chủ đề chính trước khi đi vào chi tiết."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính về cách tin tặc có thể lợi dụng token và các nguy cơ rò rỉ token. Tuy nhiên, có thể lược bỏ một số chi tiết nhỏ để bản tóm tắt ngắn gọn hơn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, trung thực và liên quan đến nội dung gốc. Điểm cần cải thiện là tăng tính mạch lạc bằng cách thêm câu mở đầu và lược bỏ một vài chi tiết nhỏ để tăng tính súc tích."
            }
        }
    },
    {
        "Index": "00179",
        "Article": "Bối cảnh Thông thường một chương trình được lưu trữ trên đĩa như một tập tin nhị phân có thể xử lý Để thực hiện chương trình cần nạp chương trình vào bộ nhớ chính tạo lập tiến trình tương ứng để xử lý Hàng đợi nhập hệ thống là tập hợp các chương trình trên đĩa đang chờ được nạp vào bộ nhớ để tiến hành xử lý Các địa chỉ trong chương trình nguồn là địa chỉ tượng trưng vì thế một chương trình phải trải qua nhiều giai đoạn xử lý để chuyển đổi các địa chỉ này thành các địa chỉ tuyệt đối trong bộ nhớ chính Có thể thực hiện kết buộc các chỉ thị và dữ liệu với các địa chỉ bộ nhớ vào một trong những thời điểm sau Thời điểm biên dịch nếu tại thời điểm biên dịch có thể biết vị trí mà tiến trình sẽ thường trú trong bộ nhớ trình biên dịch có thể phát sinh ngay mã với các địa chỉ tuyệt đối Tuy nhiên nếu về sau có sự thay đổi vị trí thường trú lúc đầu của chương trình cần phải biên dịch lại chương trình Thời điểm nạp nếu tại thời điểm biên dịch chưa thể biết vị trí mà tiến trình sẽ thường trú trong bộ nhớ trình biên dịch cần phát sinh mã tương đối translatable Sự liên kết địa chỉ được trì hoãn đến thời điểm chương trình được nạp vào bộ nhớ lúc này các địa chỉ tương đối sẽ được chuyển thành địa chỉ tuyệt đối do đã biết vị trí bắt đầu lưu trữ tiến trình Khi có sự thay đổi vị trí lưu trữ chỉ cần nạp lại chương trình để tính toán lại các địa chỉ tuyệt đối mà không cần biên dịch lại Thời điểm xử lý nếu có nhu cầu di chuyển tiến trình từ vùng nhớ này sang vùng nhớ khác trong quá trình tiến trình xử lý thì thời điểm kết buộc địa chỉ phải trì hoãn đến tận thời điểm xử lý Để thực hiện kết buộc địa chỉ vào thời điểm xử lý cần sử dụng cơ chế phần cứng đặc biệt",
        "Summary": "Chương trình cần chuyển đổi địa chỉ tượng trưng thành địa chỉ tuyệt đối trong bộ nhớ chính, với ba thời điểm kết buộc địa chỉ: biên dịch (tạo mã với địa chỉ tuyệt đối, cần biên dịch lại nếu vị trí thay đổi), nạp (chuyển địa chỉ tương đối thành tuyệt đối khi nạp vào bộ nhớ), và xử lý (kết buộc địa chỉ tại thời điểm xử lý, yêu cầu phần cứng đặc biệt để hỗ trợ di chuyển tiến trình).",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và logic, dễ hiểu. Cách diễn đạt súc tích, tập trung vào các điểm chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về quá trình chuyển đổi địa chỉ và ba thời điểm kết buộc địa chỉ, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00180",
        "Article": "3.2.2. Control System Toolbox\n Control System Toolbox cung cấp các thuật toán chuẩn công nghiệp và các ứng dụng để phân tích mang tính hệ thống, thiết kế, và điều chỉnh các hệ thống điều khiển tuyến tính. Ta có thể định nghĩa hệ thống bằng một hàm truyền đạt, không gian trạng thái, điểm không – điểm cực – độ lợi, hoặc mô hình đáp ứng tần số. Các ứng dụng và các hàm, ví dụ như hàm vẽ đáp ứng nhảy bậc và đồ thị Bode, cho phép chúng ta hình dung được hoạt động của hệ thống trong miền thời gian và miền tần số. Ta có thể điều chỉnh các tham số bù sử dụng bộ điều khiển tự động PID, phương pháp quỹ tích gốc, thiết kế LQR/LQG và các kỹ thuật tương tác và điều khiển khác. Ta có thể kiểm tra thiết kế bằng cách thay đổi thời gian quá độ, độ quá điều chỉnh lượng dự trữ pha và độ lợi và các yêu cầu khác.\n Các chức năng chính của Control System Toolbox\n • Hàm truyền đạt, không gian trạng thái, điểm cực – điểm không – độ lợi, và các mô hình đáp ứng tần số của các hệ thống tuyến tính\n • Các kết nối nối tiếp, song song, hồi tiếp và các kết nối sơ đồ khối tổng quát của các mô hình tuyến tính.\n • Đáp ứng nhảy bậc, vẽ tiêu chuẩn Nyquist, và các công cụ phân tích tính ổn định và thông số hoạt động trong miền thời gian và miền tần số\n • Quỹ tích gốc, đồ thị Bode, LQR, LQG, và các kỹ thuật thiết kế hệ thống điều khiển cổ điển và theo không gian trạng thái\n • Tự động điều chỉnh các bộ điều khiển PID\n • Chuyển đổi mô hình biểu diễn, rời rạc hóa mô hình liên tục theo thời gian, và xấp xỉ bậc thấp cho các hệ thống bậc cao.\n • Các thuật toán LAPACK và SLICOT để tối ưu độ chính xác và hoạt động.",
        "Summary": "Control System Toolbox cung cấp các thuật toán và ứng dụng để phân tích, thiết kế và điều chỉnh hệ thống điều khiển tuyến tính, cho phép định nghĩa hệ thống bằng nhiều mô hình khác nhau (hàm truyền đạt, không gian trạng thái,...). Toolbox này cung cấp các công cụ trực quan hóa hoạt động của hệ thống trong miền thời gian và tần số, cũng như các phương pháp điều chỉnh tham số bù (PID, quỹ tích gốc, LQR/LQG). Các chức năng chính bao gồm các mô hình hệ thống tuyến tính, kết nối sơ đồ khối, công cụ phân tích ổn định, kỹ thuật thiết kế hệ thống điều khiển, tự động điều chỉnh PID, chuyển đổi mô hình và các thuật toán tối ưu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Bản tóm tắt đã làm nổi bật được những thông tin quan trọng nhất về Control System Toolbox một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00181",
        "Article": "Hệ thống file FAT được thiết kế ban đầu để sử dụng trong hệ điều hành DOS, và sau đó đã được sử dụng trong một số phiên bản của hệ điều hành Windows như Windows 3.0, 3.1, 95/98, ME. Hiện nay, FAT không được dùng làm hệ thống file cho đĩa cứng trong những phiên bản mới nhất của Windows do có một số nhược điểm như tốc độ và độ tin cậy không cao, không hỗ trợ cơ chế bảo mật. Tuy nhiên, FAT vẫn là hệ thống file thông dụng nhất, được sử dụng trong hầu hết các hệ điều hành hiện nay để quản lý thẻ nhớ, đĩa mềm, đĩa CD, và được sử dụng như phương tiện trung gian thuận tiện khi cần trao đổi file giữa các hệ điều hành khác nhau. Ngoài ra, rất nhiều hệ thống nhúng sử dụng FAT để quản lý file do sự đơn giản của hệ thống file này. Hệ thống file FAT có ba phiên bản là FAT12, FAT16, và FAT32, trong đó chữ số sau phần chữ chỉ kích thước ô của bảng FAT tương ứng là 12, 16, và 32 bit. Hiện nay, đa số FAT được sử dụng cho đĩa cứng là FAT32, trong khi FAT16 được sử dụng cho thiết bị nhớ ngoài có dung lượng nhỏ hơn như CD, thẻ nhớ ngoài. Đĩa lôgic: Đơn vị tổ chức trong hệ thống file FAT là đĩa lôgic (logical disk). Đối với đĩa cứng, toàn bộ đĩa được chia thành các vùng (partition), bao gồm vùng chính (primary partition) và vùng mở rộng (extended partition). Vùng mở rộng được chia tiếp thành một số đĩa lô gic. Bản thân vùng chính cũng được coi là đĩa lô gic với khác biệt là có thể khởi động hệ điều hành từ đây. Đối với thiết bị nhớ ngoài khác, mỗi đĩa mềm, CD, thẻ nhớ ngoài được coi là một đĩa lô gic với đầy đủ cấu trúc quản lý đĩa lô gic của mình. Đĩa lô gic được đặt tên bằng các chữ cái A,B,C,D, v.v. với một số quy ước như A là ổ đĩa mềm, C là đĩa lô gic đầu tiên trên ổ cứng. Đơn vị cấp phát không gian trên đĩa (khối lô gic) là cluster. Mỗi cluster chứa một số lượng sector bằng lũy thừa của 2. Kích thước cluster cùng với phiên bản FAT (12, 16, hay 32) quyết định kích thước tối đa của đĩa lô gic mà FAT có thể quản lý. Thông thường, kích thước cluster nằm trong khoảng tự 512B đến 32KB.",
        "Summary": "Hệ thống file FAT, ban đầu được thiết kế cho DOS và sau đó dùng trong các phiên bản Windows cũ, hiện ít được dùng cho ổ cứng do hạn chế về tốc độ, độ tin cậy và bảo mật. Tuy nhiên, FAT vẫn là hệ thống file phổ biến cho thẻ nhớ, đĩa mềm, CD và trao đổi file giữa các hệ điều hành khác nhau, cũng như trong các hệ thống nhúng nhờ tính đơn giản. Có ba phiên bản FAT (FAT12, FAT16, FAT32), với FAT32 chủ yếu dùng cho ổ cứng và FAT16 cho thiết bị nhớ ngoài nhỏ hơn. Đơn vị tổ chức trong FAT là đĩa logic, được chia thành các vùng (partition) trên đĩa cứng. Đơn vị cấp phát không gian là cluster, kích thước cluster (từ 512B đến 32KB) và phiên bản FAT quyết định kích thước tối đa của đĩa logic được quản lý.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc có thể dễ dàng theo dõi và hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Nhờ đó, bản tóm tắt tập trung vào trọng tâm và truyền tải thông tin một cách hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin tốt, giúp người đọc nhanh chóng nắm bắt được nội dung cốt lõi của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00182",
        "Article": "Ghép nối là độ đo sự nối ghép với nhau giữa các đơn vị (module) của hệ thống. Hệ thống có nối ghép cao thì các module phụ thuộc lẫn nhau lớn. Hệ thống nối ghép lỏng lẻo thì các module là độc lập hoặc là tương đối độc lập với nhau và chúng ta sẽ dễ bảo trì nó. Các module được ghép nối chặt chẽ nếu chúng dùng các biến chung và nếu chúng trao đổi các thông tin điều khiển (ghép nối chung nhau và ghép nối điều khiển). Ghép nối lỏng lẻo đạt được khi bảo đảm rằng các thông tin cục bộ được che dấu trong các module và các module trao đổi thông tin thông qua danh sách tham số (giao diện) xác định. Có thể chia ghép nối thành các mức từ chặt chẽ đến lỏng lẻo như sau: a. Ghép nối nội dung: hai hay nhiều module dùng lẫn dữ liệu của nhau, đây là mức xấu nhất, thường xảy ra đối với các ngôn ngữ mức thấp dùng các dữ liệu toàn cục hay lạm dụng lệnh GOTO. b. Ghép nối chung: một số module dùng các biến chung, nếu xảy ra lỗi thao tác dữ liệu, sẽ khó xác định được lỗi đó do module nào gây ra. c. Ghép nối điều khiển: một module truyền các thông tin điều khiển để điều khiển hoạt động của một module khác. d. Ghép nối dư thừa: module nhận thông tin thừa không liên quan trực tiếp đến chức năng của nó, điều này sẽ làm giảm khả năng thích nghi của module đó. e. Ghép nối dữ liệu: Các module trao đổi thông tin thông qua tham số và giá trị trả lại. f. Ghép nối không có trao đổi thông tin: module thực hiện một chức năng độc lập và hoàn toàn không nhận tham số và không có giá trị trả lại. Ưu việt của thiết kế hướng đối tượng là do bản chất che dấu thông tin của đối tượng dẫn tới việc tạo ra các hệ ghép nối lỏng lẻo. Việc thừa kế trong hệ thống hướng đối tượng lại dẫn tới một dạng khác của ghép nối, ghép nối giữa đối tượng mức cao và đối tượng kế thừa nó.",
        "Summary": "Độ ghép nối đo lường mức độ phụ thuộc lẫn nhau giữa các module trong hệ thống. Hệ thống ghép nối lỏng lẻo dễ bảo trì hơn hệ thống ghép nối cao. Có nhiều mức độ ghép nối, từ chặt chẽ (ghép nối nội dung, ghép nối chung, ghép nối điều khiển) đến lỏng lẻo (ghép nối dữ liệu, ghép nối không có trao đổi thông tin). Thiết kế hướng đối tượng, với khả năng che giấu thông tin, thường tạo ra các hệ thống ghép nối lỏng lẻo, tuy nhiên việc thừa kế có thể tạo ra một dạng ghép nối giữa đối tượng cha và đối tượng con.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy và kiểm chứng trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ định nghĩa về ghép nối, ưu điểm của ghép nối lỏng lẻo, các mức độ ghép nối, đến ảnh hưởng của thiết kế hướng đối tượng. Các câu liên kết với nhau một cách trôi chảy, tạo thành một đoạn văn dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa, ưu điểm, các loại ghép nối và ảnh hưởng của hướng đối tượng. Các chi tiết không quan trọng đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách rõ ràng và súc tích. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00183",
        "Article": "CHƯƠNG VI: LÀM VIỆC VỚI BỘ LỌC - FILTER\n Adobe Photoshop cung cấp cho bạn một số lượng khổng lồ các bộ lọc để tạo các hiệu ứng đặc biệt\n cho bản thiết kế của bạn. Các bộ lọc này được chia ra thành các nhóm theo chức năng, bao gồm:\n • Nhóm Artistic\n • Nhóm Blur\n • Nhóm Brush Strokes\n • Nhóm Distort\n • Nhóm Noise\n • Nhóm Pixelate\n • Nhóm Render\n • Nhóm Shapen\n • Nhóm Sketch\n • Nhóm Stylize\n • Nhóm Texture\n • Nhóm Video\n • Nhóm Other\n Có 3 kiểu bộ lọc chính là:\n • Bộ lọc một bước (One - Step filter)\n • Bộ lọc tham số (Parameter filter)\n • Bộ lọc ứng dụng mini (Mini - application filter)\n Giải thích về 3 kiểu bộ lọc:\n Bộ lọc một bước (One - Step filter):\n Áp dụng bô lọc không có sự điều khiển tham số của người sử dụng, kết quả là không thể can\n thiệp, người sử dụng chỉ có thể chọn bộ lọc rồi sử dụng, không thể thay đổi các tham số của\n bộ lọc. Ví dụ như bô lọc Blur...\n Bộ lọc tham số (Parameter filter):\n Cho phép bạn định rõ các giá trị tại các trường hay tại các con trượt trước khi nhấp OK để\n áp dụng bộ lọc. Đa phần các bộ lọc trong Adobe Photoshop đều thuộc dạng này.\n Bộ lọc ứng dụng mini (Mini - application filter)\n Là bộ lọc cho phép người dùng lưu và gọi lại các xác lập, tạo ra môi trường riêng bên trong\n Photoshop. Nhiều bộ lọc của bên thứ ba (tức là bộ lọc không phải của Adobe) là dạng này.\n Loại bộ lọc\n Các bộ lọc có thể được phân chia thành nhiều loại chung. Hai loại cơ bản nhất là Production vàSpecial Effects. Bộ lọc hướng sản xuất được dùng để chỉnh màu hoặc hiệu chỉnh tiêu điểm giúp\n chuẩn bị hình ảnh để in. Bộ lọc hiệu ứng đặc biệt thay đổi hình ảnh theo cách thức không hiện\n thực. Loại này còn được chia nhỏ thành các loại sau:\n • Pre-Press: bộ lọc giúp chuẩn bị hình ảnh để in\n • Special Effects: mục đích thay đổi hình ảnh theo chiều hướng nghệ thuật hơn là hiện thực\n • Color Change: thay đổi các giá trị màu trong hình ảnh\n • Deformation: thay đổi dạng hình học của hình ảnh bằng cách uốn, vặn, thu nhỏ vv...\n • Displacement: sử dụng hình ảnh khác hoặc một thuật toán cài sẵn làm ánh xạ để điều khiển\n sự biến dạng hình ảnh gốc. Làm cho hình ảnh đó có dáng vẻ như được chiếu qua kiểu bề mặt\n khác, chẳng hạn như nước hay thủy tinh...\n • Destructive: thay thế hình ảnh với hiệu ứng riêng, hình ảnh gốc không tác động đến kết quả lọc.\n • Distressed: hình ảnh gốc thay đổi hiệu ứng bộ lọc, nhưng hình ảnh được lọc không dễ nhận\n biết được.\n • Focus: thay đổi tiêu điểm của hình ảnh, làm cho hình ảnh trở nên nhòe hơn hay sắc nét hơn.\n • Stylizing: tạo hiệu ứng trừu tượng và tạo phiên bản cách điệu hóa của ảnh gốc.\n • Texture: tạo mẫu kết cấu chất liệu\n • 3D: tạo chiều thứ 3 cho hình ảnh.",
        "Summary": "Adobe Photoshop cung cấp nhiều bộ lọc chia theo nhóm chức năng (Artistic, Blur,...) để tạo hiệu ứng đặc biệt. Có ba kiểu bộ lọc chính: một bước (áp dụng trực tiếp), tham số (cho phép tùy chỉnh giá trị) và ứng dụng mini (cho phép lưu và gọi lại cài đặt). Các bộ lọc còn được phân loại thành Production (chỉnh sửa ảnh để in) và Special Effects (thay đổi ảnh theo hướng nghệ thuật), với các loại nhỏ hơn như Pre-Press, Color Change, Deformation, Displacement, Destructive, Distressed, Focus, Stylizing, Texture, và 3D.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các loại bộ lọc, cách chúng hoạt động và các phân loại chính, đúng trọng tâm của chương VI."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ về nội dung chính của chương VI. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00184",
        "Article": "* Một vài thuật ngữ:\n - Mảng: là một tập hợp các số, được gọi là các ‗phần tử ‘ hay các ‗đầu số‘, được biết đến với một hoặc nhiều chỉ số chạy suốt các tập hợp chỉ số. Trong MATLAB, các tập hợp chỉ số luôn là chuỗi số nguyên tố bắt đầu bằng 1.\n - Số chiều của một mảng là số các chỉ số cần thiết để định nghĩa một phần tử trong mảng. Chẳng hạn mảng 2 chiều sẽ cần 2 chỉ số i và j để đặc trưng cho một phần tử của mảng.\n - Kích thước của mảng là một danh sách các kích thước của các tập hợp chỉ số\n - Ma trận là một mảng hai chiều (kích thước m x n với các quy luật đặt biệt cho phép cộng, nhân và các tính toán khác. Nó đặc trưng cho một sự biến đổi tuyến tính về toán học. Hai chiều của ma trận là hàng và cột (m hàng và n cột ) .\n - Véctơ là một ma trận mà một chiều chỉ có chỉ số = 1. Cụ thể, một véctơ hàng là một ma trận chỉ có một hàng (kích thước 1 x n), còn một véctơ cột là một ma trận chỉ có một cột (kích thước m x 1).\n - Mặc dù khái niệm mảng tổng quát hơn và ít tính chất toán học hơn một ma trận, nhưng hai thuật ngữ này vẫn thường được dùng lẫn với nhau. Hơn nữa, MATLAB đôi khi không có một sự phân biệt chính thức nào, thậm chí là giữa một đại lượng vô hướng và một ma trận kích thước 1x1.\n - Các lệnh có thể được sắp xếp theo sự phân biệt giữa mảng/ma trận, nhưng MATLAB thường cho phép ta sử dụng chúng lẫn lộn một cách thoải mái. Ý tưởng ở đây (và bất cứ chỗ nào khác) là MATLAB muốn giữ cho ngôn ngữ của mình đơn giản và tự nhiên, để ta có thể tự mình tránh khỏi các rắc rối.\n - Các phần tử đơn lẻ trong ma trận có thể được tiếp cận và sửa đổi bằng cách sử dụng chỉ số phần tử (subscripting). Trong MATLAB, phần tử thứ i của véctơ V được biểu diễn bằng ký hiệu V(i), chỉ số được viết trong ngoặc đơn",
        "Summary": "\"Trong MATLAB, mảng là tập hợp các phần tử được xác định bằng một hoặc nhiều chỉ số số nguyên, bắt đầu từ 1. Số chiều của mảng là số chỉ số cần thiết để định nghĩa một phần tử, kích thước của mảng là danh sách kích thước của các tập hợp chỉ số. Ma trận là mảng hai chiều, véctơ là ma trận có một chiều bằng 1. MATLAB thường dùng lẫn lộn các thuật ngữ mảng và ma trận để đơn giản hóa ngôn ngữ, và cho phép truy cập, sửa đổi các phần tử bằng cách sử dụng chỉ số trong ngoặc đơn.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tính súc tích và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan đến văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00185",
        "Article": "Việc quản lý nguồn nước đang trở thành một thách thức lớn trong bối cảnh phát triển kinh tế - xã hội và ứng phó với biến đổi khí hậu. Internet vạn vật (IoT) và Dữ liệu lớn (Big Data) đóng vai trò quan trọng trong việc giám sát, tối ưu hóa và nâng cao hiệu quả sử dụng tài nguyên nước. Hiện nay, IoT đang được áp dụng rộng rãi để giám sát mạng lưới nước, giúp phát hiện sớm các sự cố và giảm thiểu thất thoát nước. Trên toàn cầu, lượng nước rò rỉ trung bình chiếm từ 30% - 35%, thậm chí ở một số khu vực lên đến 50% - 60%, gây thất thoát doanh thu nghiêm trọng cho các công ty cấp nước. Đồng hồ thông minh IoT ra đời đã giúp theo dõi lượng tiêu thụ nước theo thời gian thực, phát hiện nhanh chóng tình trạng thất thoát và hỗ trợ quản lý hiệu quả hơn. Ngoài ra, IoT còn được ứng dụng trong hệ thống cảnh báo thiên tai, như Alerta Rio tại Brazil, giúp giám sát lượng mưa và điều phối ứng phó kịp thời. Tại Việt Nam, Công ty Thoát nước Hà Nội đã triển khai trung tâm giám sát thoát nước và ứng dụng HSDC Maps giúp người dân cập nhật thông tin về ngập úng, mưa giông và tìm đường đi tránh ngập. Trong lĩnh vực giám sát nước thải, nhiều thành phố trên thế giới đã triển khai các hệ thống IoT để kiểm soát ô nhiễm. Chẳng hạn, TP. Holon (Israel) sử dụng thiết bị SmartScan 50 để theo dõi mực nước thải và gửi cảnh báo khi có sự cố, trong khi TP. Murcia (Tây Ban Nha) áp dụng cảm biến không dây để giám sát nồng độ nitrit và nitrat trong nước thải với độ chính xác cao. Nhờ IoT, dữ liệu thu thập được phân tích nhanh chóng, giúp nâng cao khả năng kiểm soát ô nhiễm. Tuy nhiên, ứng dụng IoT và Big Data cũng đặt ra thách thức về bảo mật, quyền riêng tư và khả năng xử lý dữ liệu lớn. Bên cạnh đó, nguy cơ gia tăng bất bình đẳng do sự chênh lệch về khả năng tiếp cận công nghệ cũng là một vấn đề cần lưu ý. Để khai thác tối đa tiềm năng của IoT trong quản lý nước, cần có chính sách hỗ trợ, đầu tư vào hạ tầng công nghệ và nâng cao nhận thức cộng đồng về ứng dụng khoa học kỹ thuật vào quản lý tài nguyên nước một cách bền vững.",
        "Summary": "iot và big data đang đóng vai trò then chốt trong việc giám sát và tối ưu hóa quản lý nguồn nước, giúp phát hiện sớm sự cố, giảm thất thoát và nâng cao hiệu quả sử dụng tài nguyên. tuy nhiên, việc triển khai công nghệ này vẫn đối mặt với thách thức về bảo mật, xử lý dữ liệu và bất bình đẳng trong tiếp cận công nghệ, đòi hỏi sự đầu tư đồng bộ và chính sách hỗ trợ phù hợp.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic chặt chẽ. Câu văn dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào vai trò của IoT và Big Data trong quản lý nguồn nước, cũng như các thách thức và yêu cầu để triển khai hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt ngắn gọn, đầy đủ ý chính, trung thực, mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00186",
        "Article": "3.3.6 Các luật IDS\n 3.3.6.1 Phân tích về luật\n Cú pháp sử dụng bởi các luật Snort và Suricata là vô cùng linh hoạt, nhưng nó đòi hỏi các\n thông lệ nhất định phải được tuân thủ. Ví dụ về một luật rất đơn giản:\n alert tcp $EXTERNAL_NET 80 - > $HOME_NET any (msg:”Users Downloading Evil);\n content:”evil”; sid:55555555; rev:1;)\n Luật này là rất cơ bản là sẽ tạo ra một cảnh báo nếu một người dùng trên mạng nội bộ tải dữ\n liệu từ một máy chủ web có chứa từ \"evil\". Tất nhiên, việc phát hiện khi người dùng tải về những\n dữ liệu xấu từ Internet không phải là dễ dàng.\n PTIT\n 94\n Trước khi kiểm tra từng thành phần cụ thể của luật này, cần thấy rằng các luật có hai phần\n riêng biệt: tiêu đề luật và các tùy chọn. Các tiêu đề luật là các mục trước dấu ngoặc, và các tùy\n chọn là các mục trong dấu ngoặc đơn (xem Hình 3.19).\n Hình 3.19 Phân tích luật cơ bản\n a. Tiêu đề luật\n Tiêu đề luật luôn luôn là phần đầu tiên của luật và nó là phần bắt buộc của luật. Tiêu đề có\n nhiệm vụ xác định \"ai\" có liên quan tới mẫu lưu lượng. Tất cả mọi thứ được định nghĩa trong tiêu\n đề luật có thể được tìm thấy trong tiêu đề của gói tin. Chúng rất quan trọng trong việc phân tích\n các luật này. Các thành phần trong tiêu đề luật được thể hiện trong Hình 3.20.\n Hình 3.20 Phần tiêu đề luật IDS\n Tiêu đề luật thường bao gồm các thành phần tương tự nhau: hành động của luật, giao thức,\n máy tính nguồn/đích, cổng nguồn/đích, và hướng lưu lượng.\n Hành động của luật. Phần đầu tiên của bất kỳ luật nào là khai báo hành động để báo cho\n IDS engine phải làm gì khi có cảnh báo. Có ba hành động có thể có:\n · Cảnh báo: Báo cho IDS engine ghi log các luật tìm thấy kết quả phù hợp, và các dữ liệu\n gói tin liên quan kết quả. Đây là hành động luật phổ biến nhất.\n · Ghi log: Báo cho IDS engine ghi log các luật tìm thấy kết quả phù hợp, nhưng không log\n lại dữ liệu gói tin liên quan.\n · Bỏ qua: Báo cho IDS engine không xử lý các gói tin.",
        "Summary": "Luật IDS (Hệ thống phát hiện xâm nhập) bao gồm hai phần chính: tiêu đề luật và các tùy chọn. Tiêu đề luật, phần bắt buộc, xác định các yếu tố liên quan đến mẫu lưu lượng dựa trên thông tin tiêu đề gói tin, bao gồm hành động của luật (cảnh báo, ghi log hoặc bỏ qua), giao thức, máy tính nguồn/đích, cổng nguồn/đích và hướng lưu lượng. Các tùy chọn nằm trong dấu ngoặc đơn. Một ví dụ đơn giản về luật là cảnh báo khi người dùng tải dữ liệu chứa từ \"evil\" từ một máy chủ web.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Nội dung tóm tắt tập trung vào cấu trúc và chức năng của luật IDS, cũng như các thành phần chính của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về các luật IDS. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00187",
        "Article": "Trong Arduino, việc sử dụng xung PWM được thực hiện dễ dàng thông qua hàm analogWrite(). Hàm này giúp điều chỉnh độ rộng xung, từ đó thay đổi chu kỳ xung PWM và điều khiển các thiết bị điện tử như LED, động cơ, hoặc các thiết bị khác. Cụ thể, hàm analogWrite(pin, value) nhận hai tham số: pin là chân Arduino nơi tín hiệu PWM được xuất ra và value là giá trị từ 0 đến 255, đại diện cho độ rộng xung (duty cycle). Tùy vào giá trị của value, bạn sẽ có các mức chu kỳ xung khác nhau. Ví dụ, analogWrite(0) tương ứng với chu kỳ xung là 0%, có nghĩa là không có điện áp dương; analogWrite(64) tương ứng với chu kỳ xung là 25%, tức là tín hiệu có mức điện áp cao trong 25% thời gian của chu kỳ xung và thấp trong 75% thời gian; analogWrite(127) là 50%, nghĩa là tín hiệu có mức điện áp cao trong một nửa chu kỳ; analogWrite(191) là 75%; và analogWrite(255) là 100%, tức là tín hiệu luôn ở mức điện áp cao. Arduino sử dụng tần số cố định cho xung PWM tùy theo từng chân, ví dụ trên board Arduino Uno, các chân 3, 9, 10, và 11 có tần số xung là 490Hz, còn các chân 5 và 6 có tần số xung là 980Hz. Với việc sử dụng hàm analogWrite(), bạn có thể dễ dàng điều chỉnh độ sáng của LED, tốc độ của động cơ hoặc các ứng dụng khác yêu cầu điều khiển công suất điện. Ví dụ, trong bài tập ứng dụng điều chỉnh độ sáng của LED qua giao tiếp serial, bạn có thể thay đổi độ rộng xung PWM để điều chỉnh độ sáng của LED từ tối đến sáng tùy theo giá trị nhập vào từ serial",
        "Summary": "Hàm analogWrite() trong Arduino được sử dụng để tạo ra xung PWM, giúp điều chỉnh độ rộng xung (duty cycle) và điều khiển các thiết bị như LED, động cơ. Hàm này nhận hai tham số: chân PWM và giá trị từ 0 đến 255, tương ứng với các mức chu kỳ xung khác nhau. Arduino sử dụng tần số cố định cho các chân PWM, ví dụ chân 3, 9, 10 và 11 có tần số 490Hz, trong khi chân 5 và 6 có tần số 980Hz.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Ví dụ, các ví dụ cụ thể về giá trị analogWrite và chu kỳ xung tương ứng đã được lược bỏ, tập trung vào ý chính về chức năng và tham số của hàm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày các ý chính một cách hiệu quả."
            }
        }
    },
    {
        "Index": "00188",
        "Article": "1.1.3. Lịch sử hình thành và phát triển của thiết bị di động Mỗi loại đầu cuối di động đều có lịch sử hình thành và phát triển riêng. Trong phạm vi bài giảng này sẽ nêu ra lịch sử hình thành và phát triển của điện thoại di động, một loại đầu cuối di động phổ biến không thể thiếu trong cuộc sống con người Ngày 10/3/1876 được coi là mốc son đánh dấu sự ra đời của điện thoại. Cha đẻ của chiếc điện thoại đầu tiên là Alexander Graham Bell người Scottish-Scốt lan, đã được trao bằng sáng chế đầu tiên của Mỹ cho việc phát minh ra điện thoại. Chiếc máy thô sơ có thể truyền được giọng nói này đã mở ra một kỷ nguyên phát triển mới trong lịch sử thông tin liên lạc, thay thế cho điện tín. Hình 1.9. Chiếc điện thoại đầu tiên ra đời năm 1876 Vào năm 1973, Martin Cooper đã sáng chế ra chiếc điện thoại di động đầu tiên. Điện thoại thời kỳ này gọi là điện thoại dạng cục gạch (Brick phone). Hình 1.10. Motorola Dyna-Tac - Cell phone đầu tiên năm 1973 Motorola Dyna Tac mang hình dáng gần giống điện thoại di động ngày nay mặc dù vẫn còn khá cồng kềnh, không phổ biến và chi phí đắt hơn điện thoại có dây. Một số đặc tính của điện thoại này như sau: - Kích thước 9 x 5 x 1.75 inches. - Trọng lượng: 2.5 pounds. - Màn hình: không có. - Số bảng mạch điện: 30. - thời gian nói chuyện: 35 phút. - Thời gian sạc pin: 10 giờ. - Đặc điểm: Nói, nghe, quay số. Giai đoạn những năm 1988-1998 được gọi là kỷ nguyên của điện thoại dạng thanh Hình 1.11.",
        "Summary": "Lịch sử hình thành và phát triển của thiết bị di động Mỗi loại đầu cuối di động đều có lịch sử hình thành và phát triển riêng. Trong phạm vi bài giảng này sẽ nêu ra lịch sử hình thành và phát triển của điện thoại di động, một loại đầu cuối di động phổ biến không thể thiếu trong cuộc sống con người Ngày 1031876 được coi là mốc son đánh dấu sự ra đời của điện thoại.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt gần như hoàn toàn trung thực. Thông tin về ngày ra đời của điện thoại và việc điện thoại di động là một loại thiết bị di động phổ biến đều được lấy từ văn bản gốc. Tuy nhiên, có một lỗi nhỏ về định dạng ngày tháng (1031876 thay vì 10/3/1876)."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu văn liên kết với nhau một cách logic và dễ hiểu. Tuy nhiên, bản tóm tắt quá ngắn gọn, khiến cho một số ý bị thiếu sự phát triển đầy đủ."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có liên quan đến văn bản gốc, nhưng lại bỏ qua nhiều chi tiết quan trọng khác như việc Martin Cooper sáng chế ra điện thoại di động đầu tiên năm 1973 và các đặc tính của điện thoại Motorola Dyna Tac. Việc chỉ tập trung vào ngày ra đời của điện thoại và định nghĩa chung về thiết bị di động khiến bản tóm tắt chưa thực sự hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá về tính trung thực và mạch lạc, nhưng cần cải thiện về tính liên quan. Bản tóm tắt cần bao gồm thêm các thông tin quan trọng khác trong văn bản gốc, đặc biệt là về sự phát triển của điện thoại di động, để cung cấp một cái nhìn toàn diện hơn về lịch sử hình thành và phát triển của thiết bị di động. Cần sửa lỗi định dạng ngày tháng."
            }
        }
    },
    {
        "Index": "00189",
        "Article": "Chúng ta sẽ trình bày quá trình xác định các công việc cần thực hiện cho dự án trước hay việc xác định WBS. Việc ước lượng cho toàn bộ dự án phụ thuộc rất nhiều vào việc thiết lập WBS có chính xác hay không. Bạn cảm thấy sao khi tôi hỏi “Dự án của bạn sẽ thực hiện trong bao lâu?”. Chắc chắn bạn sẽ không dễ dàng có câu trả lời đúng ngay cả khi bạn là khách hàng thật của một dự án có thực. Vậy bạn có thể giải quyết vấn đề này thế nào? Một trong những cách tiếp cận để giải quyết vấn đề này là biện pháp phân nhỏ dự án. Bạn cần phân chia dự án thành nhiều phần để có thể quản lý được. Tất cả các dự án đều cần bước này bởi đây là một cách dựa trên nguyên lý “Chia để trị “. Nguyên nhân chính dẫn đến sự thất bại của một dự án là do 1) - Quên một số thứ thiết yếu cho dự án và 2) – Cố gắng nhắm tới những con số ước lượng. Muốn biến những con số đó thành hiện thực. Chúng ta cùng thử phân tích xem việc phân nhỏ dự án sẽ giúp gì cho việc này. Các nhân tố của một dự án bao gồm các chức năng, hoạt động và công việc được mô tả ví dụ trong hình vẽ dưới đây . Một nhóm phân cấp theo định hướng các sản phẩm phân phối của các nhân tố dự án tổ chức và định nghĩa toàn bộ phạm vi của dự án. Mỗi mức bên dưới thể hiện một định nghĩa dự án ở mức chi tiết hơn. Cấu trúc phân rã công việc là danh sách phân rã các hoạt động cần thực hiện của dự án.Cấu trúc này gồm hai định dạng, sử dụng một hệ thống đánh số thập phân vs dụ 3.1.5 trong đó 0 thường biểu diễn mức độ cao nhất - - Định dạng theo dạng các đầu mục (outline) Định dạng theo cây đồ họa (biểu đồ tổ chức) Cấu trúc thường bao gồm các nhiệm vụ phát triển phần mềm (sản phẩm cuối cùng giao cho khách hàng), nhiệm vụ về quản lý và hỗ trợ dự án. Nó thể hiện các mối quan hệ bên trong của dự án, mối quan hệ giữa các công việc cụ thể và nó không thể hiện sự phụ thuộc về thời gian và khoảng thời gian cần thực hiện mỗi công việc.",
        "Summary": "\"Việc xác định WBS (Work Breakdown Structure) là quá trình quan trọng để phân chia dự án thành các phần nhỏ, dễ quản lý hơn, giúp ước lượng thời gian và nguồn lực chính xác hơn. Đây là biện pháp \"chia để trị\" để tránh thất bại do bỏ sót công việc hoặc cố gắng đạt những con số ước lượng thiếu thực tế. WBS bao gồm các chức năng, hoạt động và công việc, được phân cấp theo định hướng sản phẩm, thể hiện phạm vi dự án ở các mức độ chi tiết khác nhau. Cấu trúc này có thể được trình bày dưới dạng danh sách phân rã theo hệ thống số thập phân hoặc dạng cây đồ họa, bao gồm các nhiệm vụ phát triển phần mềm, quản lý và hỗ trợ dự án, thể hiện mối quan hệ bên trong dự án mà không thể hiện sự phụ thuộc về thời gian.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào việc giải thích WBS, lợi ích của nó, và cấu trúc của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00190",
        "Article": "Có thể chia tấn công theo mục đích thực hiện thành 4 loại chính như sau. Giả mạo (Fabrications): Tấn công giả mạo thông tin thường được sử dụng để đánh lừa người dùng thông thường; Chặn bắt (Interceptions): Tấn công chặn bắt thường liên quan đến việc nghe lén trên đường truyền và chuyển hướng thông tin để sử dụng trái phép; Gây ngắt quãng (Interruptions): Tấn công gây ngắt quãng làm ngắt, hoặc chậm kênh truyền thông, hoặc làm quá tải hệ thống, ngăn cản việc truy nhập dịch vụ của người dùng hợp pháp; Sửa đổi (Modifications): Tấn công sửa đổi liên quan đến việc sửa đổi thông tin trên đường truyền hoặc sửa đổi dữ liệu file. Theo hình thức thực hiện, có thể chia các loại tấn công thành 2 kiểu chính như sau: Tấn công chủ động (Active attacks): Tấn công chủ động là một đột nhập, xâm nhập (intrusion) về mặt vật lý vào hệ thống, hoặc mạng. Các tấn công chủ động thực hiện sửa đổi dữ liệu trên đường truyền, sửa đổi dữ liệu trong file, hoặc giành quyền truy nhập trái phép vào máy tính hoặc hệ thống mạng. Tấn công thụ động (Passive attacks): Tấn công thụ động thường không gây ra thay đổi trên hệ thống. Các tấn công thụ động điển hình là nghe trộm và giám sát lưu lượng trên đường truyền. Trên thực tế, tấn công thụ động thường là giai đoạn đầu của tấn công chủ động, trong đó tin tặc sử dụng các kỹ thuật tấn công thụ động để thu thập các thông tin về hệ thống, mạng, và trên cơ sở thông tin có được sẽ lựa chọn kỹ thuật tấn công chủ động có xác suất thành công cao nhất.",
        "Summary": "Tấn công có thể được chia theo mục đích thành 4 loại: giả mạo, chặn bắt, gây ngắt quãng và sửa đổi, hoặc theo hình thức thực hiện thành tấn công chủ động và thụ động. Tấn công chủ động xâm nhập hệ thống để sửa đổi dữ liệu hoặc giành quyền truy cập trái phép, trong khi tấn công thụ động như nghe trộm không thay đổi hệ thống nhưng thường là bước đầu để hỗ trợ tấn công chủ động.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các loại tấn công theo mục đích và hình thức thực hiện, cũng như mối liên hệ giữa tấn công thụ động và chủ động."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00191",
        "Article": "Các tiếp cận của tính toán tin cậy làm thay đổi mạnh mẽ thiết kế của hệ thống máy tính để bàn và ứng dụng phân tán. Điều mới với tính toán tin cậy là việc đảm bảo chắc chắn phần mềm chạy cục bộ hay ở xa dựa trên cơ chế mã hóa sử dụng cách thức xác thực đảm bảo. Tính toán tin cậy ngăn chặn các vụ tấn công dựa trên phần mềm nhờ vào các thao tác thiết yếu cho hoạt động phải có sự chứng thực từ phần cứng TPM. Tính toán tin cậy chịu nhiều chỉ trích không chỉ từ cộng đồng mã nguồn mở từ những điểm tiêu biểu như sau: Tính riêng tư: Không bảo vệ định danh người dùng với một số giao dịch .Kiểm soát của bên bán hàng: Bên bán hàng có thể sử dụng TPM khiến cho việc lựa chọn và thay đổi sản phẩm khó khăn hơn với người dùng cuối .Chứng thực: Việc chứng thực sử dụng chữ ký khó khăn do số lượng phần mềm lớn, nhất là khi các phần mềm này có thể được cập nhật định kỳ, vì vậy việc chứng thực cần thực hiện trên cơ sở hành vi của chương trình. .Không hỗ trợ mã khóa đối xứng. Thiết kế của TPM dù dùng rất nhiều phần của bộ xử lý mã hóa song không cung cấp chức năng mã hóa đối xứng nào. Điều này ảnh hưởng tới vấn đề như thực thi luật pháp. .Thực thi luật pháp: việc mã khóa mạnh tác động cả hai bên người dùng hợp lệ và người bẻ khóa. Được dùng một cách đúng đắn, TPM giúp bảo vệ dữ liệu bí mật của người dùng. TPM mô tả một cách rõ ràng không có cửa hậu trong thiết bị hợp chuẩn. Như vậy, không có cách thức hợp lệ nào khác ngoài thông tin của chủ sở hữu để truy nhập vào các thông tin được bảo vệ. Ngược lại, khi bị lạm dụng sẽ rất khó khăn cho các cơ quan thực thi luật pháp để khai thác các thông tin bí mật này.",
        "Summary": "Tính toán tin cậy thay đổi thiết kế hệ thống máy tính, đảm bảo phần mềm chạy cục bộ hoặc từ xa thông qua mã hóa và xác thực phần cứng TPM, giúp ngăn chặn tấn công phần mềm. Tuy nhiên, nó cũng gặp phải chỉ trích về tính riêng tư (không bảo vệ định danh người dùng), kiểm soát của bên bán hàng (khó thay đổi sản phẩm), chứng thực (khó khăn do số lượng phần mềm lớn và cập nhật thường xuyên), không hỗ trợ mã khóa đối xứng và khó khăn cho thực thi luật pháp khi bị lạm dụng. Mặc dù TPM giúp bảo vệ dữ liệu, việc thiếu \"cửa hậu\" khiến các cơ quan thực thi luật pháp khó truy cập thông tin được bảo vệ.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa, ưu điểm và nhược điểm của tính toán tin cậy, cũng như vai trò của TPM. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ về chủ đề được đề cập trong văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00192",
        "Article": "Câu hỏi: Có thể sử dụng chương trình trên để viết thêm được các chương trình gì? Gõ vào chương trình sau: #include <iostream.h> void main() à cout << “1 + 2 = ” << 1+ 2 << “\\n”; cout << “1.0 / 2 = ” << 1.0 / 2 << “\\n”; cout << “1 / 2.0 = ” << 1 / 2.0 << “\\n”; cout << “1.0 / 2.0 = ” << 1.0 / 2.0 << “\\n”; cout << “11 % 8 = ” << 11 % 8 << “\\n”; cout << “-11 % 8 = ” << -11 % 8 << “\\n”; cout << “11 % -8 = ” << 11 % -8 << “\\n”; cout << “-11 % -8 = ” << -11 % -8 << “\\n”; cout << “(1 + 2 > 1 * 2) = ” << (1 + 2 > 1 * 2) << “\\n”; cout << “(1 + 2 <= 1 * 2) = ” << (1 + 2 <= 1 * 2) << “\\n”; cout << “(‘B’ > ‘a’ && 1 + 2 > 1 * 2) = ” << (‘B’ > ‘a’ && 1 + 2 > 1 * 2) << “\\n”; 57 cout << “(‘B’ > ‘a’ áá 1 + 2 > 1 * 2) = ” << (‘B’ > ‘a’ áá 1 + 2 > 1 * 2) << “\\n”; cout << “sizeof(int) = ” << sizeof(int) << “\\n”; cout << “sizeof(double) = ” << sizeof(double) << “\\n”; cout << “sizeof(long int) = ” << sizeof(Iong int) << “\\n”; cout << “sizeof(1.0 / 2) = ” << sizeof(int) << “\\n”; cout << “(4 & 5) = “ << (4 & 5) << “\\n”; cout << “(4 á 5) = “ << (4 á 5) << “\\n”; cout << “(4 ^ 5) = “ << (4 ^ 5) << “\\n”; cout << “(2 << 3 )= “ << (2 << 3) << “\\n”; cout << “(8 >> 3 )= “ << (8 >> 3) << “\\n”; â Kết quả xuất ra màn hình: 58 Câu hỏi: mục tiêu của chương trình trên là gì ? Gõ vào chương trình sau: // chuong trinh doi do Fareinheit sang do Celsius #include <iostream.h> void main() à // B1. Nhap du lieu double f, c; cout << “Nhap do Fareinheit f = ”; cin >> f; // B2. Xu ly c = 5.0 / 9 * (f-32); 59 // B3. Xuat ket qua c cout << “Do Celsius tuong ung la “ << c << “\\n”; â Kết quả sau khi nhập trị 50 cho biến f:",
        "Summary": "Văn bản mô tả hai chương trình C++. Chương trình đầu tiên minh họa các phép toán số học, logic và bitwise trong C++, bao gồm phép cộng, phép chia, phép modulo, so sánh và các toán tử bitwise như AND, OR, XOR, dịch trái và dịch phải. Chương trình thứ hai chuyển đổi nhiệt độ từ độ Fahrenheit sang độ Celsius, bao gồm việc nhập liệu, tính toán và xuất ra kết quả. Cả hai chương trình đều sử dụng thư viện iostream để nhập xuất dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt được trình bày mạch lạc, rõ ràng. Các ý được liên kết logic với nhau, giúp người đọc dễ dàng nắm bắt nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Nó tập trung vào các ý chính của cả hai chương trình C++ được mô tả, bao gồm mục đích, các phép toán được sử dụng và cách nhập xuất dữ liệu."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt, đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00193",
        "Article": "Kiến trúc dịch vụ nền tảng liên quan đến Cloud được mô hình hóa trong chương trình mô phỏng bởi thành phần Data center. Data center được tạo bởi các tập hợp các Host, có trách nhiệm quản lý các máy ảo VM trong chu kỳ sống của chúng. Các Host là các nút trong Cloud: nó được tham số khả năng xử lý của bộ vi xử lý trung tâm CPU (biểu diễn qua đơn vị MIPS = milion of instruction per second), bộ nhớ, khả năng lưu trữ và chính sách định thời để xử lý việc cấp phát lõi tính toán cho các máy ảo. Các thành phần máy Host của nền tảng mô phỏng hỗ trợ mô phỏng vi xử lý một nhân và đa nhân. Việc phân phối máy ảo phục vụ cho ứng dụng cụ thể nào đó đến các thành phần Host là trách nhiệm của thành phần Virtual Machine Provisioner. Thành phần này cung cấp một tập các phương thức cho người sử dụng, với nhưng chính sách điều phối tài nguyên hướng tới mục tiêu tối ưu hiệu quả sử dụng. Những chính sách mặc định hiện có sẵn rất giản đơn theo hướng ai đến trước sẽ được phục vụ trước. Với mỗi thành phần Host, sự cấp phát các vi xử lý CPU tới các máy ảo được thực hiện theo chính sách điều phối cụ thể dựa theo số lượng yêu cầu và số lượng vi xử lý sẵn có. Do vậy, có thể có các chính sách như cấp phát CPU dành riêng cho máy ảo hay phân tán động giữa các máy ảo (chia sẻ theo thời gian). Mô hình chợ Cloud đóng vai trò như người môi giới giữa nhà cung cấp dịch vụ Cloud và khách hàng là điểm nhấn của Cloud computing. Hơn thế nữa, những dịch vụ này cần cơ chế để xác định chi phí dịch vụ và các chính sách về giá. Mô hinh chính sách, chi phí và giá cả là một ý tưởng được xem xét khi thiết kết chương trình mô phỏng Cloud, bốn thuộc tính được xem xét đến là: Chi phí mỗi bộ xử lý; Chi phí mỗi đơn vị bộ nhớ; Chi phí mỗi đơn vị lưu trữ; Chi phí mỗi đơn vị băng thông sử dụng. Chi phí mỗi đơn vị bộ nhớ và lưu trữ được kèm theo trong quá trình khởi tạo máy ảo. Chi phí mỗi đơn vị băng thông sử dụng có trong quá trình truyền dữ liệu. Bên cạnh đó, các chi phí sử dụng bộ nhớ, lưu trữ và các chi phí liên quan có mối liên hệ với việc sử dụng tài nguyên tính toán. Do vậy, nếu máy ảo VM được tạo mà không có tác vụ nào thực thi trên chúng, thì chỉ có chi phí về bộ nhớ và lưu trữ. Những vấn đề này có thể được thay đổi bởi người dùng.",
        "Summary": "Kiến trúc dịch vụ nền tảng liên quan đến Cloud được mô phỏng qua thành phần Data center, bao gồm các Host quản lý máy ảo (VM) dựa trên khả năng xử lý CPU, bộ nhớ, lưu trữ và chính sách định thời. Việc phân phối máy ảo đến các Host do Virtual Machine Provisioner đảm nhiệm, với các chính sách điều phối tài nguyên nhằm tối ưu hiệu quả sử dụng. Mô hình chợ Cloud đóng vai trò môi giới giữa nhà cung cấp dịch vụ và khách hàng, với các chính sách chi phí liên quan đến bộ xử lý, bộ nhớ, lưu trữ và băng thông, có thể được điều chỉnh bởi người dùng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ nguyên và trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được sắp xếp theo trình tự hợp lý, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào kiến trúc dịch vụ nền tảng Cloud, vai trò của Data center, Host, Virtual Machine Provisioner và mô hình chợ Cloud, đồng thời đề cập đến các chính sách chi phí liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã thành công trong việc cô đọng những ý chính của văn bản gốc một cách hiệu quả. Không có đề xuất cải thiện nào."
            }
        }
    },
    {
        "Index": "00194",
        "Article": "Xây dựng hệ thống High Availability: Giải pháp High availability cần sử dụng ít nhất 02 server chạy song song để đảm bảo việc chuyển tiếp thông tin không bị gián đoạn. Khi xây dựng giải pháp high availability cần tính đến khả năng xảy ra sự cố và thiết kế dự phòng ở các nơi cần thiết: Dự phòng tất cả các tuyến từ Worksattion đến router ở lớp building access. Máy chủ dự phòng cho các server farm module. Dự phòng tuyến đường bên trong và giữa các thành phần mạng. Liên kết truyền thông dự phòng ở các lớp truy cập. Server Redundancy (Máy chủ dự phòng ) Máy chủ này được cài đặt trong hệ thống mạng cần lưu trữ các thông tin quan trọng. Trong trường hợp bình thường, máy chủ dự phòng ở chế độ offline. Còn khi máy chủ chính gặp sự cố thì máy chủ dự phòng sẽ được bật. Router Redundancy (Tuyến dự phòng) Tuyến dự phòng được thiết kế nhằm thực hiện 2 mục đích: Cân bằng tải và tăng tính sẵn sàng. Load balancing (Cân bằng tải) Đây là cách chia nhỏ số lượng công việc trên một thiết bị thành nhiều thiết bị tương ứng để xử lý yêu cầu nhanh và hiệu quả hơn. Thực tế, các website của những doanh nghiệp lớn thường gặp vấn đề về quá tải nên load balancing (cân bằng tải) chính là giải pháp cần thiết, nhằm định tuyến yêu cầu truy cập đến các host server khác nhau. Phần lớn các giao thức định tuyến IP đều cân bằng tải trên các liên kết song song. Do đó, cần sử dụng tối đa đường dẫn, thay đổi số lượng liên kết để router thực hiện cân bằng tải, mặc định là 4 và tối đa 6 đường. Thông thường, cứ 2 máy chủ được sử dụng để cân bằng tải thì sẽ phải có thêm 1 máy chủ thực hiện nhiệm vụ quyết định server nào đảm nhận công việc. Vì thế, bộ cân bằng tải cần nhiều thiết bị để cài đặt và chúng được tích hợp với các dịch vụ sao lưu, dự phòng dữ liệu. Thậm chí, trong một số tình huống, thiết bị còn được đặt ở nhiều nơi khác nhau.",
        "Summary": "Để xây dựng hệ thống High Availability (HA), cần sử dụng ít nhất hai server chạy song song và thiết kế dự phòng ở nhiều lớp, từ workstation đến router, server farm module, và các liên kết truyền thông. Server Redundancy sử dụng máy chủ dự phòng offline, chỉ bật khi máy chủ chính gặp sự cố. Router Redundancy có hai mục đích: cân bằng tải (load balancing) và tăng tính sẵn sàng. Load balancing chia nhỏ công việc cho nhiều thiết bị để xử lý nhanh hơn, thường dùng cho các website lớn. Các giao thức định tuyến IP thường cân bằng tải trên các liên kết song song, cần tối đa số lượng đường dẫn để router thực hiện. Bộ cân bằng tải cần nhiều thiết bị, tích hợp dịch vụ sao lưu, và có thể được đặt ở nhiều nơi khác nhau.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt được trình bày một cách mạch lạc và logic. Các ý được liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin dễ hiểu. Cách diễn đạt rõ ràng, không gây khó khăn cho người đọc trong việc nắm bắt nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Chỉ những ý chính và quan trọng nhất được giữ lại, loại bỏ các chi tiết thừa hoặc không cần thiết. Điều này giúp người đọc nhanh chóng nắm bắt được bản chất của vấn đề mà không bị phân tâm bởi các thông tin không quan trọng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin tốt, giúp người đọc dễ dàng nắm bắt được nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00195",
        "Article": "5.1.2.3. Điều khiển truy nhập dựa trên vai trò\n Điều khiển truy nhập dựa trên vai trò (RBAC) cho phép người dùng truy nhập vào hệ thống và thông tin dựa trên vai trò (role) của họ trong cơ quan, tổ chức đó. Điều khiển truy nhập dựa trên vai trò có thể được áp dụng cho một nhóm người dùng hoặc từng người dùng riêng lẻ. Quyền truy nhập vào các đối tượng trong hệ thống được tập hợp thành các nhóm “vai trò” với các mức quyền truy nhập khác nhau. Các vai trò được tổ chức thành một cây theo mô hình phân cấp tự nhiên của các cơ quan, tổ chức. Ví dụ như, hệ thống thông tin trong một trường học chia người dùng thành các nhóm gán sẵn quyền truy nhập vào các phần trong hệ thống như sau:\n - Nhóm Quản lý được quyền truy nhập vào tất cả các thông tin trong hệ thống;\n - Nhóm Giáo viên được truy nhập vào cơ sở dữ liệu các môn học, bài báo khoa học, cập nhật điểm các lớp do mỗi giáo viên phụ trách;\n - Nhóm Sinh viên chỉ được quyền xem nội dung các môn học, tải tài liệu học tập và xem điểm của mình.\n Việc liên kết giữa người dùng và nhóm vai trò có thể được tạo lập và huỷ bỏ dễ dàng và được thực hiện theo nguyên tắc: Người dùng được cấp “thẻ thành viên” của các nhóm “vai\n  \n trò” trên cơ sở năng lực và vai trò, cũng như trách nhiệm của họ trong một tổ chức. Trong nhóm “vai trò”, người dùng được cấp vừa đủ quyền để thực hiện các thao tác cần thiết cho công việc được giao. Hình 5.4 minh họa một mô hình RBAC đơn giản, trong đó quyền truy nhập vào các đối tượng (PRMS) được tập hợp thành các nhóm vai trò (Role) và việc cấp quyền truy nhập các đối tượng cho người dùng (User) được thực hiện thông qua thao tác gán quyền (UA – User Assignment). Việc cấp quyền truy nhập các đối tượng cho người dùng có thể có hiệu lực trong dài hạn, hoặc cũng có thể có hiệu lực trong ngắn hạn, như theo phiên làm việc (Session).\n 5.1.2.4. Điều khiển truy nhập dựa trên luật\n Điều khiển truy nhập dựa trên luật (Rule-based Access Control) là cơ chế cho phép người dùng truy nhập vào hệ thống và thông tin dựa trên các luật (rule) đã được định nghĩa trước. Các luật có thể được thiết lập để hệ thống cho phép truy nhập đến các tài nguyên của mình cho người dùng thuộc một tên miền, một mạng hay một dải địa chỉ IP. Các tường lửa (firewall), hoặc proxy là ví dụ điển hình về việc thực hiện cơ chế điều khiển truy nhập dựa trên luật. Các luật trong tường lửa thực hiện kiểm soát truy nhập sử dụng các thông tin trích xuất từ các gói tin, thông tin về nội dung truy nhập, có thể bao gồm:\n - Địa chỉ IP nguồn và đích của các gói tin;\n - Cổng dịch vụ của các máy chủ;\n - Địa chỉ IP hoặc các tên miền để lọc, hoặc chặn các website bị cấm;\n - Phần mở rộng các file để lọc các mã độc hại;\n - Tập các từ khoá để lọc các nội dung bị cấm.",
        "Summary": "**Tóm tắt:**\n \n Điều khiển truy nhập dựa trên vai trò (RBAC) cho phép người dùng truy cập hệ thống và thông tin dựa trên vai trò của họ trong tổ chức. Các vai trò được tổ chức phân cấp và gán quyền truy nhập khác nhau. Người dùng được cấp quyền truy cập thông qua \"thẻ thành viên\" của các nhóm vai trò.\n \n Điều khiển truy nhập dựa trên luật (Rule-based Access Control) cho phép truy cập dựa trên các luật định nghĩa trước. Các luật này có thể dựa trên tên miền, mạng, địa chỉ IP, hoặc thông tin từ các gói tin, như địa chỉ IP, cổng dịch vụ, tên miền, phần mở rộng file, và từ khóa. Tường lửa và proxy là các ví dụ điển hình của cơ chế này.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Nội dung tóm tắt tập trung vào trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Đảm bảo tính trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00196",
        "Article": "Socket cho tiến trình trên máy khách Hàm public Socket(string host,int port) throws UnknownHostException, IOException tạo một socket TCP, trong đó host là địa chỉ hoặc tên miền (trong trường hợp này phải sử dụng dịch vụ DNS) và port là số hiệu cổng cung cấp dịch vụ của server. Ví dụ: Try { Socket s = new Socket( “www.ptit.edu.vn”,80); } Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 108 catch(UnknownHostException e) { System.err.println(e); } catch(IOException e) { System.err.println(e); } Một số phương thức thường dùng: Đối tượng Socket có một số trường thông tin riêng mà ta có thể truy nhập tới chúng thông qua các phương thức trả về các thông tin này. Phương thức Ý nghĩa getInetAddress() Trả về địa chỉ đích getPort() Trả về số hiệu cổng đích getLocalAddress() Trả về địa chỉ nguồn getLocalPort() Trả về số hiệu cổng nguồn getInputStream() Trả về một luồng nhập để đọc dữ liệu từ một socket vào chương trình getOutputStream() Trả về một luồng xuất thô để ghi dữ liệu từ ứng dụng ra đầu cuối của một socket Đóng Socket: Các socket được đóng một cách tự động khi một trong hai luồng đóng lại, hoặc khi chương trình kết thúc, hoặc khi socket được thu hồi. Tuy nhiên, lập trình viên không nên để hệ thống tự đóng socket, đặc biệt là khi các chương trình chạy trong khoảng thời gian vô hạn. Mỗi khi một Socket đã bị đóng lại, ta vẫn có thể truy xuất tới các trường thông tin InetAddress, địa chỉ cục bộ, và số hiệu cổng cục bộ thông qua các phưong thức getInetAddress(), getPort(), getLocalHost(), và getLocalPort(). Tuy nhiên khi ta gọi các phương thức getInputStream() hoặc getOutputStream() để đọc dữ liệu từ luồng đọc InputStream hoặc ghi dữ liệu OuputStream thì xuất hiện ngoại lệ IOException. Lập trình viên có thể sử dụng các phương thức sau để đóng kết nối: public void close() throws IOException public void shutdownInput() throws IOException public void shutdownOutput() throws IOException Phương thức close() đóng cả các luồng nhập và luồng xuất từ socket. Trong một số trường hợp ta chỉ muốn đóng một nửa kết nối, hoặc là luồng nhập hoặc là luồng xuất. Bắt đầu từ Java 1.3, các phương thưc shutdownInput() và shutdownOutput() cho phép ta thực hiện điều này.",
        "Summary": "Hàm `Socket(string host, int port)` tạo socket TCP kết nối đến địa chỉ `host` và cổng `port` của server. Đối tượng Socket cung cấp các phương thức để truy xuất thông tin về địa chỉ và cổng nguồn/đích (ví dụ: `getInetAddress()`, `getPort()`, `getLocalAddress()`, `getLocalPort()`) cũng như luồng nhập/xuất dữ liệu (`getInputStream()`, `getOutputStream()`). Socket sẽ tự động đóng khi luồng đóng, chương trình kết thúc hoặc bị thu hồi, nhưng lập trình viên nên chủ động đóng bằng phương thức `close()`. Có thể đóng riêng luồng nhập hoặc xuất bằng `shutdownInput()` và `shutdownOutput()` (từ Java 1.3). Sau khi đóng, vẫn có thể truy xuất thông tin địa chỉ và cổng, nhưng thao tác với luồng sẽ gây ra ngoại lệ IOException.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào chức năng tạo socket, các phương thức truy xuất thông tin và cách đóng socket, đây đều là những điểm cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã bao quát được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00197",
        "Article": "Trong ma trận truy cập, hàng biểu diễn miền bảo vệ, cột biểu diễn đối tượng cần bảo vệ. Phần tử trong ma trận xác định các quyền truy cập của miền trên đối tượng tương ứng. Do đối tượng được xác định qua cột, nên có thể bỏ qua tên đối tượng trong quyền truy cập, vì thế access(i, j) xác định tập hợp các thao tác mà tiến trình thực thi trong miền bảo vệ D j có thể thực hiện trên đối tượng O j. Xét ma trận truy cập. Ma trận gồm 4 miền và 4 đối tượng: ba file (F1, F2, F3) và máy in laser. Khi thực thi trong miền D1, tiến trình có thể đọc file F1 và F3. Tiến trình thực thi trong miền D3 có quyền đọc file F2, nhưng không có quyền đọc file F1 hay F3. Chú ý, chỉ tiến trình thực thi trong miền D2 mới in được trên máy in laser. Thông qua ma trận truy cập, hệ thống có thể cài đặt nhiều loại chính sách khác nhau. Cơ chế bảo vệ ở đây gồm hai phần: cài đặt ma trận và đảm bảo các nguyên tắc an ninh của hệ thống. Hệ thống phải đảm bảo tiến trình thực thi trong miền D1 chỉ có thể thực hiện được đúng các thao tác đã liệt kê tại các phần tử ở hàng i. Chính sách bảo vệ xác định nội dung các phần tử của ma trận quyền truy cập. Người dùng có thể quyết định nội dung các phần tử của ma trận truy cập. Khi người dùng tạo mới đối tượng Oi, có thể Oi được thêm vào ma trận với các giá trị khởi tạo ban đầu do người dùng thiết lập. Khi cần thiết, người dùng có thể thêm quyền vào các ô ở cột j của ma trận. Ma trận truy cập là cơ chế thích hợp để tạo lập và kiểm soát mối liên kết giữa tiến trình và miền bảo vệ. Tiến trình chuyển từ miền bảo vệ này sang miền bảo vệ khác thông qua thao tác chuyển (switch) (lúc này miền bảo vệ cũng được xem là đối tượng). Tương tự, thay đổi nội dung ma trận truy cập tương ứng với việc thực hiện thao tác nào đó trên ma trận (ma trận cũng được coi là đối tượng). Mặc dù quyền sao chép và quyền sở hữu có thể giới hạn sự lan truyền các quyền truy cập, nhưng lại không thể ngăn chặn thông tin bị rò rỉ. Không thể đảm bảo thông tin nằm trong đối tượng không thể bị chuyển ra khỏi môi trường thực thi. Các thao tác trên đối tượng miền bảo vệ và ma trận quyền truy cập minh họa được khả năng cài đặt và kiểm soát ma trận truy cập đáp ứng yêu cầu bảo vệ động. Đối tượng và miền mới có thể được tạo mới trong mô hình ma trận quyền truy cập.",
        "Summary": "Ma trận truy cập biểu diễn mối quan hệ giữa miền bảo vệ và đối tượng, với mỗi phần tử xác định các quyền truy cập của miền trên đối tượng tương ứng. Hệ thống sử dụng ma trận để cài đặt và kiểm soát các chính sách bảo vệ, cho phép thêm quyền hoặc tạo mới đối tượng và miền bảo vệ. Mặc dù ma trận hỗ trợ bảo vệ động, nhưng không thể ngăn chặn hoàn toàn việc rò rỉ thông tin từ đối tượng ra ngoài môi trường thực thi.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được trình bày rõ ràng, không gây khó khăn cho người đọc trong việc nắm bắt nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa hoặc không cần thiết. Bản tóm tắt tập trung vào định nghĩa, chức năng, và hạn chế của ma trận truy cập, là những điểm cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00198",
        "Article": "b) Kỹ thuật giấu tin bằng phương pháp hoán vị giả nhẫu nhiên\n Theo sơ đồ tổng quan về quá trình giấu và tách tin, để thực hiện giấu tin và giải mã,\n bên nhận và bên gửi cần thống nhất với nhau về việc sử dụng thuật toán sinh bộ số giả ngẫu\n nhiên và giá trị khởi tạo ban đầu hoặc gửi giá trị khởi tạo qua kênh truyền an toàn. Ngoài ra\n nếu thông điệp được mã hóa thì hai bên cũng cần thống nhất thuật toán mã hóa, giải mã và gửi\n khóa qua kênh truyền an toàn.\n + Thuật toán giấu tin\n Bước 1: Thông điệp được mã hóa (nếu cần) sau đó được chuyển sang thành dãy nhị\n phân. Gọi 𝑙𝑚 là độ dài của thông điệp (ở dạng nhị phân) và tương ứng 𝑚𝑖 là bit thứ i của thông\n điệp sau khi mã hóa và chuyển về dạng nhị phân.\n Bước 2: Trích xuất ma trận điểm ảnh trong ảnh, biến đổi các điểm ảnh về dạng nhị phân\n và chuyển ma trận thành dãy nhị phân. Gọi 𝑙𝑐 là độ dài của ảnh sau khi chuyển về dãy nhị\n phân và tương ứng 𝑐𝑖 là bit thứ i trong ảnh.\n Bước 3: Sử dụng bộ sinh số giả ngẫu nhiên và giá trị khởi tạo chọn trước, sinh dãy số\n 𝑟1, 𝑟2, … , 𝑟𝑙𝑚\n Bước 4: Thay thế bit 𝑐𝑟𝑖 của ảnh bằng bit 𝑚𝑖 của thông điệp\n + Thuật toán tách tin\n Bước 1: Trích xuất ma trận điểm ảnh trong ảnh, biến đổi các điểm ảnh về dạng nhị phân\n và chuyển ma trận thành dãy nhị phân. Gọi 𝑙𝑐 là độ dài của ảnh sau khi chuyển về dãy nhị\n phân và tương ứng 𝑐𝑖 là bit thứ i trong ảnh.\n Bước 2: Sử dụng bộ sinh số giả ngẫu nhiên và giá trị khởi tạo chọn trước, sinh dãy số\n 𝑟1, 𝑟2, … , 𝑟𝑙𝑚\n Bước 3: Lần lượt lấy ra các bit bit 𝑐𝑟𝑖 của ảnh và ghép lại để được một dãy nhị phân.\n Đây chính là dãy nhị phân của thông điệp.",
        "Summary": "Để giấu tin bằng phương pháp hoán vị giả ngẫu nhiên, bên gửi và bên nhận cần thống nhất thuật toán sinh số giả ngẫu nhiên và giá trị khởi tạo, cũng như thuật toán mã hóa/giải mã thông điệp (nếu cần). Quá trình giấu tin bao gồm mã hóa thông điệp thành dãy bit, trích xuất dãy bit từ ảnh, sinh dãy số ngẫu nhiên và thay thế các bit ảnh bằng các bit thông điệp tại vị trí ngẫu nhiên. Quá trình tách tin ngược lại, trích xuất dãy bit từ ảnh, sinh lại dãy số ngẫu nhiên, lấy các bit ảnh tại vị trí ngẫu nhiên và ghép lại thành thông điệp.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của phương pháp giấu tin bằng hoán vị giả ngẫu nhiên và các bước chính trong quá trình giấu và tách tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về phương pháp giấu tin bằng hoán vị giả ngẫu nhiên được mô tả trong văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00199",
        "Article": "2.2.2 Đặc điểm ví điện tử\n Ví điện tử có những đặc điểm sau :\n (1) Dòng tiền liên thông giữa tài khoản ví và tài khoản ngân hàng\n Tiện ích cho phép chuyển đổi một phần hoặc toàn bộ số tiền từ tài khoản ngân hàng\n sang tài khoản ví điện tử và ngược lại là yêu cầu bắt buột theo luật quy định đối với các tổ\n chức cung cấp dịch vụ ví điện tử. Trước đây kể từ năm 2014 trở về trước chưa có đặc điểm\n này, nên một số nhà cung cấp dịch vụ ví điện tử cung cấp khá linh hoạt các cách thức để nạp,\n rút tiền từ ví điện tử, tuy nhiên kể từ năm 2014 (theo thông tư 39/2014 – Hướng dẫn về dịch\n vụ trung gian thanh toán) thì bắt buộc phải có sự liên thông giữa tài khoản ví và tài khoản thẻ.\n (2) Ví điện tử là một dịch vụ nhạy cảm về mặt tài chính, nó sẽ hoạt động như một\n ngân hàng điện tử\n Theo luật quy định, một nhà cung cấp dịch vụ ví điện tử là một tổ chức tín dụng phi\n ngân hàng. Mà một tổ chức tín dụng : là doanh nghiệp thực hiện một, một số hoặc tất cả các\n hoạt động ngân hàng. Hoạt động ngân hàng là những nghiệp vụ: Nhận tiền gửi; cấp tín dụng;\n cung ứng dịch vụ thanh toán qua tài khoản, chính vì vậy ví điện tử hoạt động như một ngân\n hàng điện tử bao gồm những hoạt động: thanh toán trực tuyến, nhận và chuyển tiền, lưu trữ\n thông tin bao gồm thông tin cá nhân, thông tin thẻ thanh toán, và tiền điện tử.\n Bản thân ví điện tử nó sẽ chịu sự điều chỉnh của luật ngân hàng và các tổ chức tín\n dụng, để tránh trường hợp nhà cung cấp dịch vụ thanh toán ví điện tử nắm giữ tiền của người\n mua và người bán.\n (3) Ví điện tử đòi hỏi phải được kết nối với một cổng thanh toán trực tuyến\n Ví điện tử chỉ là một phương tiện thanh toán giống như những phương tiện thanh toán\n khác như : thẻ thanh toán, vi thanh toán, séc điện tử,… vì thế nếu mà người bán hàng muốn\n cung cấp dịch vụ này cho người mua hàng thì đều phải kết nối với một cổng thanh toán trực\n tuyến hoặc một nhà cung cấp dịch vụ ví điện tử. Bản thân nó không thể tồn tại riêng lẻ và\n tham gia vào các hoạt động thanh toán trực tuyến.\n (4) Thanh toán tạm giữ là phương thức than toán chủ đạo\n Thanh toán tạm giữ là hình thức thanh toán an toàn của nhà cung cấp dịch vụ ví điện\n tử, vì sau khi xác nhận thanh toán (bằng OTP gửi tới điện thoại di động hoặc mật khẩu thanh\n toán), số tiền thanh toán sẽ bị \"treo\" (chưa thực sự chuyển sang tài khoản của người bán,\n người bán không thể rút ra và người mua cũng không dùng số tiền này để thực hiện một giao39\n dịch khác). Người mua và người bán có một khoảng thời gian (thông thường mặc định là 7\n ngày) để thực hiện các giao kèo (như chuyển nhận hàng,....). Trong thời gian tạm giữ, chỉ khi\n nào người mua nhấn vào nút phê chuẩn - đồng ý chuyển tiền cho người bán thì tiền mới thực\n sự chuyển đi. Dịch vụ tích hợp ví điện tử bảo vệ an toàn cho khách hàng khỏi các rủi ro và\n nguy cơ lừa đảo trên Internet vì vậy thanh toán tạm giữ là phương thức thanh toán chủ đạo đối\n với ví điện tử.\n Một số ví điện tử cung cấp hình thức thanh toán tạm giữ: Ngân lượng, Bảo Kim,\n Paypal, Alipay,…\n (5) Chưa có sự liên thông giữa các tài khoản ví điện tử khác hệ thống như tài\n khoản thẻ\n Tài khoản ví điện tử khác biệt so với tài khoản ngân hàng ở chỗ hiện giờ hầu như các\n hệ thống tài khoản thẻ được liên thông với nhau, do sự liên minh của các hệ thống ngân hàng,\n nhưng tài khoản ví điện tử không có đặc điểm này.",
        "Summary": "\"Ví điện tử có các đặc điểm chính: (1) Dòng tiền liên thông giữa ví và tài khoản ngân hàng là bắt buộc theo quy định. (2) Hoạt động như một ngân hàng điện tử, chịu sự điều chỉnh của luật ngân hàng. (3) Cần kết nối với cổng thanh toán trực tuyến để tham gia thanh toán. (4) Thanh toán tạm giữ là phương thức chủ đạo, bảo vệ người mua khỏi rủi ro. (5) Chưa có sự liên thông giữa các ví điện tử khác hệ thống như tài khoản thẻ ngân hàng.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả các thông tin được trình bày trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và dễ hiểu. Các câu liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin liên tục và có ý nghĩa."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các đặc điểm chính của ví điện tử, đúng như mục đích của đoạn văn gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được đầy đủ các ý chính của văn bản gốc và trình bày chúng một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00200",
        "Article": "Bản chất xác suất sử dụng trong suy diễn Bản chất thống kê: trong lý thuyết xác suất truyền thống, giá trị xác suất được xác định dựa trên quan sát, thực nghiệm, thống kê. Ví dụ, để xác định xác suất trời mưa vào ngày lễ 1- suất như vậy không phải khi nào cũng thực hiện được. Xác suất dựa trên chủ quan: trong suy diễn xác suất, khi không thể xác định giá trị xác suất bằng thống kê, xác suất có thể xác định một cách chủ quan, dựa trên niềm tin của chuyên gia, của người dùng về sự đúng, sai của các sự kiện. Ví dụ, bác sĩ có thể cung cấp giá trị xác suất về một triệu chứng bệnh nào đó dựa trên kinh nghiệm và ước lượng, thay vì dựa trên thống kê chính xác và cụ thể. Thu thập và biểu diễn thông tin cho suy diễn xác suất Để suy diễn xác suất cho một vấn đề nào đó, các bước sau cần được thực hiện: Xác định các tham số liên quan tới vấn đề, chẳng hạn trong chẩn đoán bệnh, tham số có thể là “đau đầu”, “chán ăn”. Mỗi tham số xác định ở trên được biểu diễn bằng một biến ngẫu nhiên tương ứng. Xác định miền giá trị cho các biến ngẫu nhiên. Thông thường, mỗi biến ngẫu nhiên có thể nhận một giá trị rời rạc trong miền giá trị của mình. Với những trường hợp đơn giản, biến chỉ có hai giá trị “đúng”, “sai” như đối với biến “chán ăn”. Những biến như vậy được gọi là biến bool hay biến nhị phân. Trong trường hợp chung, biến có thể nhận nhiều giá trị hơn, chẳng hạn “đau đầu” có thể nhận giá trị “nhẹ”, “dữ dội”, Xác định xác suất ứng với sự kiện biến nhận giá trị nào đó.",
        "Summary": "Ví dụ, bác sĩ có thể cung cấp giá trị xác suất về một triệu chứng bệnh nào đó dựa trên kinh nghiệm và ước lượng, thay vì dựa trên thống kê chính xác và cụ thể.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Câu văn được trích dẫn trực tiếp từ văn bản gốc mà không có bất kỳ sự thay đổi hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt là một câu duy nhất, nên không thể đánh giá về sự liên kết giữa các ý. Tuy nhiên, vì chỉ là một câu trích dẫn nên nó rõ ràng và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chỉ trích dẫn một ví dụ minh họa cho việc xác định xác suất dựa trên chủ quan. Mặc dù ví dụ này có trong văn bản gốc, nhưng nó không phải là ý chính hoặc bao quát toàn bộ nội dung. Việc chỉ tóm tắt bằng một ví dụ làm giảm giá trị của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có tính trung thực cao vì trích dẫn chính xác từ văn bản gốc. Tuy nhiên, nó thiếu tính liên quan vì chỉ tập trung vào một ví dụ cụ thể mà không đề cập đến các ý chính khác của văn bản. Để cải thiện, bản tóm tắt nên bao gồm các ý chính như bản chất xác suất sử dụng trong suy diễn, sự khác biệt giữa xác suất dựa trên thống kê và xác suất dựa trên chủ quan, và các bước thu thập và biểu diễn thông tin cho suy diễn xác suất."
            }
        }
    }
]