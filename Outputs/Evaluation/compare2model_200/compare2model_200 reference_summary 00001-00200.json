[
    {
        "Index": "00001",
        "Article": "2.6 Chuyển danh sách Lvào ngăn xếp S; End; Ví dụ : Với ví dụ đồ thị không gian trạng thái như hình 2.2 thì cây tìm kiếm leo đồi tương ứng như hình 2.4 : A 20 C 15 E 7 6 D F I 10 8 B G 0 5 Cây tìm kiếm leo đồi Hạn chế của - Giải thuật có khuynh hướng bị sa lầy ở những cực đại cục bộ: + Lời giải tìm được không tối ưu + Không tìm được lời giải mặc dù có tồn tại lời giải - Giải thuật có thể gặp vòng lặp vô hạn do không lưu giữ thông tin về các trạng thái đã duyệt. * Tìm kiếm Beam Để hạn chế không gian tìm kiếm, người ta đưa ra phương pháp tìm kiếm Beam. Đây là phương pháp tìm kiếm theo chiều rộng nhưng có hạn chế số đỉnh phát triển ở mỗi mức. Trong tìm kiếm theo chiều rộng, tại mỗi mức ta phát triển tất cả các đỉnh, còn tìm kiếm Beam thì chọn k đỉnh tốt nhất để phát triển. Các đỉnh này được xác định bởi hàm đánh giá. Ví dụ, với đồ thì không gian trạng thái như hình 2.2 và lấy k=2 thì cây tìm kiếm Beam như hình 2.5. Các đỉnh được chọn ở mỗi mức là các đỉnh được tô màu đỏ: A 20 C 15 E 7 6 D K 12 F 10 I G 8 5 0 B 5 G B 3 H 0 Cây tìm kiếm Beam * Tìm kiếm nhánh cận Ý tưởng : thuật toán tìm kiếm leo đồi kết hợp với hàm đánh giá f(u). Tại mỗi bước, khi phát triển trạng thái u, chọn trạng thái con v tốt nhất (f(v) nhỏ nhất) của u để phát triển ở bước sau. Quá trình tiếp tục như vậy cho đến khi gặp trạng thái w là đích, hoặc w không có đỉnh kề, hoặc w có f(w) lớn hơn độ dài đường đi tối ưu tạm thời (đường đi đầy đủ ngắn nhất trong số những đường đi đầy đủ đã tìm được). Trong các trường hợp này, chúng ta không phát triển đỉnh w nữa, tức là cắt bỏ những nhánh xuất phát từ w, và quay lên cha của w để tiếp tục đi xuống trạng thái tốt nhất trong số những trạng thái còn lại chưa được phát triển. Procedure Branch-and-Bound; Begin 1. Khởi tạo ngăn xếp S chỉ chứa trạng thái đầu; Gán giá trị ban đầu cho cost; /*cost là giá trị đường đi tối ưu tạm thời*/",
        "Summary": "Văn bản mô tả các thuật toán tìm kiếm trong không gian trạng thái, bao gồm tìm kiếm leo đồi, tìm kiếm Beam và tìm kiếm nhánh cận. Tìm kiếm leo đồi dễ bị mắc kẹt ở cực đại cục bộ và có thể gặp vòng lặp vô hạn. Tìm kiếm Beam khắc phục hạn chế này bằng cách giới hạn số lượng đỉnh được mở rộng ở mỗi mức, dựa trên hàm đánh giá. Cuối cùng, tìm kiếm nhánh cận kết hợp ý tưởng của tìm kiếm leo đồi với một hàm đánh giá để cắt bỏ các nhánh không tiềm năng, tối ưu hóa quá trình tìm kiếm bằng cách loại bỏ các đường đi không hiệu quả.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Tóm tắt tập trung vào việc mô tả các thuật toán tìm kiếm và hạn chế của chúng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00002",
        "Article": "Ngoài ra, chính phủ Mông Cổ đã có những tiến bộ trong việc sử dụng công nghệ thông tin truyêng thông trong việc đơn giản hóa thủ tục để công dân đóng thuế. Cơ quan thuế trực tuyến của Mông Cổ Trang web của Cơ quan Thuế Mông Cổ (http://www.mta.mn) chứa thông tin không chỉ về quyền mà còn một danh sách đầy đủ các dịch vụ đối với công dân và tổ chức. Trong số này là các hình thức thuế có thể tải về , in trong mẫu sẵn và được mua lại với giá từ đại lý thuế. Các doanh nghiệp hoặc cá nhân có thể tải các mẫu đơn từ trang web về, điền thông tin và trình các mẫu đơn này tại 'dịch vụ một điểm”. Đây là một bước tiến lớn trong việc sử dụng công nghệ thông tin truyền thông trong quản lý thuế tại Mông Cổ. Tuy nhiên, chỉ những người có quyền truy cập vào dịch vụ Internet có thể truy cập các website và hưởng lợi từ việc sử dụng này. Một cuộc khảo sát năm 2003 cho thấy, đã có 50.000 người sử dụng chỉ Internet ở Mông Cổ, đại diện cho khoảng 4% dân số. Trong khi dự án đã đạt được hầu hết các mục tiêu của nó, vẫn còn có vấn đề về việc làm thế nào để tiếp cận với các nhóm thiệt thòi, làm thế nào để cải thiện giao diện với người hưởng lợi và đảm bảo sự tham gia của cộng đồng, và làm thế nào để đào tạo lại lực lượng lao động và thay đổi thái độ của tổ chức. Nguồn: Adapted from Mongolian Taxation Authority, http://www.mta.mn. Hệ thống Chính phủ điện tử như cơ quan thuế Mông Cổ có thể làm giảm chi phí giao dịch cho cả hai chính phủ và cho các công dân, qua đó nâng cao thu thuế và tăng tính minh bạch trong hoạt động của chính phủ. Tuy nhiên, trường hợp của Cơ quan thuế của Mông Cổ cũng minh họa những thách thức của chính phủ điện tử mang lại cho người nghèo.",
        "Summary": "Đây là một bước tiến lớn trong việc sử dụng công nghệ thông tin truyền thông trong quản lý thuế tại Mông Cổ. Trong khi dự án đã đạt được hầu hết các mục tiêu của nó, vẫn còn có vấn đề về việc làm thế nào để tiếp cận với các nhóm thiệt thòi, làm thế nào để cải thiện giao diện với người hưởng lợi và đảm bảo sự tham gia của cộng đồng, và làm thế nào để đào tạo lại lực lượng lao động và thay đổi thái độ của tổ chức.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều được lấy trực tiếp từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được trích dẫn liên tiếp nhau và có liên quan đến chủ đề chung. Tuy nhiên, vì là trích đoạn nên sự liên kết giữa các ý có thể chưa được hoàn hảo như một bản tóm tắt được viết lại hoàn toàn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào việc Mông Cổ sử dụng công nghệ thông tin trong quản lý thuế và những thách thức còn tồn tại. Tuy nhiên, việc chỉ trích dẫn hai câu có thể bỏ qua một số chi tiết quan trọng khác, ví dụ như việc trang web của Cơ quan Thuế Mông Cổ cung cấp các dịch vụ gì."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá. Điểm mạnh là tính trung thực cao, đảm bảo thông tin chính xác. Tuy nhiên, để cải thiện, bản tóm tắt nên bao gồm nhiều ý chính hơn từ văn bản gốc để cung cấp cái nhìn toàn diện hơn về chủ đề, đồng thời diễn đạt lại các ý thay vì chỉ trích dẫn để tăng tính mạch lạc."
            }
        }
    },
    {
        "Index": "00003",
        "Article": "JAX-RPC và SAAJ: Java API cho RPC XML-Based (JAX-RPC) và SOAP với Attachments API cho Java (SAAJ) cung cấp giao diện lập trình ứng dụng Java để xử lý các thông điệp SOAP. JAX-RPC cao cấp hơn và được xây dựng trên SAAJ. JAX-RPC xử lý chuyển đổi giữa các đối tượng Java và XML, thực hiện kiểm tra kiểu trong chuyển đổi. JAX-RPC cũng bao gồm các công cụ để tạo ra các tài liệu WSDL từ mã Java và từ các tài liệu WSDL. Đối với SOAP, SAAJ tự xây dựng trên JAXP và cung cấp một API đơn giản hướng về SOAP. Ví dụ, các API bao gồm các phương pháp để quản lý các kết nối SOAP, tạo thông điệp SOAP, trích xuất nội dung thích hợp (tiêu đề, phần thân), và xử lý các phản hồi. Java API cho việc gửi thông điệp XML (JAXM) cung cấp các API cho việc tạo và xử lý bản tin SOAP. JAXM ở mức thấp hơn so với JAX-RPC và đã được thay thế bởi SAAJ. Web Services Invocation Framework: Dịch vụ Web Services Invocation Framework của dự án Apache (WSIF) là một tiếp cận để gọi dịch vụ dựa trên WSDL. WSIF mang quan điểm là client. Tuy nhiên, nó được dựa trên mô tả WSDL của các dịch vụ và về nguyên tắc, là độc lập với các kết nối (binding). Một kết nối cho SOAP có sẵn và quan trọng, nhưng một WSIF client có thể dễ dạng chuyển sang một ràng buộc kết nối khác. JAXR: Java API XML cho XML Registries (JAXR) là một cách tiếp cận dựa trên Java để truy cập vào nhiều loại registry khác nhau, bao gồm cả ISO 11.179, OASIS, ebXML, và UDDI. Nó hữu ích nhất cho việc truy cập một UDDI hoặc ebXML registry để quảng cáo hoặc tìm kiếm một dịch vụ. JAXP: JAXP là một API để xử lý các tài liệu XML. Một trong những thành phần của JAXP là một công cụ phân tích cú pháp dựa trên DOM (Document Object Model). DOM cung cấp một khái niệm đơn giản để duyệt cây phân tích cú pháp của một tài liệu qua xử lý đệ quy. Có một công cụ phân tích cú pháp khác nữa là dựa trên Simple API cho XML (SAX). Hơn nữa, JAXP hỗ trợ các biến đổi XSL (XSLT).",
        "Summary": "JAX-RPC và SAAJ cung cấp API Java để xử lý thông điệp SOAP, trong đó JAX-RPC hỗ trợ chuyển đổi giữa Java và XML, tạo tài liệu WSDL, còn SAAJ cung cấp API đơn giản để quản lý và xử lý thông điệp SOAP. WSIF là một framework của Apache để gọi dịch vụ dựa trên WSDL, hỗ trợ chuyển đổi giữa các kết nối. JAXR cho phép truy cập các registry như UDDI và ebXML, trong khi JAXP hỗ trợ xử lý tài liệu XML, bao gồm phân tích cú pháp DOM, SAX và biến đổi XSLT.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, với sự liên kết tốt giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc và loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo tính súc tích và hiệu quả của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, tính mạch lạc và tính liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin chính xác và trình bày một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00004",
        "Article": "Sự cần thiết của tri thức và lập luận Một yêu cầu quan trọng đối với hệ thống thông minh là phải có khả năng sử dụng tri thức về thế giới xung quanh và lập luận (reasoning) với tri thức đó. Rất khó để đạt được những hành vi thông minh và mềm dẻo mà không có tri thức về thế giới xung quanh và khả năng suy diễn với tri thức đó. Sử dụng tri thức và lập luận đem lại những lợi ích sau. - - Hệ thống dựa trên tri thức có tính mềm dẻo cao. Việc kết hợp tri thức và lập luận (bao gồm suy diễn và suy luận) cho phép tạo ra tri thức khác, giúp hệ thống đạt được những mục tiêu khác nhau, đồng thời có khả năng lập luận về bản thân mục tiêu. Chương trước đã đề cập tới kỹ thuật giải quyết vấn đề bằng cách tìm kiếm. Những hệ thống tìm kiếm chỉ sử dụng tri thức hạn chế, thể hiện trong việc biểu diễn bài toán (như cách sinh ra các chuyển động) và các heuristic. Hệ thống như vậy không có khả năng tự thay đổi mục đích cũng như không có khả năng hành động một cách mềm dẻo, ngoài những gì chứa trong giải thuật và mô tả bài toán. Vì vậy kỹ thuật tìm kiếm là chưa đủ để tạo ra hệ thống thông minh. Sử dụng tri thức và lập luận cho phép hệ thống hoạt động cả trong trường hợp thông tin quan sát về môi trường là không đầy đủ. Hệ thống có thể kết hợp tri thức chung đã có để bổ sung cho thông tin quan sát được khi cần ra quyết định. Ví dụ, khi giao tiếp bằng ngôn ngữ tự nhiên, có thể hiểu một câu ngắn gọn nhờ sử dụng tri thức đã có về ngữ cảnh giao tiếp và nội dung liên quan tới chủ đề. - Việc sử dụng tri thức thuận lợi cho việc xây dựng hệ thống. Thay vì lập trình lại hoàn toàn hệ thống, có thể thay đổi tri thức trang bị cho hệ thống và mô tả mục đích cần đạt được, đồng thời giữ nguyên thủ tục lập luận. Các hệ thống có sử dụng tri thức được gọi là hệ dựa trên tri thức. Hệ thống loại này gồm thành phần cơ bản là cơ sở tri thức (tiếng Anh là Knowledge Base, viết tắt là KB). Cơ sở tri thức gồm các câu hay các công thức trên một ngôn ngữ nào đó và chứa các tri thức về thế giới của bài toán. Cùng với cơ sở tri thức, hệ thống còn có khả năng lập luận, gồm cả suy diễn (inference) và suy luận (deduction), cho phép đưa ra các hành động hoặc câu trả lời hợp lý dựa trên tri thức và thông tin quan sát được. Thực chất, suy diễn hay suy luận là cách tạo ra các câu mới từ những câu đã có. Như vậy, một hệ dựa trên tri thức bao gồm cơ sở tri thức và thủ tục suy diễn.",
        "Summary": "\"Hệ thống thông minh cần tri thức và khả năng lập luận để đạt được hành vi mềm dẻo và thông minh. Việc này giúp hệ thống linh hoạt, tự thay đổi mục đích và hành động ngay cả khi thông tin không đầy đủ, bằng cách kết hợp tri thức chung. Sử dụng tri thức giúp xây dựng hệ thống dễ dàng hơn bằng cách thay đổi tri thức và mục đích, thay vì lập trình lại. Hệ thống dựa trên tri thức (Knowledge-Based System) gồm cơ sở tri thức (Knowledge Base) chứa thông tin về thế giới của bài toán và khả năng lập luận (suy diễn và suy luận) để đưa ra hành động hợp lý.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tóm tắt đúng trọng tâm và có giá trị."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, làm nổi bật được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00005",
        "Article": "Các bước thiết kế chương trình • Xác định bài toán • Phân tích bài toán • Thiết kế thuật toán 5 Chương 1 CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH • Cài đặt chương trình • Thử nghiệm chương trình Định nghĩa. Thuật toán (algorithm) là tập hợp hữu hạn các chỉ thị được định nghĩa rõ ràng nhằm giải quyết một vấn đề cụ thể nào đó. Tính chất. Một thuật toán phải có các tính chất sau • Tính chính xác: quá trình tính toán hay các thao tác máy tính thực hiện là chính xác. • Tính rõ ràng: các câu lệnh minh bạch được sắp xếp theo thứ tự nhất định. • Tính khách quan: được viết bởi nhiều người trên máy tính nhưng kết quả phải như nhau. • Tính phổ dụng: có thể áp dụng cho một lớp các bài toán có đầu vào tương tự nhau. • Tính kết thúc: hữu hạn các bước tính toán Trình bày thuật toán như thế nào? • Trình bày bằng ngôn ngữ tự nhiên • Trình bày bằng mã giả • Trình bày bằng lưu đồ Ví dụ 1.2 Hãy trình bày cách làm món sữa dâu bằng ngôn ngữ tự nhiên Cách 1 • Lấy một ít sữa. • Đổ nước ép dâu vào. • Trộn hỗn hợp này và làm lạnh. Cách 2 • Rót một ly sữa vào máy xay • Đổ thêm vào một ít nước dâu ép • Đóng nắm máy xay • Mở điện và bắt đầu trộn • Dừng máy trộn lại • Nếu đã trộn đều thì tắt máy, ngược lại thì trộn tiếp 6 Chương 1 CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH • Khi đã trộn xong, rót hỗn hợp vào tô và đặt vào tủ lạnh • Để lạnh một lúc rồi lấy ra dùng Ví dụ 1.3 Hãy trình bày cách sắp xếp một dãy số L theo thứ tự tăng dần bằng ngôn ngữ mã giả MergeSort(L) if Size(L)>1 Split(L, L , L ) (tách dãy L thành L và L ) 1 2 1 2 MergeSort(L ) (sắp xếp dãy L ) 1 1 MergeSort(L ) (sắp xếp dãy L ) 2 2 Merge(L , L , L) (trộn dãy L và L thành L) 1 2 1 2 7 Chương 2 LƯU ĐỒ THUẬT TOÁN 2 LƯU ĐỒ THUẬT TOÁN A picture is worth a thousand words thành ngữ Chương này sẽ trình bày các ký hiệu biểu diễn lưu đồ thuật toán, cách biểu diễn các cấu trúc điều khiển rẽ nhánh, cấu trúc lặp và các kỹ thuật liên quan đến lưu đồ thuật toán.",
        "Summary": "Văn bản mô tả khái niệm thuật toán, bao gồm các tính chất như tính chính xác, rõ ràng, khách quan, phổ dụng và tính kết thúc. Thuật toán có thể được trình bày bằng ngôn ngữ tự nhiên, mã giả hoặc lưu đồ. Văn bản minh họa bằng ví dụ về cách làm sữa dâu và sắp xếp mảng số bằng thuật toán MergeSort, nhấn mạnh vào việc sử dụng mã giả để biểu diễn thuật toán. Cuối cùng, văn bản giới thiệu về việc sử dụng lưu đồ để trực quan hóa thuật toán.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa, tính chất, cách trình bày thuật toán và ví dụ minh họa, phản ánh đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00006",
        "Article": "Cách kết hợp hai thuật toán cho phép tìm ra lời giải chất lượng hơn với độ phức tạp tính toán chập nhận được. Kết quả. Thực nghiệm với các trường phổ thông với trên 30 lớp và trên 50 giáo viên cho thấy các kỹ thuật trình bầy ở trên tìm ra thời khoá biểu có chất lượng tốt hơn nhiều (hàm mục tiêu nhỏ hơn nhiều) so với thời khoá biểu xếp bằng tay và các phương pháp heuristic. Quá trình xếp thời khoá biểu có thể thực hiện trên máy tính cá nhân thông thường trong vòng vài phút tới vài chục phút tuỳ kích thước trường. 2.7. CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1. Giả sử ta có ba can đựng nước với dung tích 3 lít, 8 lít và 12 lít. Ta có thể đổ nước đầy các can hoặc rót toàn bộ nước trong can ra ngoài hoặc sang can khác. Cần tìm cách đổ đầy và rót nước khỏi can để đong được 1 lít nước. Trình bầy bài toán này dưới dạng bài toán tìm kiếm và viết chương trình để tìm lời giải, sử dụng một thuật toán tìm kiếm phù hợp. Giải quyết vấn đề bằng tìm kiếm 2. Bài toán nhà truyền giáo và người ăn thịt người. Có ba nhà truyền giáo và ba người thuộc bộ lạc ăn thịt người ở trên bờ một con sông. Cần chuyển cả sáu người sang bờ bên kia bằng một con thuyền có thể chở tối đa hai người. Yêu cầu đặt ra là không có lúc nào số người ăn thịt trên một bờ sông hoặc trên thuyền lớn hơn số nhà truyền giáo. • Hãy phát biểu bài toán dưới dạng bài toán tìm kiếm trong không gian trạng thái và sử dụng thuật toán tìm kiếm phù hợp để tìm ra lời giải. • Xây dựng chương trình máy tính để thực hiện hiện thuật toán.",
        "Summary": "Thực nghiệm với các trường phổ thông với trên 30 lớp và trên 50 giáo viên cho thấy các kỹ thuật trình bầy ở trên tìm ra thời khoá biểu có chất lượng tốt hơn nhiều hàm mục tiêu nhỏ hơn nhiều so với thời khoá biểu xếp bằng tay và các phương pháp heuristic. CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1. Yêu cầu đặt ra là không có lúc nào số người ăn thịt trên một bờ sông hoặc trên thuyền lớn hơn số nhà truyền giáo.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt gần như trung thực. Tuy nhiên, việc trích dẫn hai câu không liên quan đến nhau và đặt cạnh nhau có thể gây hiểu lầm về ý nghĩa ban đầu của văn bản gốc. Câu 'CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1' được chèn vào giữa hai nội dung khác nhau, tạo cảm giác không tự nhiên và có thể không chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt chưa được mạch lạc. Việc trích dẫn các câu từ văn bản gốc một cách rời rạc và không có sự liên kết rõ ràng giữa chúng làm giảm tính mạch lạc của bản tóm tắt. Đặc biệt, việc chèn tiêu đề 'CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1' vào giữa câu làm gián đoạn dòng chảy của ý tưởng."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số chi tiết không thực sự liên quan đến ý chính của đoạn văn. Ví dụ, câu 'CÂU HỎI VÀ BÀI TẬP CHƯƠNG 1' không phải là một phần nội dung cần tóm tắt, mà chỉ là tiêu đề của một phần khác trong văn bản gốc. Việc đưa câu này vào bản tóm tắt làm giảm tính liên quan của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt này có chất lượng ở mức trung bình. Điểm mạnh là nó giữ lại một số thông tin quan trọng từ văn bản gốc. Tuy nhiên, nó mắc phải một số lỗi về tính mạch lạc và tính liên quan, làm giảm giá trị của bản tóm tắt. Để cải thiện, cần tập trung vào việc chọn lọc các ý chính một cách cẩn thận hơn và đảm bảo rằng các ý này được trình bày một cách logic và liên kết với nhau."
            }
        }
    },
    {
        "Index": "00007",
        "Article": "Khi chương trình lớn, việc chia nhỏ chương trình thành các package sẽ thuận lợi hơn cho việc quản lý và phát triển. - Tên gói còn được dùng để định danh lớp cho ứng dụng. - Dòng lệnh khai báo tên khối phải được đặt đầu tiên trong tệp tin mã - Chỉ được khai báo tối đa một tên khối đối với mỗi tệp mã nguồn Java. - Các tệp tin của các lớp nằm cùng gói ứng dụng phải được lưu trong cùng một thư mục (tên thư mục là tên khối) theo cấu trúc khối của dự án. - Tên khối nên đặt theo chữ thường vì tên khối sẽ là tên thư mục tương ứng trong ổ đĩa, tránh nhầm lẫn với tên các tệp tin là tên các lớp của - Khi không phân chia chương trình thành khối (chương trình đơn giản), không cần thiết phải khai báo tên khối ở đầu chương trình. Khai báo thư viện để chỉ ra những thư viện đã được định nghĩa sẵn mà chương trình sẽ tham khảo tới. Cú pháp khai báo thư viện với từ khóa import như sau: Ví dụ, nếu trong chương trình cần đến các thao tác chuyển đổi kiểu dữ liệu tường minh (từ kiểu string sang kiểu int), thì ta sẽ phải tham khảo thư viện java.lang - Nếu muốn khai báo tham khảo nhiều thư viện, phải khai báo tham khảo mỗi thư viện với một từ khóa import. - Nếu chỉ tham khảo một vài lớp trong một thư viện, nên chỉ rõ tham khảo lớp nào, thay vì phải khai báo tham khảo cả gói (bằng kí hiệu “*”) vì tham khảo cả gói sẽ tăng kích thước tệp tin class sau khi biên dịch. - Nếu không tham khảo thư viện nào, không nhất thiết phải khai báo các tham khảo với từ khóa import.",
        "Summary": "Khi chương trình lớn, việc chia nhỏ chương trình thành các package sẽ thuận lợi hơn cho việc quản lý và phát triển. - Các tệp tin của các lớp nằm cùng gói ứng dụng phải được lưu trong cùng một thư mục tên thư mục là tên khối theo cấu trúc khối của dự án. - Tên khối nên đặt theo chữ thường vì tên khối sẽ là tên thư mục tương ứng trong ổ đĩa, tránh nhầm lẫn với tên các tệp tin là tên các lớp của - Khi không phân chia chương trình thành khối chương trình đơn giản, không cần thiết phải khai báo tên khối ở đầu chương trình.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả các thông tin được trình bày trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các ý được trình bày theo một trình tự nhất định và có liên kết với nhau. Tuy nhiên, việc sử dụng dấu '-' ở đầu mỗi câu có thể làm giảm tính trôi chảy khi đọc. Nên sử dụng các liên từ hoặc cấu trúc câu phức tạp hơn để tăng tính liên kết giữa các ý."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt khá liên quan, tập trung vào các ý chính về package trong Java. Tuy nhiên, phần tóm tắt đã bỏ qua phần quan trọng về khai báo thư viện (import), đây là một nội dung lớn thứ hai trong văn bản gốc. Việc lược bỏ hoàn toàn phần này làm giảm giá trị của bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt về tính trung thực và mạch lạc. Tuy nhiên, tính liên quan có thể được cải thiện bằng cách bao gồm các ý chính về khai báo thư viện (import). Cần cân nhắc kỹ hơn về việc lựa chọn các ý quan trọng nhất để đưa vào bản tóm tắt, đảm bảo bao quát được các chủ đề chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00008",
        "Article": "IEEE 802.11 Control Frame: có 6 kiểu control frame • Request-to-Send (RTS) RTS được sử dụng để yêu cầu dành đường truyền như một phần của cơ chế truy cập đường truyền trong 802.11. Duration (D): thời gian cần thiết để việc trao đổi frame giữa các trạm diễn ra. Nó bao gồm thời gian để truyền frame RTS (gồm cả khoảng chèn ngắn giữa các khung SIFS-Short InterFrame Space), thời gian để nhận frame CTS (gồm cả SIFS), thời gian để truyền frame dữ liệu và thời gian để nhận frame ACK (gồm cả SIFS). Receiver address: địa chỉ MAC của đích nhận frame. Transmitter address: địa chỉ MAC của nguồn gởi frame. • Clear To Send (CTS) Frame CTS được dùng để hồi đáp cho frame RTS. Frame này báo cho trạm nhận biết rằng đường truyền đã được dành riêng cho nó trong một khoảng thời gian xác định. Duration (D): giá trị này được lấy từ trường Duration của frame RTS trừ đi thời gian cần để truyền frame CTS và khoảng thời gian SIFS. Receiver address: địa chỉ MAC của đích nhận frame. • Acknowledgment (ACK) Dùng để báo nhận trong quá trình truyền frame. Khi trạm nhận nhận được một frame thì nó sẽ gởi frame ACK đến trạm truyền để thông báo rằng nó đã nhận frame thành công. Duration (D): khoảng thời gian để truyền ACK thường là 0 bởi vì frame mà nó đang báo nhận đã bao gồm khoảng thời gian truyền cần thiết cho cả frame ACK và SIFS. Receiver address: địa chỉ MAC của đích muốn nhận. Power-Save Poll (PS-Poll) Được dùng để chỉ cho AP biết rằng có một trạm không dây đang yêu cầu nhận các frame đã lưu trữ dành cho nó. AID: giá trị AID của client không dây với 2 bit đầu tiên được thiết lập thành 1. BSS Identifier (BSSID): địa chỉ MAC của AP trong mạng Infrastructure. Transmitter Address (TA): địa chỉ MAC của trạm không dây (tron chế độ Power save). CF-End và CF-ACK Các frame này được sử dụng trong hoạt động của chức năng phân phối điểm PCF (Point Co-ordination Function). CF-End báo hiệu sự kết thúc của khoảng thời gian không tranh giành đường truyền CFP (Contention-free period) trong khi CF-End + CF- ACK vừa báo hiệu kết thúc CFP đồng thời cũng kèm theo một lời báo nhận cho frame đã nhận trước đó bởi điểm điều phối (chính là AP). Duration (D): được thiết lập về 0. Receiver address: địa chỉ MAC của đích nhận frame. Đối với frame CF-End thì nó là địa chỉ MAC quảng bá (broadcast) bởi vì mọi trạm phải nhận được thông báo này. BSSID: địa chỉ MAC của AP. IEEE 802.11 Management Frame (MMPDU): có tổng cộng 11 kiểu frame: • Beacon • Probe Request • Probe Response • Association Request • Association Response • Disassociation • Reassociation Request • Reassociation Response • (IBSS) Annoucement Traffic Indication Map • Authentication • Deauthentication . IEEE 802.11 Data Frame (MPDU): • FC – 802.11: Frame Control • D – 802.11: Duration • SC – 802.11: Sequence Control • QC – 802.11e: QoS Control • FCS – 802.11: Frame Check Sequence",
        "Summary": "IEEE 802.11 định nghĩa ba loại frame: Control, Management và Data. Control frame (6 kiểu) bao gồm RTS (yêu cầu đường truyền, chứa thông tin thời gian và địa chỉ), CTS (hồi đáp RTS, báo đường truyền đã được dành riêng), ACK (báo nhận frame thành công), PS-Poll (trạm yêu cầu AP gửi frame đã lưu trữ), CF-End và CF-ACK (sử dụng trong PCF, báo hiệu kết thúc CFP). Management frame (11 kiểu) quản lý kết nối và thông tin mạng. Data frame chứa dữ liệu và các trường điều khiển, thời gian, QoS và kiểm tra lỗi.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, giúp người đọc dễ dàng nắm bắt thông tin. Cách phân loại các loại frame và liệt kê các chức năng chính của từng loại rất hiệu quả."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm các loại frame IEEE 802.11 và chức năng của chúng. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00009",
        "Article": "Mạch Trigơ số (có tên là FlipFlop, viết tắt là FF) là một phần tử logic tuẩn tự hết sức quan trọng và cơ bản trong kỹ thuật điện tử số. Một FF thường có 2 đầu ra và có ít nhất hai đầu vào thực hiện các chức năng tối thiểu sau: \n 1. Có hai trạng thái ra là Q và Q̅ ổn định và có tính liên hợp, khi Q =1 thì Q̅ = 0 và ngược lại khi Q = 0 thì Q̅ = 1. \n 2. Các trạng thái đầu ra không những phụ thuộc vào các trạng thái đầu vào áp đến ngay lúc đang xét mà còn phụ thuộc vào trạng thái quá khứ của mình (trước khi áp tín hiệu vào, Q đang ở trạng thái nào?) \n 3. Có khả năng tiếp nhận (ghi vào), lưu giữ trong một thời gian tùy yêu cầu và đưa ra (đọc ra) một trạng thái (1bít) nhị phân đang được lưu giữ trong FF. \n 4. Việc mở rộng chức nãng của FF sẽ được thực hiện nhờ có các đầu vào điều khiến hành vì của FF ngoài các đầu vào tín hiệu đã nói tới (xóa tín hiệu đang lưu, cho phép ghi hay đọc...). Có thể sử dụng các cách sau để thực hiện chức năng của một FF: \n a) Áp tới các lối vào (gọi là lối vào dữ liệu) mức điện thế thích hợp với mức logic 0 hay mức logic 1 - đây là loại FF làm việc ở chế độ không đồng bộ. \n b) Đồng thời với việc trên cần có một lối vào đặc biệt (gọi là đầu vào nhịp) để đưa tới 1 tín hiệu điều khiển (ở mức 1 hoặc mức 0 hoặc lúc ở mức 1 về mức 0 hay lúc ở mức 0 lên mức 1). Chỉ khi xuất hiện tín hiệu điều khiển này (còn được gọi là tín hiệu đồng bộ) khả năng làm việc của FF mới được thực hiện với các đầu vào dữ liệu, đây là loại FF làm việc ở chế độ đồng bộ. \n c) Chỉ sử dụng 1 trong số 2 đầu vào đặc biệt gọi là đầu vào điều khiển trực tiếp ghi hay xoá (xem hình 4.3) mà không dùng hai cách đã nêu trên.",
        "Summary": "Mạch Trigơ số (Flip-Flop - FF) là phần tử logic tuần tự cơ bản trong kỹ thuật điện tử số. FF có hai đầu ra Q và Q̅ (luôn trái trạng thái), có khả năng ghi, lưu giữ và đọc ra 1 bit nhị phân. FF hoạt động ở chế độ không đồng bộ (áp mức điện thế vào lối vào dữ liệu), chế độ đồng bộ (kết hợp lối vào dữ liệu và tín hiệu điều khiển ở đầu vào nhịp) hoặc sử dụng đầu vào điều khiển trực tiếp để ghi/xóa.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, chức năng và các chế độ hoạt động của Flip-Flop, là những thông tin cốt lõi."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được những ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu."
            }
        }
    },
    {
        "Index": "00010",
        "Article": "I.3.2. Ẩn hiện một Tab lệnh\n Để làm ẩn hay xuất hiện một nhóm lệnh hoặc một Tab lệnh trong thanh công cụ Ribbon làm\n như sau:\n - Nhấp phải chuột vào một khoảng trống bất kỳ trên thanh công cụ Ribbon.\n - Một menu nhanh xuất hiện chọn Customize the Ribbon, hộp thoại Excel Option xuất\n hiện và trỏ tới mục Customize the Ribbon.\n - Trong danh sách Main Tabs bên phía tay phải của màn hình liệt kê danh sách các Tab\n Ribbon muốn ẩn Tab nào chỉ cần bỏ dấu tính ở đầu tên Tab đó. Ngược lại muốn hiện\n chúng lên đánh dấu tính cho những Tab bị ẩn. Cuối cùng nhấp OK để lưu lại.\n Lưu ý: Trường hợp muốn ẩn toàn bộ thanh công cụ Ribbon, nhấp chọn biểu tượng Minimize\n the Ribbon (hoặc nhấn tổ hợp phím Ctrl + F1) phía góc phải trên của màn hình chính.\n Khi muốn hiện lại thanh công cụ này, nhấp chuột vào nút lệnh đó một lần nữa.\n I.3.3. Tự tạo một Tab lệnh và các nhóm lệnh trên thanh công cụ Ribbon\n Ngoài những Tab lệnh sẵn có Microsoft Excel còn cung cấp cho người dùng chức năng tự tạo\n ra các Tab lệnh mới, cách thực hiện như sau:\n - Nhấp phải chuột vào một khoảng trống bất kỳ trên thanh công cụ Ribbon.\n - Một menu nhanh xuất hiện, chọn Customize the Ribbon, hộp thoại Excel Option xuất\n hiện và trỏ tới mục Customize the Ribbon.\n - Để thêm một Tab mới, nhấp chọn nút New Tab, một Tab, một nhóm lệnh mới xuất\n hiện như hình dưới đây:\n - Có thể đổi tên cho Tab bằng cách nhấp chuột phải vào Tab này chọn Rename\n - Làm tương tự để đổi tên cho nhóm lệnh\n - Ngoài ra có thể bổ xung các nhóm lệnh khác vào Tab này bằng cách nhấp chọn Tab\n vừa thêm rồi nhấn nút New Group\n Kết quả Tab các lệnh sẽ có được như hình dưới đây\n Công việc cuối cùng của là chọn những lệnh cần thiết để bổ xung vào các nhóm lệnh tương\n ứng. Cuối cùng nhấp OK để hoàn tất.\n Tab lệnh vừa tạo khi xuất hiện trên màn hình chính của chương trình sẽ như hình dưới đây:\n Đây là một ví dụ cơ bản hoàn toàn có thể tạo ra các Tab lệnh được bố trí khoa học và thuận\n tiện cho quá trình sử dụng.",
        "Summary": "\"Để ẩn/hiện Tab lệnh trên thanh Ribbon trong Excel, nhấp chuột phải vào Ribbon, chọn Customize the Ribbon, bỏ/đánh dấu vào ô tương ứng với Tab cần ẩn/hiện. Để ẩn toàn bộ Ribbon, chọn Minimize the Ribbon (Ctrl+F1). Người dùng cũng có thể tự tạo Tab lệnh mới bằng cách chọn New Tab trong Customize the Ribbon, đổi tên Tab và nhóm lệnh, sau đó thêm các lệnh cần thiết vào nhóm. Tab mới tạo sẽ xuất hiện trên thanh Ribbon.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, dễ hiểu. Các câu liên kết với nhau một cách trôi chảy, tạo thành một dòng thông tin liên tục và có ý nghĩa."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào cách ẩn/hiện Tab lệnh và cách tạo Tab lệnh mới trên thanh Ribbon, đúng như nội dung chính của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách ngắn gọn, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00011",
        "Article": "Ngôn ngữ lập trình java có 8 kiểu dữ liệu cơ sở: byte, short, int, long, float, double, boolean và char. 24 Kiểu Kích thước (bytes) Giá trị min Giá trị max Giá trị mặc định byte 1 -256 255 0 short 2 -32768 32767 0 int 4 -231 2 31 - 1 0 long 8 -263 2 63 - 1 0L float 4 0.0f double 8 0.0d 2.2.1.Kiểu số nguyên - Java cung cấp 4 kiểu số nguyên khác nhau là: byte, short, int, long. Kích thước, giá trị nhỏ nhất, lớn nhất, cũng như giá trị mặc định của các kiểu dữ liệu số nguyên được mô tả chi tiết trong bảng trên. - Kiểu mặc định của các số nguyên là kiểu int. - Các số nguyên kiểu byte và short rất ít khi được dùng. - Trong java không có kiểu số nguyên không dấu như trong ngôn ngữ C/C++. Kiểu cơ sở Kiểu luận lý boolean Kiểu số kiểu nguyên kiểu thực Kiểu ký tự char byte short int long float double 25 Khai báo và khởi tạo giá trị cho các biến kiểu nguyên: int x = 0; long y = 100; Một số lưu ý đối với các phép toán trên số nguyên: - Nếu hai toán hạng kiểu long thì kết quả là kiểu long. Một trong hai toán hạng không phải kiểu long sẽ được chuyển thành kiểu long trước khi thực hiện phép toán. - Nếu hai toán hạng đầu không phải kiểu long thì phép tính sẽ thực hiện với kiểu int. - Các toán hạng kiểu byte hay short sẽ được chuyển sang kiểu int trước khi thực hiện phép toán. - Trong java không thể chuyển biến kiểu int và kiểu boolean như trong ngôn ngữ C/C++. Ví dụ: có đoạn chương trình như sau boolean b = false; if (b == 0) { System.out.println(\"Xin chao\"); } Lúc biên dịch đoạn chương trình trên trình dịch sẽ báo lỗi: không được phép so sánh biến kiểu boolean với một giá trị kiểu int. 26 2.2.2.Kiểu dấu chấm động Đối với kiểu dấu chấm động hay kiểu thực, java hỗ trợ hai kiểu dữ liệu là float và double. Kiểu float có kích thước 4 byte và giá trị mặc định là 0.0f Kiểu double có kích thước 8 byte và giá trị mặc định là 0.0d Số kiểu dấu chấm động không có giá trị nhỏ nhất cũng không có giá trị lớn nhất. Chúng có thể nhận các giá trị: - Số âm - Số dương - Vô cực âm - Vô cực dương Khai báo và khởi tạo giá trị cho các biến kiểu dấu chấm động: float x = 100.0/7; double y = 1.56E6; Một số lưu ý đối với các phép toán trên số dấu chấm động: - Nếu mỗi toán hạng đều có kiểu dấn chấm động thì phép toán chuyển thành phép toán dấu chấm động. - Nếu có một toán hạng là double thì các toán hạng còn lại sẽ được chuyển thành kiểu double trước khi thực hiện phép toán. - Biến kiểu float và double có thể ép chuyển sang kiểu dữ liệu khác trừ kiểu boolean. 2.2.3.Kiểu ký tự (char) Kiểu ký tự trong ngôn ngữ lập trình java có kích thước là 2 bytes và chỉ dùng để biểu diễn các ký tự trong bộ mã Unicode. Như vậy kiểu char trong java có thể biểu diễn tất cả 216 = 65536 ký tự khác nhau. Giá trị mặc định cho một biến kiểu char là null. 27 2.2.4.Kiểu luận lý (boolean) - Kiểu boolean chỉ nhận 1 trong 2 giá trị: true hoặc false. - Trong java kiểu boolean không thể chuyển thành kiểu nguyên và ngược lại. - Giá trị mặc định của kiểu boolean là false.",
        "Summary": "Java cung cấp 8 kiểu dữ liệu cơ sở, bao gồm các kiểu số nguyên (byte, short, int, long), số thực (float, double), ký tự (char) và luận lý (boolean). Các kiểu số nguyên có kích thước và phạm vi giá trị khác nhau, với kiểu `int` là kiểu mặc định. Kiểu số thực `float` và `double` biểu diễn số dấu chấm động, có thể nhận giá trị âm, dương, vô cực. Kiểu `char` sử dụng mã Unicode 2 byte, trong khi kiểu `boolean` chỉ nhận hai giá trị `true` hoặc `false` và không thể chuyển đổi trực tiếp sang kiểu số.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các kiểu dữ liệu cơ bản trong Java và đặc điểm chính của từng kiểu."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về các kiểu dữ liệu cơ bản trong Java. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00012",
        "Article": "Mức độ bảo mật của SSL như trên mô tả phụ thuộc chính vào độ dài khoá hay phụ thuộc vào việc sử dụng phiên bản mã hoá 40 bits và 128bits. Phương pháp mã hoá 40 bits được sử dụng rộng rãi không hạn chế ngoài nước Mỹ và phiên bản mã hoá 128 bits chỉ được sử dụng trong nước Mỹ và Canada. Theo luật pháp Mỹ, các mật mã \"mạnh\" được phân loại vào nhóm \"vũ khí\" (weapon) và do đó khi sử dụng ngoài Mỹ (coi như là xuất khẩu vũ khí) phải được phép của chính phủ Mỹ hay phải được cấp giấy phép của Bộ Quốc phòng Mỹ (DoD). Đây là một lợi điểm cho quá trình thực hiện các dịch vụ thương mại và thanh toán điện tử trong Mỹ và các nước đồng minh phương Tây và là điểm bất lợi cho việc sử dụng các sản phẩm cần có cơ chế bảo mật và an toàn trong giao dịch điện tử nói chung và thương mại điện tử nói riêng trong các nước khác.\n Các phương thức tấn công (hay bẻ khoá) của các thuật toán bảo mật thường dùng dựa trên phương pháp \"tấn công vét cạn\" (brute-force attack) bằng cách thử-sai miền không gian các giá trị có thể của khoá. Số phép thử-sai tǎng lên khi độ dài khoá tăng và dẫn đến vượt quá khả nǎng và công suất tính toán, kể cả các siêu máy tính hiện đại nhất. Thí dụ, với độ dài khoá là 40 bits, thì số phép thử sẽ là 240=1,099,511,627,776 tổ hợp. Tuy nhiên độ dài khoá lớn kéo theo tốc độ tính toán giảm (theo luỹ thừa nghịch đảo) và dẫn đến khó có khả nǎng áp dụng trong thực tiễn. Một khi khoá bị phá, toàn bộ thông tin giao dịch trên mạng sẽ bị kiểm soát toàn bộ. Tuy nhiên do độ dài khoá lớn (thí dụ 128 bits, 256 bits), số phép thử-sai trở nên \"không thể thực hiện\" vì phải mất hàng năm hoặc thậm chí hàng nghìn nǎm với công suất và nǎng lực tính toán của máy tính mạnh nhất hiện nay.\n Ngay từ năm 1995, bản mã hoá 40 bits đã bị phá bởi sử dụng thuật toán vét cạn. Ngoài ra, một số thuật toán bảo mật (như DES 56 bits, RC4, MD4,...) hiện nay cũng bị coi là không an toàn khi áp dụng một số phương pháp và thuật toán tấn công đặc biệt. Đã có một số đề nghị thay đổi trong luật pháp Mỹ nhằm cho phép sử dụng rộng rãi các phần mềm mã hoá sử dụng mã hoá 56 bits song hiện nay vẫn chưa được chấp thuận.",
        "Summary": "\"Mức độ bảo mật của SSL phụ thuộc vào độ dài khóa mã hóa (40 bits hoặc 128 bits). Mã hóa 40 bits được sử dụng rộng rãi ngoài Mỹ, trong khi 128 bits giới hạn ở Mỹ và Canada do luật pháp Mỹ coi mật mã mạnh như \"vũ khí\". Việc \"tấn công vét cạn\" (brute-force attack) để bẻ khóa trở nên khó khăn hơn khi độ dài khóa tăng, nhưng khóa dài cũng làm giảm tốc độ tính toán. Mã hóa 40 bits đã bị phá từ năm 1995, và một số thuật toán khác cũng bị coi là không an toàn.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc có thể dễ dàng hiểu được nội dung chính của văn bản gốc thông qua bản tóm tắt này."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào mức độ bảo mật của SSL, sự khác biệt trong việc sử dụng mã hóa ở các quốc gia khác nhau, và các phương pháp tấn công bảo mật."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00013",
        "Article": "Mã hóa âm thanh và hình ảnh là kỹ thuật biểu diễn dữ liệu đa phương tiện trong máy tính, chuyển đổi tín hiệu analog thành dạng số để lưu trữ và xử lý. Đối với âm thanh, PCM (Pulse Code Modulation) là phương pháp cơ bản, lấy mẫu tín hiệu âm thanh (sampling) ở tần số cố định, như 44.1kHz trong CD, rồi lượng tử hóa (quantization) thành giá trị nhị phân, thường 16 bit/mẫu, tạo dãy số biểu diễn biên độ sóng âm. Tần số lấy mẫu cao hơn (96kHz, 192kHz) tăng chất lượng nhưng đòi hỏi dung lượng lớn, trong khi độ sâu bit (bit depth) cao hơn cải thiện độ chính xác. Mã nén như MP3 dùng thuật toán psychoacoustic, loại bỏ tần số con người không nghe được, giảm kích thước tệp từ 10MB/phút (PCM) xuống 1MB/phút, dù mất mát (lossy). Mã FLAC (lossless) nén mà không mất dữ liệu, tiết kiệm 50% dung lượng so với PCM. Hình ảnh tĩnh dùng mã hóa bitmap, gán mỗi điểm ảnh (pixel) một giá trị RGB, như 24 bit (8 bit đỏ, xanh, lục) cho 16 triệu màu; ảnh 1920x1080 chiếm khoảng 6MB chưa nén. JPEG nén lossy bằng cách chuyển sang miền tần số (DCT – Discrete Cosine Transform), loại bỏ chi tiết nhỏ, giảm dung lượng còn vài trăm KB, phù hợp web hoặc lưu trữ. PNG (lossless) dùng nén LZW, giữ chất lượng nhưng lớn hơn JPEG. Video kết hợp mã hóa hình ảnh và âm thanh, như MPEG-4, nén không gian (spatial) trong từng khung và thời gian (temporal) giữa các khung, chỉ lưu thay đổi (motion compensation), giảm từ hàng GB xuống MB. Chuẩn H.264/H.265 cải tiến nén, hỗ trợ 4K với bitrate thấp. Các mã này cần cân bằng giữa chất lượng, dung lượng, và tốc độ xử lý, với phần cứng như GPU hoặc DSP hỗ trợ giải mã thời gian thực. Mã hóa âm thanh và hình ảnh không chỉ tối ưu hóa lưu trữ mà còn định hình cách máy tính xử lý đa phương tiện trong truyền thông và giải trí.",
        "Summary": "Mã hóa âm thanh và hình ảnh là kỹ thuật chuyển đổi dữ liệu đa phương tiện thành định dạng số để lưu trữ, truyền tải và xử lý. Các định dạng phổ biến gồm MP3, AAC cho âm thanh và MPEG, H.264 cho hình ảnh. Mã hóa giúp giảm dung lượng dữ liệu mà vẫn giữ được chất lượng chấp nhận được, hỗ trợ truyền phát qua mạng hoặc lưu trữ lâu dài. Đây là công nghệ thiết yếu trong truyền hình số, phát trực tuyến và các ứng dụng đa phương tiện hiện đại.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt nhìn chung trung thực, tuy nhiên có một vài chi tiết không hoàn toàn khớp với văn bản gốc. Ví dụ, bản tóm tắt đề cập đến AAC như một định dạng âm thanh phổ biến, nhưng văn bản gốc không trực tiếp nhắc đến nó. Ngoài ra, việc tóm tắt 'truyền tải' dữ liệu không được đề cập trực tiếp trong văn bản gốc, mặc dù nó là một hệ quả logic của việc mã hóa và lưu trữ."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu liên kết với nhau một cách logic và dễ hiểu. Tuy nhiên, có thể cải thiện bằng cách làm rõ hơn mối quan hệ giữa các định dạng mã hóa và mục đích sử dụng của chúng."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính của văn bản gốc, như mục đích của mã hóa âm thanh và hình ảnh, các định dạng phổ biến và vai trò của nó trong các ứng dụng đa phương tiện. Tuy nhiên, có thể lược bỏ một số chi tiết ít quan trọng hơn để tập trung vào các khía cạnh kỹ thuật của mã hóa, như các phương pháp nén lossy và lossless."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, truyền tải được ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Tuy nhiên, có thể cải thiện bằng cách tăng tính chính xác trong việc lựa chọn thông tin và làm rõ hơn mối liên hệ giữa các khái niệm kỹ thuật. Cần đảm bảo mọi thông tin đều xuất phát trực tiếp từ văn bản gốc và tránh đưa thêm các chi tiết không có trong đó."
            }
        }
    },
    {
        "Index": "00014",
        "Article": "2. TỔNG QUAN NGHIÊN CỨU\n 2.1. Công nghệ thực tế ảo (VR)\n Công nghệ thực tế ảo, tiếng anh là Virtual Reality (tên viết tắt: VR) hiện nay có rất nhiều định nghĩa\n trên toàn thế giới.\n Theo sách “Virtual Reality” của tác giả Steven M. LaValle, công nghệ thực tế ảo được định nghĩa là\n một hệ thống máy tính mô phỏng một môi trường ảo được hiển thị cho sinh vật có thể cảm nhận được\n giống như thực tế [2].\n Khi sử dụng công nghệ sẽ mang lại nhiều lợi ích, bao gồm:\n - Trải nghiệm tương tác độc đáo\n - Nâng cao chất lượng đào tạo\n - Tiết kiệm chi phí và thời gian\n - Tạo ra cơ hội sáng tạo\n Phần cứng của hệ thống VR được phân loại gồm có 3 thành phần chính (Hình 3) [2]:\n - Cảm biến (đầu vào): thiết bị trích xuất thông tin từ thế giới thực, kích thích giác quan của người\n dùng, tạo cảm giác thật trong môi trường ảo.\n - Máy tính (xử lý): Thiết bị xử lý dữ liệu đầu vào và đầu ra\n - Màn hình (đầu ra): hiển thị mô phỏng thông qua đồ họa, âm thanh, xung lực.2.2. Ứng dụng công nghệ thực tế ảo\n Công nghệ VR tạo ra một môi trường tương tác rất hấp dẫn và chân thực, cho phép người dùng có\n những trải nghiệm mới mẻ và đắm chìm trong thế giới ảo mà không cần phải đi thực tế. Vì vậy, công\n nghệ này được áp dụng trong nhiều lĩnh vực.\n Trong ngành công nghiệp Game giải trí, công nghệ mở ra cho người chơi đắm chìm vào môi trường\n ảo, tạo ra cảm giác sống động và thực sự như đang ở trong trò chơi. Các tựa game sử dụng VR mang\n lại trải nghiệm độc đáo và thú vị, từ các Game chiến đấu trong không gian vũ trụ đến việc khám phá\n thế giới huyền bí [2].\n VR mở ra không gian sáng tạo mới, cho phép các nhà làm phim trong lĩnh vực điện ảnh tạo ra các\n trải nghiệm tương tác độc đáo và góp phần tạo nên các bộ phim bom tấn [3].\n Bên cạnh đó, thay vì chỉ sử dụng các phần mềm họp trực tuyến thông thường, VR cho phép các thành\n viên tham gia họp từ xa trong môi trường ảo như thật. Điều này tạo ra cảm giác như đang gặp mặt\n trực tiếp, giúp cho hiệu quả cuộc họp và tương tác giữa các thành viên tốt hơn [4].",
        "Summary": "\"Công nghệ thực tế ảo (VR) là hệ thống máy tính mô phỏng môi trường ảo, mang lại trải nghiệm tương tác độc đáo, nâng cao chất lượng đào tạo, tiết kiệm chi phí và tạo cơ hội sáng tạo. Phần cứng VR gồm cảm biến (đầu vào), máy tính (xử lý) và màn hình (đầu ra). VR được ứng dụng rộng rãi trong Game giải trí, điện ảnh (tạo trải nghiệm tương tác) và họp trực tuyến (tạo cảm giác gặp mặt trực tiếp).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính về định nghĩa VR, lợi ích, thành phần phần cứng và ứng dụng đều được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ định nghĩa đến lợi ích, thành phần và ứng dụng. Các câu liên kết với nhau một cách tự nhiên, tạo thành một đoạn văn dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Các ý chính được trình bày rõ ràng và logic, giúp người đọc nhanh chóng nắm bắt được nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00015",
        "Article": "AI đang ngày càng khẳng định vai trò quan trọng trong việc cải thiện quản lý và phân phối tài nguyên, đồng thời nâng cao chất lượng dịch vụ và trải nghiệm bệnh nhân trong ngành y tế. Việc áp dụng AI vào quản lý tài nguyên giúp tối ưu hóa quy trình, giảm lãng phí và bảo đảm rằng các nguồn lực được sử dụng hiệu quả. Các hệ thống AI có khả năng phân tích dữ liệu lớn, dự đoán nhu cầu và tự động điều chỉnh việc phân phối tài nguyên, từ đó giúp các tổ chức y tế hoạt động hiệu quả hơn. Một ứng dụng nổi bật của AI trong quản lý tài nguyên là hệ thống quản lý chuỗi cung ứng thông minh. Hệ thống này theo dõi và dự báo nhu cầu về thuốc, thiết bị y tế và vật tư khác, giúp giảm tình trạng thiếu hụt hoặc dư thừa. AI còn hỗ trợ trong việc lập kế hoạch và điều phối nhân lực, bảo đảm bác sĩ và nhân viên y tế được phân bổ hợp lý, nâng cao hiệu quả làm việc và giảm áp lực công việc. Lý do chính khiến chi tiêu cho chăm sóc sức khỏe quá mức là do phân bổ đáng kể vào chi phí hành chính bao gồm nhiều nhiệm vụ “thừa” như xem xét hồ sơ bệnh nhân, ghi chép các cuộc gặp gỡ và quản lý hồ sơ y tế. Nhiệm vụ hành chính là không thể thiếu trong hệ thống chăm sóc sức khỏe; tuy nhiên, chúng tiêu tốn một lượng thời gian và công sức đáng kể. Trung bình, y tá ở Hoa Kỳ dành 25% giờ làm việc của mình cho các nhiệm vụ hành chính6 . Mặc dù những nhiệm vụ này cần thiết, nhưng AI có tiềm năng tự động hóa và hợp lý hóa chúng, giảm gánh nặng cho nhà cung cấp dịch vụ và tối ưu hóa quy trình. Bằng cách phân công các nhiệm vụ lặp đi lặp lại cho AI, thời gian quý báu có thể được dành cho các tương tác chăm sóc bệnh nhân. Ngoài quản lý tài nguyên, AI còn nâng cao chất lượng dịch vụ và trải nghiệm bệnh nhân. Các trợ lý ảo y tế sử dụng AI để cung cấp thông tin và hỗ trợ bệnh nhân 24/7, trả lời câu hỏi, nhắc lịch uống thuốc, và theo dõi triệu chứng, giúp bệnh nhân an tâm và giảm bớt gánh nặng cho nhân viên y tế. Hệ thống đặt lịch hẹn thông minh và quản lý bệnh án điện tử cũng sử dụng AI để tối ưu hóa quy trình khám chữa bệnh, giảm thời gian chờ đợi và nâng cao chất lượng chăm sóc. Nhờ đó, AI mang lại những thay đổi tích cực trong quản lý và phân phối tài nguyên, góp phần nâng cao chất lượng dịch vụ và trải nghiệm bệnh nhân. Sự kết hợp giữa công nghệ AI và các phương pháp quản lý hiện đại giúp các tổ chức y tế hoạt động hiệu quả hơn, mang lại lợi ích thiết thực cho bệnh nhân và cộng đồng.",
        "Summary": "AI đóng vai trò quan trọng trong quản lý tài nguyên y tế, giúp tối ưu hóa quy trình, dự báo nhu cầu, điều phối nhân lực và tự động hóa các nhiệm vụ hành chính, từ đó giảm lãng phí và nâng cao hiệu quả hoạt động. Ngoài ra, AI cải thiện chất lượng dịch vụ và trải nghiệm bệnh nhân thông qua trợ lý ảo y tế, hệ thống đặt lịch hẹn thông minh và quản lý bệnh án điện tử, giúp giảm thời gian chờ đợi và nâng cao chất lượng chăm sóc. Sự kết hợp giữa AI và quản lý hiện đại mang lại lợi ích thiết thực cho cả tổ chức y tế và bệnh nhân.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào vai trò của AI trong quản lý tài nguyên và cải thiện dịch vụ y tế."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00016",
        "Article": "Là một Designer, đôi lúc bạn sẽ phải đối mặt với một căn bệnh cực kì khó chịu “Cạn ý tưởng” hoặc “Ý tưởng chưa về”. Những lúc đó bạn phải làm gì? cứ ngồi đó và đợi nó hết ư? Đối với mình thì mình không làm thế đâu các bạn. Mình phải chủ động tìm ý tưởng, và đây là những nơi mà mình thường làm khi phải đối mặt với vần đề trên. IDEA FOR DESIGN Liều thuốc Quên Đôi lúc thì đối mặt trực tiếp không giải quyết được vấn đề gì đâu các bạn. Nếu các bạn cứ căn óc, mở hai mắt ra mà đối mặt thì hậu quả sẽ là các bạn sẽ bị stress nặng đấy. Cho nên, lời khuyên của mình là hãy Start > Shutdown cái máy tính. Rời bàn làm việc và gọi cho những người bạn thân, các bạn có thể đi giải trí ở đâu đó tùy ý như đi xem phim, đá banh, đánh banh, tenis,… rất nhiều các bạn ạ, mỗi người một sở thích mà, riêng mình thì phim hài của Châu Tinh Trì là lựa chọn số 1. Các bạn có thể dành một ngày để vui chơi, lúc đó, đầu ốc của mình sẽ trở nên cực kì thoái mái. Có thể ý tưởng sẽ tới lúc vui chơi, cũng có thể nó sẽ xuất hiện trong giấc ngủ chẳng hạn. ^^! Và hãy bắt đầu công việc vào ngày hôm sau với tình thần thật thoải mái. Phát triển Web 2012 32 www.izwebz.com Demon Warlock Liều thuốc Notebook Đôi lúc, ý tưởng chợt ùa về, lúc đó bạn sẽ làm thế nào nhỉ? Tớ thì có một cuốn notebook, lúc nào cũng có bên mình, có ý tưởng thì vẽ ra ngay và để dành đó. Sẽ có những lúc death-line cận kề rồi mà ý tưởng nó cứ ở đâu đâu ấy, chưa về tới. Lúc này cuốn notebook lại là vũ khí quan trọng đấy.",
        "Summary": "Khi đối mặt với tình trạng \"cạn ý tưởng\" trong thiết kế, thay vì chờ đợi, tác giả khuyên nên chủ động tìm kiếm ý tưởng bằng cách: (1) Tạm dừng công việc, thư giãn, giải trí để đầu óc thoải mái, biết đâu ý tưởng sẽ đến bất ngờ; (2) Ghi chép mọi ý tưởng thoáng qua vào sổ tay để sử dụng khi cần thiết, đặc biệt là khi thời hạn công việc đang đến gần.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Tóm tắt tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các ý được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ thông điệp quan trọng nhất của bài viết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00017",
        "Article": "Bức tường lửa với cổng giao tiếp ở tầng ứng dụng, hay còn gọi là proxy, đóng vai trò như một trung gian giữa người dùng và dịch vụ mà họ muốn truy cập. Proxy có quyền truy cập đầy đủ vào giao thức ứng dụng, giúp kiểm soát và bảo vệ hệ thống mạng hiệu quả hơn. Khi người dùng gửi yêu cầu truy cập một dịch vụ, proxy sẽ tiếp nhận yêu cầu, kiểm tra xem nó có hợp lệ không, sau đó xử lý và gửi phản hồi lại cho người dùng. Điều này giúp proxy có thể giám sát và kiểm soát luồng dữ liệu ở tầng ứng dụng, tăng cường khả năng bảo mật bằng cách ngăn chặn các yêu cầu độc hại hoặc không hợp lệ ngay từ đầu. Tuy nhiên, để hoạt động hiệu quả, mỗi dịch vụ cần có một proxy chuyên biệt, phù hợp với giao thức mà nó hỗ trợ. Một số dịch vụ, chẳng hạn như HTTP hoặc FTP, có thể tích hợp với proxy một cách tự nhiên mà không cần thay đổi nhiều. Trong khi đó, một số dịch vụ khác yêu cầu giải quyết các vấn đề liên quan đến giao thức và cách thức vận hành của chúng để có thể hoạt động qua proxy một cách hiệu quả. Nhờ khả năng kiểm tra chi tiết từng yêu cầu ở tầng ứng dụng, proxy giúp bảo vệ hệ thống khỏi các cuộc tấn công tinh vi, kiểm soát nội dung truy cập và thậm chí hỗ trợ cân bằng tải trong một số trường hợp. Ngoài ra, proxy còn giúp ẩn danh người dùng bằng cách che giấu địa chỉ IP thực của họ, tăng cường quyền riêng tư trong khi duyệt web. Mặc dù mang lại nhiều lợi ích, việc triển khai proxy cũng đòi hỏi tài nguyên đáng kể, có thể làm chậm kết nối nếu không được tối ưu hóa tốt. Dù vậy, với khả năng bảo vệ mạnh mẽ và kiểm soát chi tiết các yêu cầu truy cập, proxy vẫn là một thành phần quan trọng trong nhiều hệ thống tường lửa hiện đại, đặc biệt là trong các môi trường yêu cầu bảo mật cao.",
        "Summary": "Proxy, là một thành phần trong tường lửa ở tầng ứng dụng, đóng vai trò như trung gian giữa người dùng và dịch vụ, giúp kiểm soát và bảo vệ hệ thống mạng bằng cách kiểm tra và xử lý yêu cầu truy cập. Nó giúp ngăn chặn các yêu cầu độc hại, bảo vệ hệ thống khỏi tấn công tinh vi, và có thể ẩn danh người dùng để tăng cường quyền riêng tư. Tuy nhiên, việc triển khai proxy có thể yêu cầu tài nguyên đáng kể và ảnh hưởng đến hiệu suất kết nối nếu không được tối ưu hóa tốt.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải được thông điệp quan trọng nhất của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Bản tóm tắt đã làm nổi bật được vai trò, lợi ích và hạn chế của proxy một cách ngắn gọn và đầy đủ. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00018",
        "Article": "Purchasing offers and discounts Chiết khấu trong mua bán Cách thức xuất vận sản phẩm Tiêu chí 2 : Đánh giá một Website thƣơng mại điện tử dựa trên các tiêu chí sau: Các yếu tố kỹ thuật Những nội dung cần công bố Giải quyết tranh chấp va bảo mật thông tin Trọng số biểu thị mức độ quan trọng của tiêu chí Các yếu tố kỹ thuật: 1.Thời gian tải các website bằng modem thông thƣờng 3.Bố trí các liên kết trong website 4.Công cụ tìm kiếm trong nội bộ website 5.Thông số an toàn của website Những nội dung cần công bố: 1.Thông tin liên hệ và giới thiệu về ngƣời ngƣời quản lý website và 2.Các điều kiện và điều khoản quy định cách thức kinh doanh trƣớc khi tiến hành giao dịch 3.Thông tin giới thiệu , mô tả về hàng hóa , dịch vụ 4.Thông tin về chi phí , giá cả , lệ phí 1.Cho phép khách hàng xem xét , điều chỉnh đơn đặt hàng 2.Xác nhận các đơn đặt hàng 3.Hệ thống thanh toán an toàn , dễ sử dụng 4.Giao hàng hóa và dich vụ theo thời gian và điều kiện thỏa thuận Giải quyết tranh chấp và bảo mật thông tin: 1.Chính sách riêng cho việc sử lý và giải quyết khiếu lại , tranh chấp 2.Chính sách bảo vệ thông tin của khách hàng Quy trình phát triển website chuẩn đƣợc mô phỏng theo mô hình thác nuớc, các giai đọan chủ chốt đƣợc chia thành các công đọan nhỏ hơn, cho phép thực hiện việc thiết kế web song song một lúc nhiều công đọan. Quy trình chuẩn có thể đƣợc thêm, bớt hoặc thay đổi để phù hợp với nhu cầu của dự án.  Các bước trong quy trình chuẩn:  Bước 1: Lấy thông tin yêu cầu và nghiên cứu tính khả thi Ngay từ giai đoạn đầu, sẽ chỉ định một ngƣời làm đầu mối quản lý account manager để giữ mối liên hệ thƣờng xuyên với ngƣời yêu cầu thực hiện Website trong suốt thời gian thực hiện dự án website. Ngƣời yêu cầu thực hiện Website sẽ thảo luận về yêu cầu và xác định mục tiêu chính cho website cho đơn vị thiết kế Website. Khi đơn vị thiết kế Website hiểu rõ mục đích chủ yếu của ngƣời yêu cầu thực hiện Website, đơn vị thiết kế Website sẽ xác định gói thiết kế Website phù hợp với yêu cầu của ngƣời làm đầu mối nhất. Đơn vị thiết kế Website sẽ cung cấp cho ngƣời làm đầu mối một kế hoạch xây dựng Website để giúp ngƣời làm đầu mối giải quyết tốt các yêu cầu cần thiết cho trang Website.  Bước 2: Phân tích yêu cầu và lên kế hoạch thiết kế website Sau khi các yêu cầu cho việc thiết kế website được thu thập đầy đủ, Đơn vị thiết kế web sẽ tiến hành phân tích yêu cầu để chuyển thành yêu cầu kỹ thuật, phân tích hệ thống, các nhân sự cần thiết và lên kế hoạch thiết kế website. Quá trình này nhằm đảm bảo cho website của bạn được thiết kế sẽ tuân thủ theo quy trình và thực hiện đúng theo kế  Bước 3: Thiết kế giao diện Giai đoạn thiết kế giao diện cho website là một quá trình sáng tạo nhằm chuyển đổi hình ảnh doanh nghiệp của bạn thành một website chất lƣợng, giúp quảng bá doanh nghiệp của ngƣời yêu cầu thực hiện Website thông qua website theo cách chuyên nghiệp nhất. Bản dự án xây dựng website đƣợc hoàn thành trong giai đoạn 1, sẽ giúp các nhân viên thiết kế giao diện hiểu rõ những yêu cầu kỹ thuật và sáng tạo mà website đòi hỏi. Trên cơ sở đó, các nhân viên thiết kế giao diện của đơn vị thiết kế web sẽ chuẩn bị một khái niệm mô hình, minh họa hình dáng và cấu trúc trang web của bạn. Giao diện website mẫu này sẽ đƣợc chuyển cho ngƣời yêu cầu thực hiện Website để lấy ý kiến. Trên cơ sở ý kiến phản hồi của bạn, nhân viên thiết kế giao diện sẽ chỉnh sửa giao diện (nếu đƣợc yêu cầu) trƣớc khi nghiệm thu giao diện lần cuối.",
        "Summary": "Purchasing offers and discounts Chiết khấu trong mua bán Cách thức xuất vận sản phẩm Tiêu chí 2 Đánh giá một Website thƣơng mại điện tử dựa trên các tiêu chí sau Các yếu tố kỹ thuật Những nội dung cần công bố Giải quyết tranh chấp va bảo mật thông tin Trọng số biểu thị mức độ quan trọng của tiêu chí Các yếu tố kỹ thuật 1. Thời gian tải các website bằng modem thông thƣờng 3. Bố trí các liên kết trong website 4.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực, mọi thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, tuy nhiên, do chỉ đơn thuần liệt kê các tiêu chí và yếu tố, nên thiếu sự liên kết rõ ràng giữa các ý. Cần thêm một vài từ nối để tăng tính trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có liên quan đến văn bản gốc, nhưng chỉ dừng lại ở việc liệt kê một số tiêu chí và yếu tố kỹ thuật. Nó bỏ qua các bước trong quy trình phát triển website chuẩn, là một phần quan trọng của văn bản gốc. Do đó, tính liên quan chưa cao vì chưa bao quát hết các ý chính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có độ trung thực cao, tuy nhiên, tính mạch lạc và liên quan cần được cải thiện. Để tăng tính mạch lạc, nên sử dụng các từ nối để liên kết các ý. Để tăng tính liên quan, cần bao gồm thêm thông tin về quy trình phát triển website chuẩn, đảm bảo tóm tắt bao quát được các ý chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00019",
        "Article": "Chức năng của máy tính là thực hiện chương trình thông qua xử lý một tập lệnh do người lập trình cung cấp. Chương trình là tập hợp các lệnh được người lập trình chọn lọc và sắp xếp theo một tuần tự chặt chẽ thông qua nguyên tắc xử lý, giải quyết một vấn đề cụ thể (hay còn gọi là thuật giải). Để thực hiện chức năng này, chương trình được lưu giữ trong bộ nhớ, việc thực hiện chương trình thực chất là các tác vụ thực thi lệnh theo tuần tự được người lập trình quy định. Quá trình thực thi 1 lệnh, như đã trình bày ở trên, gồm các giai đoạn sau: 1. Instruction Fetch - Nhận lệnh IF-Instruction Fetch 2. Giải mã lệnh ID-Instruction Decoder 3. Tạo địa chỉ toán hạng GOA-Generate Operand Address 4. Nhận toán hạng OF-Operand Fetch 5. Xử lý lệnh EX-Execute 6. Lưu kết quả WB-Write Back. Việc đảm bảo thực hiện chương trình theo tuần tự, như đã nói ở trên, là do CU đảm nhận thông qua việc điều khiển sự thay đổi nội dung của thanh đếm chương trình PC. Tuần tự các lệnh trong chương trình là do người lập trình quyết định thông qua việc viết chương trình theo thuật giải. Khi thực hiện một chương trình, thông thường máy tính thực hiện các công việc sau: Thứ nhất, Xử lý dữ liệu: Xử lý các yêu cầu của con người/thiết bị trên cơ sở các dữ liệu được nhập vào. Đây là chức năng quan trọng nhất. Dữ liệu có thể nhiều dạng khác nhau và các yêu cầu xử lý cũng rất khác biệt. Tuy nhiên máy tính chỉ có thể thực hiện được một số lượng hữu hạn các thao tác xử lý cơ bản, người lập trình dựa trên các khả năng xử lý đó mà tạo ra những khả năng xử lý các vấn đề lớn hơn và phức tạp hơn thông qua công việc lập trình. Thứ hai, Lưu trữ dữ liệu: Muốn công việc xử lý dữ liệu đạt hiệu quả cao, máy tính phải có khả năng lưu trữ tạm thời dữ liệu và lưu trữ dữ liệu dài hơn để tái sử dụng sau này. Thứ ba, Di chuyển dữ liệu: Để phục vụ việc xử lý, dữ liệu phải có thể di chuyển từ điểm này tới điểm khác bên trong máy tính. Ngoài ra, để có dữ liệu cho xử lý và gửi kết quả ra bên ngoài, máy tính phải có khả năng trao đổi dữ liệu với môi trường bên ngoài. Thứ tư, Điều khiển: Để thực hiện có hiệu quả ba chức năng nói trên, các tác vụ máy tính thực hiện phải được điều khiển một cách đồng bộ và hợp lý. Quy trình điều khiển này sẽ được thực hiện như con người cung cấp lệnh cho máy tính thi hành thông qua một đơn vị điều khiển bên trong máy tính. Kiến trúc máy tính phải được thiết kế để máy tính có khả năng thực hiện những công việc này.",
        "Summary": "Máy tính thực hiện chương trình bằng cách xử lý một tập lệnh do lập trình viên cung cấp, và quá trình thực thi lệnh bao gồm các giai đoạn như nhận lệnh, giải mã, xử lý và lưu kết quả. Máy tính thực hiện bốn chức năng chính: xử lý dữ liệu, lưu trữ dữ liệu, di chuyển dữ liệu và điều khiển các tác vụ thông qua đơn vị điều khiển. Việc thực hiện các chức năng này đảm bảo sự đồng bộ và hiệu quả trong quá trình xử lý chương trình.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic với nhau, giúp người đọc dễ dàng hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ bao gồm những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tóm tắt đúng trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan đến nội dung gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00020",
        "Article": "Đặc điểm của L/C\n - L/C là giao dịch kinh tế hai bên giữa ngân hàng phát hành và bên bán, mọi chỉ thị,\n yêu cầu của bên mua sẽ do ngân hàng phát hành đại diện. Cụ thể, ngân hàng phát hành là\n người sẽ thanh toán cho bên bán nên khi bên bán muốn ký phát hối phiếu đòi tiền thì phải gửi\n đến ngân hàng phát hành, không phải là bên mua.\n - L/C độc lập với hợp đồng ngoại thương và hàng hóa: L/C thể hiện cam kết thanh\n toán của ngân hàng phát hành cho người thụ hưởng khi người này xuất trình được bộ chứng\n từ phù hợp, nó hình thành trên cơ sở hợp đồng nhưng sau đó lại hoàn toàn độc lập với hợp\n đồng này.\n - L/C chỉ giao dịch bằng chứng từ và chỉ thanh toán căn cứ vào chứng từ: Ngân hàng\n phát hàng không dựa vào tình trạng của hàng hoá thực tế mà sẽ dựa vào bộ chứng từ thanh\n toán mà bên bán cung cấp có phù hợp với điều khoản trong L/C hay không nên nếu bộ chứng\n từ hợp lệ thì ngân hàng sẽ thanh toán cho bên bán vô điều kiện vì vậy bên mua cần lưu ý trong\n công tác kiểm tra hàng hoá.\n - L/C yêu cầu tuân thủ chặt chẽ của bộ chứng từ: Bộ chứng từ phải tuân thủ chặt chẽ\n các điều khoản của L/C.\n - L/C không thể huỷ ngang (theo quy định của UPC 600 – Phiên bản áp dụng mới nhất\n của bộ Quy tắc thực hành thống nhất về tín dụng chứng từ)\n - Các bên phải thống nhất và ghi rõ phiên bản áp dụng UPC vào L/C.\n - Trước khi mở L/C, bên bán và bên mua cần thống nhất với nhau về các điều khoản\n trong L/C như thời gian giao hàng và thanh toán…\n ü Lợi ích của L/C\n Hình thức thanh toán qua L/C được đánh giá là an toàn được nhiều công ty sử dụng,\n có lợi cho bên bán, bên mua và cả ngân hàng.\n - Đối với bên mua\n + Đảm bảo nhận được hàng hoá: Với L/C, chỉ khi nhận được hàng hoá từ người bán\n thì bên mua mới phải thanh toán cho họ.\n + Đảm bảo các quy định đã đưa ra trong L/C: Giúp cho bên mua yên tâm rằng bên bán59\n phải đảm bảo thực hiện các điều khoản về thời gian, quy chuẩn hàng hoá đã đưa ra trong L/C.\n + Có thể được ngân hàng phát hành cho vay để thanh toán tiền hàng cho bên bán.\n - Đối với bên bán\n + Nhận được thanh toán: Khi bên bán thực hiện đúng theo quy định trong thư tín dụng\n thì chắc chắn sẽ nhận được thanh toán từ ngân hàng phát hành theo điều khoản thanh toán\n trong thư tín dụng.\n + Không phải phụ thuộc vào bên mua: Được đảm bảo quyền lợi dựa trên điều khoản\n của L/C, không phải phụ thuộc vào bên mua như các phương thức thanh toán khác.\n - Đối với ngân hàng\n + Gia tăng doanh thu cho ngân hàng thông qua việc thu phí các dịch vụ liên quan đến\n thư tín dụng\n + Mở rộng quan hệ trong thương mại, tạo được uy tín và danh tiếng trong ngành xuất\n nhập khẩu.",
        "Summary": "\"L/C (Letter of Credit) là giao dịch kinh tế giữa ngân hàng phát hành và bên bán, độc lập với hợp đồng ngoại thương và hàng hóa. Ngân hàng phát hành thanh toán dựa trên chứng từ, yêu cầu tuân thủ chặt chẽ các điều khoản L/C và không thể hủy ngang. Các bên cần thống nhất điều khoản L/C trước khi mở.\n \n L/C mang lại lợi ích cho cả bên mua (đảm bảo nhận hàng, tuân thủ quy định, có thể được vay), bên bán (đảm bảo thanh toán, không phụ thuộc bên mua) và ngân hàng (tăng doanh thu, mở rộng quan hệ).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa. Tóm tắt tập trung vào đặc điểm và lợi ích của L/C, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Đảm bảo tính trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày một cách hiệu quả những thông tin quan trọng nhất từ văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00021",
        "Article": "Hệ thống ứng dụng được chia thành nhiều loại: hệ thống quản lý thông tin (phân loại theo cấp bậc, chức năng nghiệp vụ hoặc quy mô tích hợp), hệ thông tin bảng tính (như Excel), hệ quản trị cơ sở dữ liệu và hệ thống thông minh (trí tuệ nhân tạo). Cơ sở dữ liệu (database) được định nghĩa là tập hợp dữ liệu có tổ chức, liên quan đến một chủ đề cụ thể, như danh sách sinh viên hoặc sản phẩm. Hệ quản trị cơ sở dữ liệu là phần mềm cho phép tạo, lưu trữ, truy xuất và cập nhật dữ liệu hiệu quả, ví dụ MySQL, Oracle. Giáo trình nhấn mạnh rằng DBMS giúp quản lý dữ liệu lớn, đảm bảo tính nhất quán và bảo mật, vượt trội hơn so với cách lưu trữ thủ công như tệp văn bản. Các chức năng chính của DBMS bao gồm định nghĩa cấu trúc dữ liệu (schema), nhập dữ liệu, truy vấn (query) để lấy thông tin, và cập nhật khi cần. Ví dụ, một cơ sở dữ liệu sinh viên có thể chứa bảng với các cột như mã số, họ tên, điểm, và DBMS cho phép tra cứu nhanh sinh viên có điểm trên 8.0. Hệ thống thông tin bảng tính hỗ trợ xử lý số liệu qua các hàm tính toán, trong khi hệ thống thông minh áp dụng thuật toán học máy để dự đoán hoặc phân tích. Giáo trình cũng đề cập đến phân loại hệ thống quản lý thông tin: theo cấp bậc (chiến lược, chiến thuật, tác nghiệp), theo chức năng (kế toán, nhân sự), hoặc theo tích hợp (hệ thống nhỏ lẻ hoặc toàn doanh nghiệp). Sự khác biệt giữa các loại này nằm ở mục đích sử dụng và quy mô dữ liệu xử lý. Nội dung này không chỉ cung cấp kiến thức lý thuyết mà còn nhấn mạnh ứng dụng thực tiễn, như quản lý thông tin trong doanh nghiệp hoặc nghiên cứu khoa học. Bằng cách hiểu và sử dụng các hệ thống này, sinh viên có thể áp dụng tin học vào giải quyết các vấn đề thực tế, từ quản lý dữ liệu cá nhân đến vận hành tổ chức lớn.",
        "Summary": "Hệ thống ứng dụng được phân loại theo chức năng như: ứng dụng văn phòng (xử lý văn bản, bảng tính), ứng dụng đồ họa (thiết kế, chỉnh sửa ảnh), phần mềm kế toán, quản lý, và các hệ thống chuyên dụng trong y tế, giáo dục, công nghiệp. Mỗi loại phục vụ mục tiêu khác nhau, có giao diện và tính năng riêng biệt. Việc lựa chọn đúng ứng dụng theo nhu cầu giúp nâng cao hiệu suất làm việc, giảm sai sót và tiết kiệm thời gian. Sự phát triển của công nghệ kéo theo sự đa dạng và chuyên biệt hóa của các ứng dụng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chứa nhiều thông tin không có trong văn bản gốc và diễn giải sai lệch ý chính. Văn bản gốc tập trung vào phân loại hệ thống ứng dụng theo cấp bậc, chức năng nghiệp vụ, quy mô tích hợp, hệ thông tin bảng tính, hệ quản trị cơ sở dữ liệu và hệ thống thông minh. Bản tóm tắt lại liệt kê các loại ứng dụng văn phòng, đồ họa, kế toán, quản lý, y tế, giáo dục, công nghiệp, điều này không được đề cập trong văn bản gốc. Ngoài ra, các ý về cơ sở dữ liệu và hệ quản trị cơ sở dữ liệu hoàn toàn bị bỏ qua."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có tính mạch lạc tương đối, các câu liên kết với nhau một cách logic. Tuy nhiên, do nội dung không bám sát văn bản gốc nên tính mạch lạc không thực sự hiệu quả."
            },
            "Tính liên quan": {
                "Điểm": 1,
                "Đánh giá": "Bản tóm tắt rất ít liên quan đến văn bản gốc. Các ý chính của văn bản gốc về các loại hệ thống ứng dụng và cơ sở dữ liệu đã bị bỏ qua, thay vào đó là các thông tin không có trong văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất kém. Nội dung tóm tắt không trung thực, không liên quan đến văn bản gốc và bỏ qua các ý chính. Cần viết lại bản tóm tắt, tập trung vào các ý chính của văn bản gốc và tránh đưa thêm thông tin không có trong văn bản gốc."
            }
        }
    },
    {
        "Index": "00022",
        "Article": "Các tiêu chí để xác định sự thành công của một dự án gồm 3 tiêu chí chính + Dự án được thực hiện đúng theo tiến độ, hoàn thành đúng thời hạn yêu cầu của khách hàng. Để thực hiện được điều đó đội dự án cần thực hiện tốt các công việc lập kế hoạch, ước lượng, và kiểm soát việc thực thi các công việc trong hệ thống. + Dự án được thực hiện với chi phí trong phạm vi ngân sách cho phép. Một lần nữa để đạt được tiêu chí này, các công việc lập kế hoạch, ước lượng và kiểm soát cần được thực hiện tốt. + Tuân thủ theo đúng yêu cầu của khách hàng. Để đạt được tiêu chí này đội dự án phải ý thức được tầm quan trọng về yêu cầu của bài toán (hệ thống) mà cả đội đang phát triển. Tìm hiểu kỹ và nhận thức tốt những khái niệm và những thỏa thuận quan trọng. Để dự án thành công, giám đốc dự án cần nắm được những điểm mấu chốt sau: + Học cách nói “không”, thường xuyên nói “không” vào những lúc cần thiết, nhưng với thái độ lịch sự mà cứng rắn. + Nhận thức giá trị của các phiên bản trung gian trong quá trình phát triển dự án. Tận dụng các kết quả và dùng chúng (nếu có thể) trong những pha phát triển tiếp theo. + Luôn có nhiều phương pháp để phòng tránh rủi ro khi cần thiết. + Luôn nắm được yêu cầu của bài toán (hệ thống đang xây dựng) một cách chặt chẽ và tập trung + Thực hiện xem xét một dự án tại một mốc thời gian + Nên giải quyết mọi công việc theo một cách càng đơn giản càng tốt nhưng không nên quá đơn giản mà hỏng chuyện + Phân nhỏ các công việc hay yêu cầu ra để dễ giải quyết. + Đối với thái độ xử lý các công việc trong toàn bộ quá trình phát triển dự án: không nên quá nghiêm khắc với các thành viên trong đội, cũng không nên đưa ra quá nhiều giải pháp và tiến hành chúng một cách quá cặn kẽ vì người ta thường nói rằng “quá nhiều thuốc sẽ giết chết bệnh nhân”. + Điều hành và quản lý đội dự án nên ở trạng thái cân bằng là quan trọng nhất, đừng quá lộn xộn và cũng đừng quá quy củ, công thức. Theo thống kê, tỉ lệ thành công của các dự án trong thực tế được phân chia theo các ngành, theo kích cỡ. Nếu phân chia theo các ngành thì dự án cho ngành bán buôn là có tỉ lệ thành công cao nhất, vì nhìn chung những dự án này được kiểm soát về chi phí rất chặt chẽ, các dự án cho chính phủ có tỉ lệ ít thành công nhất bởi vì sự kiểm soát về chi phí rất lỏng lẻo. Nếu phân chia các dự án theo kích cỡ thì những dự án càng nhỏ có tỉ lệ thành công càng cao bởi vì những dự án này càng nhỏ thì càng dễ quản lý chi phí, thời gian thực hiện và nhân lực làm việc của đội.",
        "Summary": "\"Để một dự án thành công, cần đáp ứng ba tiêu chí: đúng tiến độ, trong ngân sách và tuân thủ yêu cầu khách hàng. Giám đốc dự án cần biết cách từ chối hợp lý, tận dụng các phiên bản trung gian, phòng tránh rủi ro, nắm vững yêu cầu bài toán, xem xét dự án định kỳ, đơn giản hóa công việc, chia nhỏ yêu cầu và duy trì sự cân bằng trong quản lý đội dự án. Theo thống kê, dự án ngành bán buôn có tỷ lệ thành công cao nhất do kiểm soát chi phí chặt chẽ, trong khi dự án nhỏ dễ thành công hơn do dễ quản lý.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ lại một cách chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các tiêu chí thành công của dự án, vai trò của giám đốc dự án và thống kê về tỷ lệ thành công theo ngành và kích cỡ dự án."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về các điểm chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00023",
        "Article": "Trong hệ thống mã hóa đối xứng, cả hai bên tham gia truyền thông phải chia sẻ một khóa bí mật chung. Một trong những thách thức quan trọng là làm thế nào để phân phối khóa một cách an toàn, vì nhiều hệ thống đã bị bẻ khóa do lỗ hổng trong quá trình phân phối khóa. Có một số phương pháp phổ biến để phân phối khóa giữa hai đối tác A và B. Một cách đơn giản là A tự chọn khóa và gửi trực tiếp cho B, tuy nhiên, điều này tiềm ẩn nguy cơ bị đánh cắp khóa trong quá trình truyền. Một cách khác là sử dụng một bên thứ ba tin cậy để tạo và phân phối khóa đến cả A và B. Ngoài ra, A và B có thể sử dụng một khóa đã có từ trước để mã hóa khóa mới. Một phương pháp khác là cả A và B cùng trao đổi thông tin một cách bí mật với một bên thứ ba C, sau đó C sẽ đóng vai trò trung gian chuyển tiếp khóa giữa hai bên.Khóa trong hệ thống mã hóa thường được phân thành hai loại chính. Khóa phiên (session key) là khóa tạm thời, chỉ được sử dụng trong một phiên làm việc giữa các người dùng và sau đó bị loại bỏ. Trong khi đó, khóa chính (master key) có vai trò quan trọng hơn, được sử dụng để mã hóa các khóa phiên. Khóa chính thường được chia sẻ giữa người dùng và một trung tâm phân phối khóa (Key Distribution Center - KDC).Với các hệ thống mạng lớn, việc phân phối khóa yêu cầu một cơ chế phân cấp với KDC. Tuy nhiên, điều này đòi hỏi phải thiết lập sự tin cậy giữa người dùng với KDC và giữa các KDC với nhau. Để tăng cường bảo mật, thời gian sống của mỗi khóa cần được giới hạn nhằm giảm nguy cơ bị tấn công. Việc phân phối khóa có thể được tự động hóa để giảm tải cho người dùng, nhưng hệ thống này cần đảm bảo tính ngẫu nhiên trong việc tạo khóa. Đồng thời, cần triển khai một hệ thống phân phối khóa phân tán và phân cấp, hỗ trợ kiểm soát mục đích sử dụng khóa nhằm đảm bảo an toàn trong quá trình truyền thông.",
        "Summary": "Trong hệ thống mã hóa đối xứng, việc phân phối khóa bí mật giữa hai bên là một thách thức quan trọng, với các phương pháp như gửi trực tiếp, sử dụng bên thứ ba tin cậy, hoặc trao đổi thông tin qua một bên trung gian. Khóa trong hệ thống mã hóa được chia thành khóa phiên (tạm thời) và khóa chính (dùng để mã hóa khóa phiên), với khóa chính thường được chia sẻ qua một trung tâm phân phối khóa (KDC). Để đảm bảo bảo mật, hệ thống phân phối khóa cần được phân cấp và có cơ chế kiểm soát chặt chẽ, đồng thời giới hạn thời gian sống của khóa và tự động hóa quá trình phân phối.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các phương pháp phân phối khóa, phân loại khóa, và các biện pháp bảo mật đều được tóm tắt chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ thách thức phân phối khóa đến các phương pháp, phân loại khóa, và cuối cùng là các biện pháp bảo mật. Các câu liên kết với nhau một cách trôi chảy, tạo thành một dòng chảy thông tin dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Các ý chính như thách thức phân phối khóa, các phương pháp phân phối, phân loại khóa, và các biện pháp bảo mật đều được đề cập một cách súc tích."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách rõ ràng và súc tích. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00024",
        "Article": "Nếu bên gửi gửi đi tin nhắn có độ dài lớn hơn 160 kí tự thì tin nhắn sẽ được cắt ra thành các tin nhắn có độ dài ngắn hơn, với mỗi tin nhắn có độ dài dưới 160 kí tự. Để làm được điều này, Android cung cấp phương thức một số API để làm điều này: - divideMessage(): đầu vào là đoạn văn bản muốn gửi đi, đầu ra là mảng ArrayList chứa các tin nhắn có chiều dài dưới 160 kí tự. - sendMultipartTextMessage(): cho phép truyền 1 mảng tin nhắn đã phân ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>(); for (int i = 0; i < messageArray.size(); i++) Nhận tin nhắn trong chính ứng dụng Để nhận tin nhắn SMS trong chính ứng dụng cần tạo ra 1 lớp Java kế thừa từ lớp BroadcastReceiver cho phép ứng dụng nhận các Intent gửi từ ứng dụng khác thông qua sendBroadcast(). Việc cài đặt như sau: Cấp quyền cho phép nhận tin nhắn trong chính ứng dụng, trong Trong đó : thuộc tính android:priority được thiết lập có giá trị càng cao thì ứng dụng càng có khả năng cao nhận được tin nhắn. Cài đặt lệnh nhận tin nhắn SMS trong chính ứng dụng: public class SMSReceiver extends BroadcastReceiver public void onReceive(Context context, Intent intent) //---get the SMS message passed in--- SmsMessage[] msgs = null; String str = \"SMS from \"; //---retrieve the SMS message received--- Object[] pdus = (Object[]) bundle.get(\"pdus\"); for (int i=0; i<msgs.length; i++){ //---get the sender address/phone number--- //---display the new SMS message--- Khi ứng dụng nhận được tin nhắn gửi tới, onReceive() được thực thi. Tin nhắn SMS được chứa trong đối tượng Intent ( tham số thứ 2 của onReceive()) thông qua đối Mỗi tin nhắn SMS được chứa trong 1 mảng Object theo định dạng PDU. Nếu tin nhắn SMS có độ dài nhỏ hơn 160 kí tự thì mảng đó chứa 1 phần tử, ngược lại nếu tin nhắn có độ dài lớn hơn 160 kí tự thì mảng sẽ chứa các phần tử, mỗi phần tử là 1 đoạn trong nội dung tin nhắn có độ dài nhỏ hơn 160 kí tự.",
        "Summary": "Để làm được điều này, Android cung cấp phương thức một số API để làm điều này - divideMessage đầu vào là đoạn văn bản muốn gửi đi, đầu ra là mảng ArrayList chứa các tin nhắn có chiều dài dưới 160 kí tự. Việc cài đặt như sau Cấp quyền cho phép nhận tin nhắn trong chính ứng dụng, trong Trong đó thuộc tính androidpriority được thiết lập có giá trị càng cao thì ứng dụng càng có khả năng cao nhận được tin nhắn. Cài đặt lệnh nhận tin nhắn SMS trong chính ứng dụng public class SMSReceiver extends BroadcastReceiver public void onReceiveContext context, Intent intent ---get the SMS message passed in--- SmsMessage msgs null String str SMS from ---retrieve the SMS message received--- Object pdus Object bundle.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số thông tin không chính xác hoặc không đầy đủ so với văn bản gốc. Ví dụ, phần code được trích dẫn bị cắt xén và không đầy đủ, gây khó hiểu. Ngoài ra, một số câu cú bị lược bỏ khiến ý nghĩa không rõ ràng."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc, các ý không được liên kết một cách rõ ràng. Việc trích dẫn các đoạn code không đầy đủ và không có sự giải thích khiến người đọc khó hiểu được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có đề cập đến một số ý chính trong văn bản gốc, nhưng lại bỏ qua nhiều chi tiết quan trọng khác. Việc tập trung quá nhiều vào các đoạn code mà không giải thích đầy đủ khiến bản tóm tắt trở nên khó hiểu và ít giá trị."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt hiện tại có chất lượng kém. Cần cải thiện đáng kể về tính trung thực, mạch lạc và liên quan. Nên tập trung vào việc tóm tắt các ý chính một cách đầy đủ và rõ ràng, thay vì chỉ trích dẫn các đoạn code một cách rời rạc. Cần đảm bảo rằng mọi thông tin trong bản tóm tắt đều chính xác và dễ hiểu."
            }
        }
    },
    {
        "Index": "00025",
        "Article": "• Xét các đoạn lệnh sau. Hãy cho biết kết quả xuất ra màn hình của các biến x, y. Giải thích. … int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) à for ( int j = 0; j < 5; j++ ) 84 if ( ( i + j ) % 2 == 0 ) x++; y += x; â … • Như bài tập trên … int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ ) à if ( ( i + j ) % 2 == 0 ) x++; y += x; â … • Như bài tập trên … 85 int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) à for ( int j = 0; j < 5; j++ ) if ( (x + y ) % 2 == 0 ) x++; y += x; â … • Như bài tập trên … int x = 0, y = 1; for ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ ) à if ( ( i + j ) % 2 == 0 ) x++; else y += x; 86 â … • Như bài tập trên … int i = 0, x = 0; doà if ( x %5 == 0 ) à x++; cout << setw( 4 ) << x; â i++; â while ( i < 20 ); … • Như bài tập trên … int i = 0, x = 0; while ( i < 20 ) 87 à if ( x % 5 == 0 ) à x += i; cout << setw( 4 ) << x; â i++; â … • Như bài tập trên … int i, x = 0; for ( i = 1; i < 10; i*=2 ) à x++; cout << setw( 4 ) << x; â … 88 • Như bài tập trên … int i, x = 0; for (i = 1; i < 10; i++) à if ( i % 2 == 1 ) x += i; else x–– ; cout << setw( 4 ) << x; â … • Như bài tập trên … int i, j, k, x = 0; for ( i = 1; i < 5; i++ ) for ( j = 0; j < i; j++ ) à 89 k = (i + j – 1); if ( k % 2 == 0 ) x += k; else if ( k % 3 ==0 ) x += k – 2; cout << setw( 4 ) << x; â … • Như bài tập trên … int i, j, k, x = 0; for ( i = 1; i < 5; i++ ) for ( j = 0; j < i; j++ ) à switch ( i + j – 1 ) à case –1: 90 case 0: x += 1; break; case 1: case 2: case 3: x += 2; break; default: x += 3; â cout << setw( 4 ) << x; â …",
        "Summary": "Văn bản trình bày một loạt các đoạn mã C++ với các vòng lặp `for` và `while`, cùng câu lệnh điều kiện `if` và `switch`. Mỗi đoạn mã thực hiện các phép tính khác nhau trên các biến `x` và `y`, thay đổi giá trị của chúng dựa trên điều kiện modulo. Kết quả cuối cùng của `x` và `y` phụ thuộc vào logic của mỗi đoạn mã, bao gồm cả việc tăng hoặc giảm giá trị biến dựa trên điều kiện chia hết cho 2, 3 hoặc 5. Các đoạn mã minh họa các kỹ thuật lập trình cơ bản như vòng lặp lồng nhau, điều kiện và toán tử modulo trong C++.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Bản tóm tắt đã nắm bắt được bản chất của các đoạn mã C++ được trình bày trong văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Cách diễn đạt súc tích giúp người đọc nhanh chóng nắm bắt được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm việc sử dụng các vòng lặp, câu lệnh điều kiện, và các phép toán trên biến. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt trở nên ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã thành công trong việc tóm gọn nội dung chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00026",
        "Article": "Tường lửa đóng vai trò như một rào chắn giữa mạng nội bộ tin cậy và các mạng bên ngoài không tin cậy như Internet, kiểm soát luồng lưu lượng mạng ra vào dựa trên một tập hợp các quy tắc xác định trước. Có hai loại tường lửa chính: tường lửa phần cứng và tường lửa phần mềm. Tường lửa phần cứng là các thiết bị chuyên dụng, thường được triển khai tại ranh giới giữa mạng nội bộ và Internet, trong khi tường lửa phần mềm là các chương trình được cài đặt trên hệ điều hành máy chủ hoặc máy trạm. Ngoài ra, còn có tường lửa thế hệ mới (Next Generation Firewall – NGFW) tích hợp thêm các chức năng như kiểm tra gói tin ở lớp ứng dụng, phát hiện xâm nhập, và lọc nội dung nâng cao. Các kỹ thuật lọc của tường lửa có thể bao gồm lọc gói tin (packet filtering), kiểm tra trạng thái kết nối (stateful inspection), và lọc theo proxy. Tường lửa có thể được cấu hình để chặn hoặc cho phép lưu lượng dựa trên các tiêu chí như địa chỉ IP, cổng, giao thức hoặc nội dung. Việc cấu hình tường lửa cần được thực hiện cẩn thận để đảm bảo không làm gián đoạn các dịch vụ hợp lệ, đồng thời ngăn chặn các lưu lượng độc hại. Tường lửa không thể bảo vệ khỏi tất cả các mối đe dọa, nhưng là một phần không thể thiếu trong kiến trúc phòng thủ nhiều lớp (defense in depth). Ngoài ra, tường lửa cần được giám sát và cập nhật định kỳ để đảm bảo hiệu quả hoạt động và thích ứng với các mối đe dọa mới. Trong các hệ thống lớn, thường triển khai tường lửa theo tầng – ví dụ: tường lửa tại biên mạng, tường lửa trong nội bộ và cả trên các thiết bị đầu cuối. Sự kết hợp giữa tường lửa truyền thống và các công nghệ bảo mật khác giúp tăng cường khả năng bảo vệ hệ thống trước các tấn công ngày càng tinh vi.",
        "Summary": "Tường lửa là công cụ bảo vệ hệ thống bằng cách kiểm soát lưu lượng mạng ra vào dựa trên các quy tắc bảo mật được thiết lập trước. Có thể chia tường lửa thành phần cứng, phần mềm hoặc dịch vụ đám mây, mỗi loại phù hợp với quy mô và nhu cầu khác nhau. Tường lửa giúp ngăn chặn truy cập trái phép, lọc nội dung nguy hiểm và hạn chế các kết nối không mong muốn. Việc cấu hình đúng, cập nhật định kỳ và tích hợp với các hệ thống bảo mật khác là yếu tố then chốt để phát huy hiệu quả bảo vệ toàn diện.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt nhìn chung trung thực với văn bản gốc. Tuy nhiên, việc đề cập đến 'dịch vụ đám mây' như một loại tường lửa có thể gây hiểu nhầm, vì văn bản gốc chỉ đề cập đến tường lửa phần cứng, phần mềm và NGFW. Mặc dù tường lửa có thể được triển khai trên đám mây, nhưng cách diễn đạt này có thể không hoàn toàn chính xác so với nội dung gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các ý được trình bày một cách logic, từ định nghĩa tường lửa đến các loại, chức năng và yếu tố để đảm bảo hiệu quả. Tuy nhiên, có thể cải thiện bằng cách liên kết rõ ràng hơn giữa các câu."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa, các loại, chức năng và tầm quan trọng của việc cấu hình và cập nhật tường lửa. Tuy nhiên, có thể lược bỏ chi tiết 'dịch vụ đám mây' để tập trung hơn vào các loại tường lửa được đề cập trong văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, đã nắm bắt được các ý chính của văn bản gốc. Tuy nhiên, cần chú ý hơn đến tính chính xác tuyệt đối so với văn bản gốc và đảm bảo mọi thông tin đều có thể truy xuất trực tiếp từ đó. Việc diễn giải nên cẩn trọng để tránh thêm thông tin mới hoặc làm sai lệch ý nghĩa ban đầu. Cần xem xét lại chi tiết về 'dịch vụ đám mây' để đảm bảo tính trung thực và liên quan."
            }
        }
    },
    {
        "Index": "00027",
        "Article": "Trong phân tích tín hiệu miền thời gian, có nhiều dạng tín hiệu thông dụng được phân thành ba nhóm chính: tín hiệu năng lượng, tín hiệu công suất và tín hiệu phân bố. Tín hiệu năng lượng bao gồm các dạng như xung vuông, xung tam giác, xung hàm mũ giảm, tín hiệu sin suy giảm theo hàm mũ và tín hiệu Sa, với đặc điểm chung là năng lượng hữu hạn. Tín hiệu công suất bao gồm tín hiệu bước nhảy, tín hiệu hàm mũ tăng, hàm dấu, tín hiệu sin - cos, dãy xung vuông lưỡng cực và đơn cực, có công suất trung bình hữu hạn và thường tồn tại trong khoảng thời gian vô hạn. Tín hiệu phân bố bao gồm phân bố Delta Dirac và phân bố lược, đóng vai trò quan trọng trong lý thuyết xử lý tín hiệu. Các thông số đặc trưng của tín hiệu gồm tích phân tín hiệu, trị trung bình, năng lượng và công suất trung bình. Trị trung bình mô tả giá trị trung bình của tín hiệu theo thời gian, trong khi năng lượng và công suất giúp phân biệt tín hiệu năng lượng và tín hiệu công suất. Một tín hiệu có năng lượng hữu hạn nhưng công suất bằng không thường chỉ tồn tại trong một khoảng thời gian nhất định, còn tín hiệu công suất có giá trị trung bình hữu hạn trong suốt khoảng thời gian vô hạn. Bên cạnh đó, phân tích thành phần tín hiệu giúp tách tín hiệu thành các phần thực - ảo, một chiều - xoay chiều, và chẵn - lẻ. Thành phần thực và ảo của một tín hiệu phức giúp dễ dàng biểu diễn và phân tích trong các hệ thống xử lý tín hiệu số. Thành phần một chiều và xoay chiều giúp xác định sự biến thiên của tín hiệu theo thời gian. Thành phần chẵn - lẻ hỗ trợ trong việc đơn giản hóa các phép biến đổi tín hiệu bằng cách xác định tính đối xứng của nó. Cuối cùng, phân tích tương quan đóng vai trò quan trọng trong việc xác định mối quan hệ giữa hai tín hiệu, giúp đánh giá mức độ tương đồng và sự phụ thuộc giữa chúng theo thời gian. Các khái niệm và phương pháp trong chương này là nền tảng quan trọng để hiểu rõ hơn về cách tín hiệu thay đổi và được xử lý trong thực tế.",
        "Summary": "\"Trong phân tích tín hiệu miền thời gian, các tín hiệu được phân loại thành tín hiệu năng lượng (năng lượng hữu hạn), tín hiệu công suất (công suất trung bình hữu hạn) và tín hiệu phân bố (Delta Dirac và lược). Các thông số đặc trưng bao gồm tích phân, trị trung bình, năng lượng và công suất. Phân tích thành phần tín hiệu giúp tách tín hiệu thành phần thực-ảo, một chiều-xoay chiều, chẵn-lẻ để đơn giản hóa biểu diễn và xử lý. Phân tích tương quan xác định mối quan hệ và độ tương đồng giữa các tín hiệu.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào việc phân loại tín hiệu, các thông số đặc trưng, phân tích thành phần và phân tích tương quan, đúng với trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về nội dung chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00028",
        "Article": "Truyền dữ liệu tin cây trên kênh truyền có lỗi bit Một dạng kênh truyền thực tế hơn là gói tin trên kênh truyền có thể bị lỗi, thường bit bị lỗi xảy ra trên đường truyền vật lý của mạng. Giả sử tất cả các gói dữ liệu truyền đi đều đến được đích và theo đúng thứ tự gửi mặc dù các bit trong gói dữ liệu có thể bị lỗi. Xuất phát từ thực tế cuộc hội thoại giữa hai người, nếu người nghe đã rõ thì xác nhận, ngược lại sẽ yêu cầu người nói nhắc lại, cơ chế này đã được áp dụng cho rdt 2.0. Trong mạng máy tính, giao thức truyền tin cậy dựa trên cơ chế truyền lại như vậy được gọi là các giao thức yêu cầu nhắc lại tự động (ARQ - Automatic Repeat Request). Các giao thức ARQ cần phải có ba khả năng sau để xử lý trường hợp có lỗi bit: - Phát hiện lỗi: Cơ chế cho phép bên nhận phát hiện được khi nào trong gói tin có bit bị lỗi, kỹ thuật CRC thường được sử dụng để thực hiện công việc này. Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 86 - Phản hồi từ phía nhận: Khi phía gửi và phía nhận nằm trên các thiết bị đầu cuối khác nhau - có thể cách nhau hàng nghìn km, cách duy nhất để phía gửi biết được kết quả gửi là phía nhận gửi thông tin phản hồi thông báo tình trạng nhận cho phía gửi. Báo nhận đúng ACK và báo nhận sai NAK trong ví dụ trên chính là các thông tin phản hồi. Giao thức rdt 2.0 yêu cầu phía nhận gửi phản hồi các bản tin ACK hay NAK cho phía gửi. Đoạn dữ liệu phản hồi chỉ cần sử dụng một bit, ví dụ giá trị 0 ứng với NAK và giá trị 1 ứng với ACK. - Truyền lại: Đoạn dữ liệu bị lỗi sẽ được bên gửi phát lại.",
        "Summary": "\"Trên kênh truyền có lỗi bit, các gói tin có thể bị lỗi do lỗi bit trên đường truyền vật lý. Các giao thức yêu cầu nhắc lại tự động (ARQ) dựa trên cơ chế truyền lại để đảm bảo truyền tin cậy. Để xử lý lỗi bit, giao thức ARQ cần có ba khả năng: phát hiện lỗi (thường dùng kỹ thuật CRC), phản hồi từ phía nhận (ACK hoặc NAK) và truyền lại dữ liệu bị lỗi.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của vấn đề truyền dữ liệu tin cậy trên kênh truyền có lỗi bit và các yếu tố cần thiết để giải quyết vấn đề này."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00029",
        "Article": "11. Bộ điều khiển gửi một thông điệp tới nút đi lên ở tầng 3 để nó trở về trạng thái bình 12. Bộ điều khiển thang máy gửi một loạt thông điệp tới thang máy để nó di chuyển lên tới 13. Bộ điều khiển thang máy gửi một thông điệp tới nút 7 ở thang máy để nó trở về trạng thái bình thường (không sáng). 14. Bộ điều khiển thang máy gửi một thông điệp tới cửa thang máy yêu cầu mở cửa để cho phép người dùng A bước ra khỏi thang máy. 15. Bộ điều khiển thang máy bắt đầu đặt thời gian. Người dùng A bước ra khỏi thang máy. 16. Bộ điều khiển thang máy gửi một thông điệp tới cửa thang máy để đóng cửa sau một 17. Bộ điều khiển thang máy gửi một loạt thông điệp tới thang máy để nó di chuyển lên Hình 12.10 Vòng lặp thứ hai của kịch bản chuẩn Các biểu đồ đóng vai trò quan trọng trong phân tích hướng đối tượng. Các biểu đồ thường xuyên thay đổi do đó cần có các công cụ vẽbiểu đồ. Các công cụ hỗ trợ cho UML: Các công cụ mang tính thương mại như: IBM Rational Rose và Together. Các công cụ Open-source: AgroUML Mục đích của bước này là viết các kịch bản (scenario) cho các use case đã xác định được trong pha lấy yêu cầu. Để tập trung vào phần nghiệp vụ chuyên môn, các kịch bản trong mục này sẽ bỏ qua phần đăng nhập của các nhân viên cho ngắn gọn. a. Kịch bản sửa thông tin phòng Nhân viên quản lí (QL) vào hệ thống để sửa thông tin phòng 305 của khách sạn. Hệ thống hiện giao diện đăng nhập, có ô nhập tên đăng nhập, mật khẩu, và nút đăng nhập. Nhân viên nhập thông tin tài khoản của mình và click đăng nhập Hệ thống hiện giao diện chính của nhân viên quản lí, có 3 chức năng lựa chọn: quản lí thông tin khách sạn, quản lí thông tin phòng, xem thống kê.",
        "Summary": "Bộ điều khiển thang máy gửi một thông điệp tới cửa thang máy yêu cầu mở cửa để cho phép người dùng A bước ra khỏi thang máy. Các công cụ Open-source AgroUML Mục đích của bước này là viết các kịch bản scenario cho các use case đã xác định được trong pha lấy yêu cầu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt trích dẫn chính xác các câu từ có trong văn bản gốc mà không hề thêm thông tin hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc. Các câu trích dẫn được lấy ra từ văn bản gốc một cách ngẫu nhiên và không có sự liên kết logic nào với nhau. Điều này khiến cho người đọc khó hiểu được ý nghĩa tổng thể mà bản tóm tắt muốn truyền đạt."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chứa các chi tiết không quan trọng và bỏ qua nhiều ý chính của văn bản gốc. Ví dụ, việc trích dẫn tên một công cụ Open-source (AgroUML) không thực sự cần thiết trong một bản tóm tắt tổng quan. Hơn nữa, bản tóm tắt không làm rõ được ngữ cảnh của các thông điệp mà bộ điều khiển thang máy gửi đi, khiến cho thông tin trở nên rời rạc và khó hiểu."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có tính trung thực cao vì trích dẫn chính xác từ văn bản gốc, nhưng lại rất yếu về tính mạch lạc và tính liên quan. Các ý được chọn lọc một cách ngẫu nhiên, không có sự liên kết và không tập trung vào các ý chính. Để cải thiện, cần chọn lọc các ý quan trọng nhất, sắp xếp chúng một cách logic và đảm bảo sự liên kết giữa các câu."
            }
        }
    },
    {
        "Index": "00030",
        "Article": "Phân tích toán học Mục đích cuối cùng của thuật toán phân cụm K-means là từ dữ liệu đầu vào và số lượng cụm cần tìm, hãy xác định tâm mỗi cụm và phân các điểm dữ liệu vào cụm tương ứng. Giả sử thêm rằng mỗi điểm dữ liệu chỉ thuộc đúng một cụm. Giả sử N điểm dữ liệu trong tập huấn luyện được ghép lại thành ma trận X = [x1, x2, . . . , xN ] ∈ R d×N và K < N là số cụm được xác định trước. Ta cần tìm các tâm cụm m1, m2, . . . , mK ∈ R d×1 và nhãn của mỗi điểm dữ liệu. Ở đây, mỗi cụm được đại diển bởi một nhãn, thường là một số tự nhiên từ 1 đến K. Nhắc lại rằng các điểm dữ liệu trong bài toán phân cụm K-means ban đầu không có nhãn cụ thể. Với mỗi điểm dữ liệu xi , ta cần tìm nhãn yi = k của nó, ở đây k ∈ {1, 2, . . . , K}. Nhãn của một điểm cũng thường được biểu diễn dưới dạng một vector hàng K 25 Vonoroi diagram – Wikipedia (https://goo.gl/xReCW8). Machine Learning cơ bản 129 https://thuviensach.vn Chương 10. Phân cụm K-means phần tử yi ∈ R 1×K, trong đó tất cả các phần tử của yi bằng 0 trừ phần tử ở vị trí thứ k bằng 1. Cách biểu diễn này còn được gọi là mã hoá one-hot. Cụ thể, yij = 0, ∀j 6= k, yik = 1. Khi chồng các vector yi lên nhau, ta được một ma trận nhãn Y ∈ R N×K. Nhắc lại rằng yij là phần tử hàng thứ i, cột thứ j của ma trận Y, và cũng là phần tử thứ j của vector yi . Ví dụ, nếu một điểm dữ liệu có vector nhãn là [1, 0, 0, . . . , 0] thì nó thuộc vào cụm thứ nhất, là [0, 1, 0, . . . , 0] thì nó thuộc vào cụm thứ hai,... Điều kiện của yi có thể viết dưới dạng toán học: yij ∈ {0, 1}, ∀i, j; X K j=1 yij = 1, ∀i",
        "Summary": "\"Thuật toán K-means nhằm xác định tâm của K cụm và phân loại N điểm dữ liệu vào các cụm tương ứng. Dữ liệu đầu vào là ma trận X chứa các điểm dữ liệu và số lượng cụm K. Kết quả là các tâm cụm m1, m2, ..., mK và nhãn yi cho mỗi điểm dữ liệu xi, với yi thuộc tập {1, 2, ..., K}. Nhãn yi có thể được biểu diễn dưới dạng vector one-hot, trong đó chỉ có một phần tử bằng 1 tương ứng với cụm mà điểm dữ liệu thuộc về, còn lại bằng 0. Ma trận Y chứa tất cả các vector nhãn.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ mục tiêu của thuật toán K-means đến cách biểu diễn nhãn của các điểm dữ liệu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng hiểu được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm mục tiêu của thuật toán K-means, dữ liệu đầu vào, kết quả đầu ra và cách biểu diễn nhãn. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách rõ ràng và ngắn gọn. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00031",
        "Article": "Ứng dụng công nghệ thông tin (CNTT) không chỉ tác động mạnh mẽ đến doanh nghiệp mà còn mang lại những thay đổi sâu sắc cho xã hội. CNTT tạo ra nhiều loại hình nghề nghiệp mới, góp phần giảm tỷ lệ thất nghiệp và nâng cao cơ hội cho người tàn tật. Thời gian và không gian làm việc được mở rộng đến mức \"mọi lúc\" và \"mọi nơi\", nhờ sự hỗ trợ của các thiết bị kết nối mạng. Cuộc cách mạng robot cũng mang lại lợi ích tiềm tàng trong các môi trường độc hại, nguy hiểm. Đối với doanh nghiệp, CNTT giúp đạt được mục tiêu kinh doanh thông qua các hệ thống cung cấp thông tin hữu ích hỗ trợ quá trình ra quyết định. Sơ đồ chuỗi giá trị thông tin (Information Value Chain) cho thấy khả năng hỗ trợ của CNTT đối với tất cả các hoạt động quản lý và quản trị kinh doanh. Một hệ thống thông tin điển hình thực hiện ba hoạt động chính: thu thập, xử lý và phân phối thông tin. Thông tin được sử dụng trong lập kế hoạch, điều phối, kiểm soát, mô hình hóa và ra quyết định, cũng như quản trị \"xuyên suốt\" chuỗi cung ứng doanh nghiệp. Quan điểm truyền thống về quản lý bao gồm lập kế hoạch, tổ chức, điều khiển và kiểm soát. Mintzberg chia vai trò của người quản lý thành ba dạng: kết nối cá nhân, thông tin và quyết định. CNTT hỗ trợ các vai trò này thông qua các công cụ giao tiếp, thu thập và phân tích thông tin. Trong môi trường ứng dụng CNTT, quản lý và kinh doanh có những thay đổi đáng kể. Các lớp quản lý trung gian giảm bớt, quyết định được đưa ra nhanh chóng hơn và vai trò của cán bộ quản lý thay đổi. Internet và các mạng hỗ trợ khác giúp nhà quản lý tiếp cận thông tin nhanh chóng. CNTT cũng ảnh hưởng đến cách thức làm việc, tạo điều kiện cho làm việc từ xa và làm việc nhóm ảo. Tuy nhiên, việc triển khai ứng dụng CNTT cũng đặt ra nhiều thách thức, bao gồm lựa chọn chiến lược phù hợp, đảm bảo an toàn thông tin và đào tạo người dùng. Sự thành công của ứng dụng CNTT phụ thuộc vào sự hiểu biết về các yếu tố cấu thành hệ thống thông tin và mối liên hệ giữa chúng.",
        "Summary": "Ứng dụng CNTT tạo ra tác động lớn đến doanh nghiệp và xã hội, mở ra nhiều cơ hội nghề nghiệp và thay đổi phương thức làm việc. Đối với doanh nghiệp, CNTT hỗ trợ ra quyết định và quản trị chuỗi cung ứng thông qua các hệ thống thu thập, xử lý và phân phối thông tin. CNTT cũng thay đổi vai trò quản lý, giảm bớt lớp trung gian và tăng tốc độ ra quyết định. Tuy nhiên, triển khai CNTT đặt ra thách thức về chiến lược, an toàn thông tin và đào tạo người dùng. Thành công phụ thuộc vào sự hiểu biết về hệ thống thông tin.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ lại một cách chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được sắp xếp theo trình tự hợp lý, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ những ý chính và quan trọng nhất từ văn bản gốc được giữ lại. Các chi tiết không cần thiết đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Bản tóm tắt đã chọn lọc và trình bày một cách hiệu quả những thông tin quan trọng nhất từ văn bản gốc, đồng thời đảm bảo tính dễ hiểu và logic."
            }
        }
    },
    {
        "Index": "00032",
        "Article": "Tìm kiếm tài liệu trên Google có thể trở thành một kỹ năng quan trọng giúp bạn tiết kiệm thời gian và có được thông tin chính xác hơn. Để cải thiện khả năng tìm kiếm của mình, bạn có thể áp dụng một số kỹ thuật nâng cao. Một trong những cách hiệu quả là tìm kiếm cụm từ chính xác. Điều này đặc biệt hữu ích khi bạn cần tìm thông tin cụ thể và không muốn bị làm phiền bởi các kết quả không liên quan. Để thực hiện việc này, bạn chỉ cần đưa cụm từ cần tìm vào dấu nháy kép (\"\"). Ví dụ, thay vì chỉ gõ \"hướng dẫn làm seo web\", bạn hãy gõ \"hướng dẫn làm seo web\" vào hộp tìm kiếm. Cách này sẽ giúp Google trả về các kết quả có chứa cụm từ chính xác mà bạn tìm kiếm, tránh các kết quả liên quan nhưng không đúng yêu cầu. Đây là một mẹo cực kỳ hữu ích khi bạn cần tìm kiếm tài liệu chuyên sâu, báo cáo hay các bài hướng dẫn có nội dung cụ thể. Ngoài ra, bạn cũng có thể kết hợp sử dụng các bộ lọc tìm kiếm khác của Google để nâng cao kết quả tìm kiếm. Ví dụ, bạn có thể sử dụng toán tử \"site:\" để tìm tài liệu trong một trang web cụ thể, hoặc \"filetype:\" để tìm kiếm tài liệu ở định dạng nhất định như PDF, Word, PowerPoint. Những kỹ thuật tìm kiếm này không chỉ giúp bạn tiết kiệm thời gian mà còn giúp bạn tìm được tài liệu chính xác hơn, phục vụ cho công việc nghiên cứu, học tập, hay giải quyết các vấn đề trong công việc. Hãy làm quen với các phương pháp tìm kiếm nâng cao này để nâng cao hiệu quả khi sử dụng Google, từ đó tiếp cận nguồn tài liệu phong phú và đa dạng hơn",
        "Summary": "Kỹ năng tìm kiếm tài liệu trên Google có thể giúp tiết kiệm thời gian và nâng cao độ chính xác. Một trong những kỹ thuật hiệu quả là tìm kiếm cụm từ chính xác bằng cách sử dụng dấu nháy kép (\"\"). Ngoài ra, bạn cũng có thể sử dụng các bộ lọc như toán tử \"site:\" và \"filetype:\" để tìm kiếm tài liệu trong các trang web cụ thể hoặc định dạng tệp mong muốn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào kỹ năng tìm kiếm trên Google, cách sử dụng dấu nháy kép và các bộ lọc tìm kiếm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng tốt. Tóm tắt trung thực, mạch lạc và liên quan đến nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00033",
        "Article": "2.4 Thực đơn và thanh công cụ\n Thực đơn (menu) của Microsoft Visual Studio.NET IDE ... 'biến hóa' tùy theo công việc đang làm nhưng tổng quát, thực đơn (menu) chính hiển thị bao gồm:\n  \n File:\n  \n Tiêu chuẩn chung cho mọi ứng dụng (application) trong nền Windows. File dùng để mở (open) hay đóng (close) các tập tin (files) hay dự án (project).\n Edit:\n Edit cung cấp các chọn lựa khi soạn nguồn mã và dùng các công cụ lập trình, tỷ như: Undo, Redo, Cut, Copy, Paste và Delete\n View:\n View cung cấp sư chọn lựa hiển thị các Windows tạo môi trường của IDE, tỷ như: Solution Explorer, Properties, Output, Tool Box, Server Explorer. Nếu ta để ý sẽ thấy các Windows này thường nằm 2 bên hoặc bên dưới window thiết kế Form hay soạn nguồn mã.Các windows này cũng có thể hiển lộ hay thu kín lại nhường chổ cho window thiết kế được rộng rãi.\n Project:\n Dùng để quản lý dự án (project) bằng cách thêm vào hay xóa bỏ các tập tin liên hệ. Build:\n Một lựa chọn quan trọng trong thực đơn là Build cho phép ta xây dựng và chạy ứng dụng (application) 1 cách độc lập bên ngoài IDE.\n Debug:\n Debug không những giúp phương tiện rà tìm các lỗi lập trình trong môi trường IDE mà còn giúp kiểm tra từng bước một các nguồn mã trong dự án (project).\n Data:\n Giúp ta nối và sử dụng dữ kiện hay thông tin trong Cơ Sở Dữ Liệu (Database). Tools:\n Chứa các công cụ bố trí Microsoft Visual Studio.NET IDE. Windows:\n Tiêu chuẩn chung dùng quản lý mọi windows trong IDE. Help:\n Cung cấp nối yêu cầu giúp đỡ với Microsoft Visual Studio.NET documentation hay từ mạng Internet.\n \n Cách dùng thanh công cụ sẽ được hướng dẫn tùy từng dự án (project). Tuy nhiên, 1 cách tổng quát, thanh công cụ mặc định (default) bao gồm như sau (theo thứ tự từ trái qua phải):\n • New Project\n • Add Item\n • Open File\n • Save (lưu trữ form hay module đang dùng)\n • Save All (lưu trữ mọi forms, modules, ... đang dùng hay đang mở)\n • Cut\n • Copy\n • Paste (sẽ hiển lộ sau khi ta nhấp nút Cut hay Copy)\n • Undo\n • Redo\n • Navigate Backward (lướt lui)\n  \n • Navigate Forwards (lướt tới)\n • Nút Start để chạy thử ứng dụng trong IDE\n • Build Configuration (bố trí xây dựng ứng dụng) trong IDE. Ở đây, cho ta biết bố trí hiện dùng là Debug\n • Truy tìm tập tin (Find in files)\n và cuối cùng, nút Toolbar Options để hiển thị thêm các công cụ phụ thuộc khác.\n Nhấp đơn hộp công cụ nằm phía bên tay trái window thiết kế như hình sau. Hộp công cụ bao gồm:\n • Hộp Data\n • Hộp Components\n • Hộp Windows Forms\n • Hộp Clipboard Ring\n • Hộp Gerneral\n Hình 2.17: Màn hình soạn thảo\n Bài kế tiếp, ta sẽ bắt đầu soạn dự án (project) đâu tiên với Microsoft Visual Studio.NET",
        "Summary": "Trong Microsoft Visual Studio .NET IDE, thực đơn chính (menu) cung cấp các chức năng File (mở/đóng tập tin/dự án), Edit (soạn mã nguồn), View (hiển thị các cửa sổ như Solution Explorer, Properties), Project (quản lý dự án), Build (xây dựng ứng dụng), Debug (rà soát lỗi), Data (kết nối CSDL), Tools (bố trí IDE), Windows (quản lý cửa sổ) và Help (trợ giúp). Thanh công cụ mặc định bao gồm các nút New Project, Add Item, Open File, Save, Save All, Cut, Copy, Paste, Undo, Redo, Navigate Backward/Forward, Start, Build Configuration, Find in Files và Toolbar Options. Hộp công cụ bên trái window thiết kế chứa các hộp Data, Components, Windows Forms, Clipboard Ring và General.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, giúp người đọc dễ dàng nắm bắt thông tin. Các chức năng của menu, các nút trên thanh công cụ và các hộp công cụ được liệt kê một cách có hệ thống."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ những ý chính và quan trọng từ văn bản gốc được giữ lại, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các chức năng chính của thực đơn, thanh công cụ và hộp công cụ trong Microsoft Visual Studio .NET IDE."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00034",
        "Article": "Thông qua truy cập thông tin sinh hoạt hàng ngày của một ngƣời, phân tích giấc ngủ và xem xét thói quen các buổi sáng trƣớc đó, công nghệ TTNT có thể cho biết thời điểm nào thích hợp để robot chuẩn bị bữa sáng. TTNT và robot đƣợc kết hợp mạnh mẽ nhằm tự động hóa các tác vụ bên trong và bên ngoài cơ sở sản xuất. Những năm gần đây, TTNT ngày càng hiện diện phổ biến thông qua cac robot, có tính linh hoạt và khả năng học các trải nghiệm, vốn không có trong các ứng dụng trƣớc đây. TTNT trong robot thể hiện dƣới dạng các khả năng trí tuệ nhƣ: suy nghĩ, lập luận, lập kế hoạch, học tập và thích nghi. Robot thông minh thông qua chƣơng trình phần mềm mô phỏng hoạt động tƣ duy hoặc suy luận. Ngoài ra, robot trí tuệ nhân tạo còn có hai đặc điểm quan trọng. Đó là robot có khả năng học để thích nghi với môi trƣờng xung quanh, có thể thay đổi hành vi dần theo thời gian. Đặc điểm thứ hai là hành vi phát sinh, thực hiện các hành động không đƣợc lập trình sẵn một cách tƣờng minh theo chủ ý của ngƣời thiết kế. e) Phương tiện tự hành Những năm gần đây, nhờ sự tiến bộ của trí tuệ nhân tạo đã có nhiều cải thiện đáng kể khả năng thông minh của các phƣơng tiện tự hành trong nhiều mặt hoạt động sản xuất và đời sống [40]. Nhiều chính phủ và nhiều công ty công nghệ lớn nhƣ Google, Baidu, Apple, Tesla, v.v cũng đang đầu tƣ rất mạnh vào lĩnh vực này. Khả năng tự hành của phƣơng tiện đƣợc chia theo 5 cấp độ, đƣợc diễn giải nhƣ sau: Cấp độ một và cấp độ hai - Hỗ trợ người lái: Ở cấp độ này, phƣơng tiện chỉ cung cấp các phần mềm ứng dụng nhƣ cảnh báo điểm mù, cảnh báo không khởi hành và cải tiến một số thiết bị trong hệ thống xe, giúp nâng cao mức độ an toàn, giảm thiểu lỗi liên quan đến sức khỏe và tính mạng con ngƣời. Một số loại xe đã tích hợp khả năng xử lý tự động giảm tốc, can thiệp điểu chỉnh chuyển động ngang trong các tình huống nguy hiểm. Nhƣng vai trò chính vẫn phụ thuộc hoàn toàn vào ngƣời lái.",
        "Summary": "Robot thông minh thông qua chƣơng trình phần mềm mô phỏng hoạt động tƣ duy hoặc suy luận. Khả năng tự hành của phƣơng tiện đƣợc chia theo 5 cấp độ, đƣợc diễn giải nhƣ sau Cấp độ một và cấp độ hai - Hỗ trợ người lái Ở cấp độ này, phƣơng tiện chỉ cung cấp các phần mềm ứng dụng nhƣ cảnh báo điểm mù, cảnh báo không khởi hành và cải tiến một số thiết bị trong hệ thống xe, giúp nâng cao mức độ an toàn, giảm thiểu lỗi liên quan đến sức khỏe và tính mạng con ngƣời.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được trích dẫn từ văn bản gốc và ghép lại với nhau. Tuy nhiên, vì là trích dẫn nên sự liên kết giữa các ý có thể chưa được mượt mà như khi viết lại hoàn toàn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào robot thông minh và phương tiện tự hành. Tuy nhiên, việc chỉ trích dẫn một vài câu có thể khiến người đọc khó nắm bắt được toàn bộ ý chính nếu không đọc văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá. Điểm mạnh là tính trung thực cao, không thêm thông tin sai lệch. Tuy nhiên, để cải thiện, nên viết lại các ý chính bằng ngôn ngữ của người tóm tắt thay vì chỉ trích dẫn, để đảm bảo tính mạch lạc và liên kết giữa các ý, đồng thời làm nổi bật các ý quan trọng hơn."
            }
        }
    },
    {
        "Index": "00035",
        "Article": "Định danh của luồng (ThreadId): ThreadId là định danh của luồng, được dùng để phân biệt với các luồng khác cùng tiến trình hoặc cùng tập luồng. Đây là thông số mà máy ảo Java tự tạo ra khi ta tạo luồng nên ta không thể sửa đổi cũng 44 như áp đặt thông số này khi tạo luồng. Nhưng ta có thể lấy được ThreadId thông qua phương thức getId() của lớp Thread. Tên của luồng (ThreadName): ThreadName là tên của luồng, đây là thuộc tính mà ta có thể đặt hoặc không đặt cho luồng. Nếu ta không đặt cho luồng thì máy ảo Java sẽ tự đặt với quy tắc sau: “Thread-” + Thứ tự luồng được tạo ra, bắt đầu từ 0. Độ ưu tiên của luồng (Priority): Như đã nói ở phần trước, mỗi luồng có 1 độ ưu tiên nhất định. Đây sẽ là thông số quyết định mức ưu tiên khi cấp phát CPU cho các luồng. Trong Java, đế đặt độ ưu tiên cho 1 luồng ta dùng phương thức: void setPriority(int newPriority) • int newPriority: Mức độ ưu tiên từ 1 đến 10. Java có định nghĩa sẵn 3 mức ưu tiên chuẩn như sau: • Thread.MIN_PRIORITY (giá trị 01) • Thread.NORM_PRIORITY (giá trị 05) • Thread.MAX_PRIORITY (giá trị 10) Để lấy độ ưu tiên của 1 luồng, ta dùng phương thức: int getPriority(). Ví dụ 3-3. Chương trình xác định mức độ ưu tiên của luồng. WorkingThread.java package vn.tbit.info; public class WorkingThread extends Thread à public WorkingThread(String name) à super(name); â public void run() à for (int i = 0; i &lt; 5; i++) à System.out.printf(\"Luồng: %s có độ ưu tiên là %d \\n\", getName(), getPriority()); â â â ThreadInfoExample.java package vn.tbit.info; public class ThreadInfoExample à public static void main(String[] args) à 45 Thread t1 = new WorkingThread(\"Luồng 1\"); Thread t2 = new WorkingThread(\"Luồng 2\"); Thread t3 = new WorkingThread(\"Luồng 3\"); System.out.println(\"ID luồng 1: \" + t1.getId()); System.out.println(\"ID luồng 2: \" + t2.getId()); System.out.println(\"ID luồng 3: \" + t3.getId()); t1.setPriority(1); t2.setPriority(5); t3.setPriority(10); t1.start(); t2.start(); t3.start(); â â Kết quả thực thi chương trình trên: ID luồng 1: 10 ID luồng 2: 11 ID luồng 3: 12 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 2 có độ ưu tiên là 5 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 3 có độ ưu tiên là 10 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 1 có độ ưu tiên là 1 Luồng: Luồng 1 có độ ưu tiên là 1",
        "Summary": "Văn bản mô tả các thuộc tính của luồng (thread) trong Java, bao gồm ThreadId (định danh tự động tạo bởi máy ảo Java), ThreadName (tên luồng có thể đặt hoặc tự động đặt theo quy tắc \"Thread-\" + thứ tự), và Priority (độ ưu tiên, có thể đặt bằng `setPriority()` với giá trị từ 1 đến 10, hoặc sử dụng các hằng số `MIN_PRIORITY`, `NORM_PRIORITY`, `MAX_PRIORITY`). Ví dụ minh họa cho thấy cách lấy ThreadId bằng `getId()` và đặt/lấy độ ưu tiên luồng, ảnh hưởng đến thứ tự thực thi. Kết quả cho thấy luồng có độ ưu tiên cao hơn được ưu tiên thực thi trước.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào. Các khái niệm như ThreadId, ThreadName, Priority, các phương thức getId(), setPriority(), và các hằng số MIN_PRIORITY, NORM_PRIORITY, MAX_PRIORITY đều được mô tả chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic. Cách sắp xếp thông tin theo thứ tự ThreadId, ThreadName, và Priority giúp người đọc dễ dàng nắm bắt các thuộc tính của luồng trong Java. Việc đề cập đến các phương thức và hằng số liên quan cũng được tích hợp một cách tự nhiên vào nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, đó là các thuộc tính quan trọng của luồng trong Java. Các chi tiết không cần thiết như code ví dụ đầy đủ đã được lược bỏ, chỉ giữ lại những phần quan trọng nhất để minh họa cho các khái niệm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã làm nổi bật được các thông tin quan trọng nhất từ văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00036",
        "Article": "Khuôn khổ chính sách cũng có xu hướng tập trung hơn và kiểm soát đối với các công nghệ. Những quy định thực tế như vậy dễ xảy ra xung đột với tiềm năng của công nghệ thông tin truyền thông. Công nghệ không chỉ đơn thuần là phần cứng mà là sự thành lập một bộ phận quản lý và thực tiễn hoạt động. Vì vậy, chính sách quản sử dụng của họ cần duy trì mở, linh hoạt, sáng tạo và có khả năng đáp ứng. Đánh giá thường xuyên là cần thiết để đảm bảo rằng các nhu cầu đặc biệt của các dự án dựa trên công nghệ thông tin truyền thông và các chương trình được thực hiện. Module 2 lập luận cho các loại hình gắn kết trong hình thành chính sách công nghệ thông tin truyền thông phục vụ cho phát triển và thực hành. Các sáng kiến thiết kế và thực hiện bởi các chính phủ thông thường như một phần của một chương trình nghị sự phát triển rộng rãi có xu hướng phản ánh sự quá lệ thuộc vào quy ước của các tổ chức hiện có: họ kết hợp các hệ thống thứ bậc và quan liêu của trong quản lí. Nhưng các mô hình quản lý dự án hoặc các sáng kiến được tập trung triển khai thực hiện không đầy đủ thì địa phương lại có nhu cầu xem xét. Sự phát triển của các giải pháp ở địa phương là cần thiết. Môđun 3 bàn về các thiết kế và phát triển dụng công nghệ thông tin truyền thông liên quan đến cả chính phủ và các công dân. Phương pháp thông thường để quản lý dự án sử dụng công nghệ thông tin truyền thông thường giả định rằng cơ sở hạ tầng là cần thiết đầu tiên và do đó, đầu tư phần cứng, các tòa nhà, thiết bị và thuê nhân viên, được ưu tiên. Phần lớn đầu tư 98 nói chung đi vào các chi phí trên kia và vài nguồn lực được để lại cho các hoạt động của dự án. Sự đầu tư song song vào con người, trong nghiên cứu chất lượng của xã hội, quản lý dự án và huy động cộng đồng và sự tham gia, hiếm khi diễn ra.",
        "Summary": "Những quy định thực tế như vậy dễ xảy ra xung đột với tiềm năng của công nghệ thông tin truyền thông. Nhưng các mô hình quản lý dự án hoặc các sáng kiến được tập trung triển khai thực hiện không đầy đủ thì địa phương lại có nhu cầu xem xét. Phương pháp thông thường để quản lý dự án sử dụng công nghệ thông tin truyền thông thường giả định rằng cơ sở hạ tầng là cần thiết đầu tiên và do đó, đầu tư phần cứng, các tòa nhà, thiết bị và thuê nhân viên, được ưu tiên. Sự đầu tư song song vào con người, trong nghiên cứu chất lượng của xã hội, quản lý dự án và huy động cộng đồng và sự tham gia, hiếm khi diễn ra.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả các câu đều được trích dẫn trực tiếp từ văn bản gốc mà không có bất kỳ sự thay đổi hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, tuy nhiên, vì các câu được trích dẫn từ các phần khác nhau của văn bản gốc nên sự liên kết giữa chúng không được tự nhiên và rõ ràng. Cần có sự chỉnh sửa để các ý tưởng được kết nối tốt hơn."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số chi tiết liên quan đến chủ đề chính, nhưng việc lựa chọn các câu có vẻ ngẫu nhiên và không tập trung vào các ý chính của văn bản gốc. Ví dụ, việc tập trung vào đầu tư cơ sở hạ tầng mà không đề cập đến các khía cạnh khác có thể làm mất đi sự cân bằng trong thông tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có độ trung thực cao, nhưng tính mạch lạc và liên quan còn yếu. Để cải thiện, cần chọn lọc các ý chính một cách cẩn thận hơn và sắp xếp chúng một cách logic để tạo ra một bản tóm tắt dễ hiểu và phản ánh đúng nội dung của văn bản gốc. Cần tập trung vào việc làm nổi bật các luận điểm quan trọng và loại bỏ các chi tiết không cần thiết."
            }
        }
    },
    {
        "Index": "00037",
        "Article": "Trong phần này, chúng ta sẽ làm quen với một thuật toán xây dựng cây quyết định ra đời từ rất sớm. ID3 (Iterative Dichotomiser 3) do Ross Quinlan đề xuất năm 1986, là một thuật toán xây dựng/học cây quyết định được áp dụng cho các bài toán phân loại mà tất cả các thuộc tính đều có kiểu định danh/phạm trù. Trong ID3, chúng ta cần xác định thứ tự của thuộc tính cần được xem xét tại mỗi bước. Với các bài toán có nhiều thuộc tính và mỗi thuộc tính có nhiều giá trị khác nhau, việc tìm được cây tối ưu thường là không khả thi. Thay vào đó, một phương pháp đơn giản thường được sử dụng là tại mỗi bước, một thuộc tính tốt nhất sẽ được chọn ra dựa trên một tiêu chuẩn nào đó. Việc chọn ra thuộc tính tốt nhất ở mỗi bước như thế này được gọi là cách chọn tham lam (greedy). Cách chọn này có thể không phải là tối ưu, nhưng trực giác cho chúng ta thấy rằng cách làm này sẽ gần với cách làm tối ưu. Ngoài ra, cách làm này khiến cho bài toán cần giải quyết trở nên đơn giản hơn. ID3 thực hiện tìm kiếm tham lam trên không gian các cây quyết định để xây dựng một cây quyết định theo chiến lược top-down, bắt đầu từ nút gốc. Cụ thể: • Ởmỗi nút, chọn thuộc tính kiểm tra tốt nhất- là thuộc tính có khả năng phân loại tốt nhất đối với các mẫu học gắn với nút đó. • Tạo mới một cây con của nút hiện tại cho mỗi giá trị có thể của thuộc tính kiểm tra, và tập học sẽ được tách ra thành các tập con tương ứng với cây con vừa tạo. Quá trình phát triển cây quyết định sẽ tiếp tục cho đến khi: • Cây quyết định phân loại hoàn toàn các mẫu học, hoặc • Tất cả các thuộc tính đã được sử dụng Trong quá trình xây dựng một cây quyết định, với mỗi thuộc tính được chọn, ta chia dữ liệu tại nút đang xét vào các nút con tương ứng với tất cả các giá trị có thể của thuộc tính đó rồi tiếp tục áp dụng phương pháp này cho mỗi nút con. Do vậy, mỗi thuộc tính chỉ được phép xuất hiện tối đa 1 lần đối với bất kỳ một đường đi nào trong cây.",
        "Summary": "Thuật toán ID3 (Iterative Dichotomiser 3) là một thuật toán xây dựng cây quyết định cho bài toán phân loại với thuộc tính định danh. ID3 sử dụng phương pháp tìm kiếm tham lam để chọn thuộc tính tốt nhất tại mỗi nút dựa trên tiêu chuẩn phân loại, từ đó xây dựng cây quyết định theo chiến lược top-down. Quá trình này tiếp tục cho đến khi cây phân loại hoàn toàn các mẫu học hoặc tất cả thuộc tính đã được sử dụng, đảm bảo mỗi thuộc tính chỉ xuất hiện tối đa một lần trên mỗi đường đi trong cây.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tính súc tích và hiệu quả."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt đầy đủ, chính xác các ý chính của văn bản gốc, đồng thời đảm bảo tính mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00038",
        "Article": "a. IPTV phân phối trên mạng truy cập cáp quang\n Đối với IPTV thì yêu cầu về băng thông lớn nhưng chi phí hoạt động phải thấp và\n tránh được các can nhiễu. Do đó, người ta quan tâm tới việc sử dụng mạng cáp quang\n đang có sẵn để triển khai các dịch vụ IPTV. Các liên kết cáp quang cung cấp cho khách\n hàng đầu cuối một kết nối chuyên dụng tốt nhất để thuận tiện cho việc tiếp nhận nội\n dung IPTV. Có thể thực thi một trong các cấu trúc mạng sau:\n · Cáp quang tới khu vực văn phòng (FTTRO – Fiber to the regional office): Sợi\n quang từ trung tâm dữ liệu IPTV tới khu vực văn phòng một cách gần nhất được lắp\n đặt bởi các công ty viễn thông hoặc công ty cáp. Sau đó sợi cáp đồng sẽ được sử\n dụng để truyền tín hiệu tới người dùng đầu cuối IPTV trong khu vực văn phòng đó.\n · Cáp quang tới vùng lân cận (FTTN – Fiber to the neighborhood): FTTN đòi hỏi\n thiết lập sợi quang từ trung tâm dữ liệu IPTV tới bộ chia “vùng lân cận”. Đây là vị trí\n node có khoảng cách nhỏ hơn 1,5 Km tính từ nhà thuê bao. Việc triển khai FTTN\n cho phép người dùng nhận một gói các dịch vụ trả tiền bao gồm truyền hình IPTV,\n truyền hình chất lượng cao và video theo yêu cầu.\n · Cáp quang tới lề đường (FTTC – Fiber to the curd ): sợi quang được lắp đặt từ\n trung tâm dữ liệu IPTV tới các tủ cáp được đặt tại lề đường. Từ đó một sợi dây cáp\n đồng hoặc cáp đồng trục được sử dụng để nối từ đầu cuối cáp quang trong tủ cáp tới\n vị trí thiết bị IPTV của nhà thuê bao.\n · Cáp quang tới nhà khách hàng (FTTH – Fiber to the home): với sợi quang tới nhà\n khách hàng, toàn bộ các định tuyến từ trung tâm dữ liệu IPTV tới nhà khách hàng\n đều được kết nối bởi sợi quang này. FTTH dựa trên mạng quang có khả năng phân\n phối dung lượng dữ liệu cao tới người sử dụng trong hệ thống. FTTH là hệ thống\n thông tin song kênh và hỗ trợ tính năng tương tác của các dịch vụ IPTV.\n Việc phân phối những cấu trúc mạng này thường được triển khai bằng hai loại mạng\n khác nhau một chút đó là mạng quang thụ động và mạng quang tích cực:",
        "Summary": "\"IPTV đòi hỏi băng thông lớn và chi phí thấp, do đó việc sử dụng mạng cáp quang được quan tâm. Các cấu trúc mạng cáp quang phổ biến bao gồm: FTTRO (cáp quang đến khu vực văn phòng, sau đó dùng cáp đồng), FTTN (cáp quang đến bộ chia vùng lân cận), FTTC (cáp quang đến tủ cáp ở lề đường, sau đó dùng cáp đồng/đồng trục), và FTTH (cáp quang trực tiếp đến nhà khách hàng, cung cấp băng thông cao và tính năng tương tác). Các cấu trúc này thường được triển khai bằng mạng quang thụ động hoặc mạng quang tích cực.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào yêu cầu băng thông của IPTV, các cấu trúc mạng cáp quang phổ biến và phương pháp triển khai, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00039",
        "Article": "Có rất nhiều ứng dụng thực tế khác nhau của học máy. Hai lĩnh vực ứng dụng lớn nhất của học máy là khai phá dữ liệu (data mining) và nhận dạng mẫu (pattern recognition). Khai phá dữ liệu là ứng dụng kỹ thuật học máy vào các cơ sở dữ liệu hoặc các tập dữ liệu lớn để phát hiện quy luật hay tri thức trong dữ liệu đó hoặc để dự đoán các thông tin quan tâm trong tương lai. Ví dụ, từ tập hợp hóa đơn bán hàng có thể phát hiện ra quy luật “những người mua bánh mì thường mua bơ”. Nhận dạng mẫu là ứng dụng các kỹ thuật học máy để phát hiện các mẫu có tính quy luật trong dữ liệu, thường là dữ liệu hình ảnh, âm thanh. Bài toán nhận dạng mẫu cụ thể thường là xác định nhãn cho đầu vào cụ thể, ví dụ cho ảnh chụp mặt người, cần xác định đó là ai. Cần lưu ý, khai phá dữ liệu và nhận dạng mẫu có nhiều điểm trùng nhau cả trong phạm vi nghiên cứu và ứng dụng. Điểm khác nhau chủ yếu liên quan tới lĩnh vực ứng dụng và kỹ thuật sử dụng, theo đó khai phá dữ liệu liên quan tới dữ liệu thương mại trong khi nhận dạng mẫu liên quan nhiều tới dữ liệu âm thanh, hình ảnh và được dùng nhiều trong kỹ thuật. Ứng dụng cụ thể Sau đây là một số ví dụ ứng dụng cụ thể của học máy: - Nhận dạng ký tự: phân loại hình chụp ký tự thành các loại, mỗi loại ứng với một ký tự tương ứng. Phát hiện và nhận dạng mặt người: phát hiện vùng có chứa mặt người trong ảnh, xác định đó là mặt người nào trong số những người đã có ảnh trước đó, tức là phân chia ảnh thành những loại tương ứng với những người khác nhau. Lọc thư rác, phân loại văn bản: dựa trên nội dung thư điện tử, chia thư thành loại “thư rác” hay “thư bình thường”; hoặc phân chia tin tức thành các thể loại khác nhau như “xã hội”, “kinh tế”, “thể thao”.v.v. Dịch tự động: dựa trên dữ liệu huấn luyện dưới dạng các văn bản song ngữ, hệ thống dịch tự động học cách dịch từ ngôn ngữ này sang ngôn ngữ khác. Hệ thống dịch tự động tiêu biểu dạng này là Google Translate. Chẩn đoán y tế: học cách dự đoán người bệnh có mắc hay không mắc một số bệnh nào đó dựa trên triệu chứng quan sát được. Phân loại khách hàng và dự đoán sở thích: sắp xếp khách hàng vào một số loại, từ đây dự đoán sở thích tiêu dùng của khách hàng. Dự đoán chỉ số thí trường: căn cứ giá trị một số tham số hiện thời và trong lịch sử, đưa ra dự đoán, chẳng hạn dự đoán giá chứng khoán, giá vàng.v.v. Các hệ khuyến nghị, hay hệ tư vấn lựa chọn: cung cấp một danh sách ngắn các loại hàng hóa, phim, video, tin tức v.v. mà người dùng nhiều khả năng quan tâm. Ví dụ ứng dụng loại này là phần khuyến nghị trên Youtube hay trên trang mua bán trực tuyến Amazon. Ứng dụng lái xe tự động: dựa trên các mẫu học chứa thông tin về các tình huống trên đường, hệ thống học máy cho phép tự ra quyết định điều khiển xe, và do vậy không cần người lái. Hiện Google đã có kế hoạch thương mại hóa xe ôtô tự động lái như vậy.",
        "Summary": "Học máy có nhiều ứng dụng thực tế, trong đó lớn nhất là khai phá dữ liệu (phát hiện quy luật trong dữ liệu lớn) và nhận dạng mẫu (phát hiện mẫu trong dữ liệu hình ảnh, âm thanh). Các ứng dụng cụ thể bao gồm nhận dạng ký tự, phát hiện và nhận dạng khuôn mặt, lọc thư rác, dịch tự động, chẩn đoán y tế, phân loại khách hàng, dự đoán chỉ số thị trường, hệ thống khuyến nghị và lái xe tự động.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các ứng dụng lớn của học máy và các ví dụ cụ thể, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về các ứng dụng của học máy một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00040",
        "Article": "Những cơ hội marketing nhờ sự hội tụ của các phương tiện công nghệ là rất lớn. Ba sự hội tụ phương tiện trên Internet đáng chú ý nhất hiện nay gồm: Tiếng nói & hình ảnh và dữ liệu. Hình thức đầu tiên của sự hội tụ là hội tụ tiếng nói, hình ảnh, và dữ liệu trên Internet. Nó cho phép các DN chỉ cần sử dụng một ứng dụng chung cho việc truyền thông giọng nói, hình ảnh và dữ liệu thay vì sử dụng 3 hệ thống riêng biệt. Cisco đang đi đầu về phát triển cho thị trường này, hỗ trợ cả về cơ sở hạ tầng lẫn sự áp dụng của người sử dụng cuối cùng như điện thoại IP. Các thiết bị không dây và website. Sự hội tụ thứ hai của phương tiện truyền thông là sự hội tụ của những thiết bị không dây - điện thoại di động và những thiết bị kỹ thuật số trợ giúp cá nhân (PDAs) - với truy cập website và thỉnh thoảng còn bao gồm cả chức năng định vị toàn cầu (GPS). Sự giới hạn chính đối với trình duyệt web là kích cỡ màn hình của PDAs và điện thoại di động là có màn hình nhỏ hơn. Từ màn hình điện thoại di động nhỏ xíu có thể sử dụng để kiểm tra thư điện tử và thời tiết, tin tức và chỉ số chứng khoán,... Tuy nhiên, nội dung web chủ đạo là thiết kế màu sắc trên những hiển thị rộng. Dù sao, nhiều websites đang bắt đầu tạo nội dung cho giao thức truy cập không dây (WAP) đến khi nó hiển thị một cách phù hợp trên những màn hình nhỏ xíu. Sự giới hạn thứ hai của trình duyệt web trên các thiết bị không dây là tốc độ đường truyền. Mạng không dây trong vài trường hợp ngoại lệ, chậm hơn những mạng có dây dẫn. Mặc dù với những hạn chế, thị trường này vẫn đang phát triển một cách nhanh chóng. Một công nghệ được chú ý tới là các mạng Wi-Fi được xây dựng trên tiêu chuẩn Ethernet 802.11b. Ngoài ra, một công nghệ phổ biến hiện nay là mạng điện thoại di động 3G. Phát thanh truyền hình và Internet. Dạng hội tụ thứ ba là giữa phương tiện thông tin phát sóng rộng (vô tuyến truyền hình và máy thu thanh), và Internet, đôi lúc được gọi là ITV. Sự hội tụ này sẽ giúp cho việc nhận được nội dung của phát thanh, truyền hình thông qua Internet. Trở ngại lớn là thiếu băng thông lớn để có thể truyền tải trơn tru toàn bộ đoạn video. Tuy nhiên, bộ điều giải cáp, bộ điều giải DSL, và sự truy cập không dây cố định có thể cung cấp độ dài dải tần lớn hơn để vượt qua được những trở ngại này. Dạng hội tụ ban đầu của Web/TV là của MSN TV và Enhanced TV. Với dạng thứ nhất, những người sử dụng MSN TV có thể đọc các trang web trên màn hình TV. Tuy nhiên mô hình này không thành công lắm do tính năng hạn chế của màn hình TV và trên thực tế mà những người tiêu dùng không có thói quen đọc trên màn hình TV. Dạng thứ hai, ABC’s Enhanced TV yêu cầu những người sử dụng phải đăng nhập vào website của ABC trong khi họ đang xem một chương trình TV. Những người sử dụng có thể tìm được nhiều thông tin hơn về phát thanh truyền hình, chơi trò chơi với những người sử dụng khác, và đặc biệt trong việc thăm dò ý kiến và nói chuyện. Thật thú vị, khi xúc tiến triển lãm trên Enhanced TV, “Ai muốn trở thành triệu phú”, 97% những người sử dụng đăng nhập Enhanced TV nói họ muốn quay trở lại.",
        "Summary": "\"Sự hội tụ của các phương tiện công nghệ (tiếng nói, hình ảnh, dữ liệu, thiết bị không dây, phát thanh truyền hình và Internet) mang lại nhiều cơ hội marketing. Ba hình thức hội tụ đáng chú ý nhất là: (1) Hội tụ tiếng nói, hình ảnh và dữ liệu trên Internet, cho phép truyền thông đa phương tiện qua một ứng dụng duy nhất. (2) Hội tụ thiết bị không dây (điện thoại di động, PDA) với truy cập web, dù còn hạn chế về kích thước màn hình và tốc độ đường truyền. (3) Hội tụ phát thanh truyền hình và Internet (ITV), cho phép tiếp nhận nội dung phát sóng qua Internet, với thách thức về băng thông. Các mô hình ban đầu như MSN TV chưa thành công do hạn chế về trải nghiệm người dùng, trong khi Enhanced TV của ABC cho thấy tiềm năng tương tác cao.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ nguyên và trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách trôi chảy, tạo thành một đoạn văn thống nhất."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào ba hình thức hội tụ phương tiện và những đặc điểm, thách thức của chúng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00041",
        "Article": "Trong mạch cải tiến 2.2.18b, mạch tính cực T6, Rb, Rc thay thế R3 trong mạch 2.2.18a.\n Mạch cải tiến là mạch nguồn điều khiển hình thành mạch phóng điện cho bazơ T5.\n • Cải tiến đặc tính truyền đạt điện áp\n Vì emitơ T2 chỉ có thể thông qua mạch emitơ T5, T6 nên trước khi T5, T6 thông thì mạch cải tiến chẳng khác gì mạch gốc và không còn giai đoạn T2 thông mà T5 vẫn chưa thông. Trong mạch gốc, giai đoạn T2 thông mà T5 chưa thông tương ứng phần tuyến tính trên đặc tuyến truyển đạt điện áp. Hình 2.2.19 là đặc tính truyên đạt của mạch 2.2.18b, không có phần tuyến tính nữa.\n Từ hình 2.2.19, ta nhận thấy múc tạp âm cho phép khi đầu vào mức thấp của mạch cải tiến lớn hơn mạch gốc rõ rệt, VNL = 1V.\n • Cải tiến thời gian truyền đạt.\n Khi VI đột biến từ mức thấp đến xấp xỉ 1,4V thì cả T5, T6 đều bắt đầu thông. Ở thời điểm bắt đầu thông, hầu như toàn bộ dòng emitơ T2 chảy đến bazơ T5, cung cấp cho T5 xung dòng rất lớn (vượt quá giá trị cần để T5 thông bão hòa), vì vậy giảm nhỏ thời gian trễ thông mạch của T5. Có thể đạt được điểu đó là vì nối tiếp bazơ của T6, sự nạp điện điện dung chuyển tiếp emitơ T6 chậm hơn sự nạp điện điện dung chuyển tiếp emitơ T5. Kết quả T6 thông chậm hơn T5 một chút. Còn sau khi T6 đã thông thì mạch T6 phân dòng cho bazơ T5, giảm nhỏ dòng bazơ ở trạng thái ổn định, giảm bớt độ hão hòa của T5, có lợi cho sự tăng tốc quá trình ngắt mạch của T5.\n Sau khi điện áp đầu vào có đột biến âm, T2 ngắt đấu tiên. Tiếp đó, điện tích tồn trữ của T5 sẽ được phóng qua mạch T6. Lúc này T6 vẫn thông bão hòa, biểu thị một điện trở nhỏ của mạch phóng điện. Kết quả, T5 nhanh chóng rời vùng bão hòa và ngắt hở mạch.\n Vậy mạch tích cực T6, Rb, Rc thay thế R3 đem lại sự cải tiến: rút ngắn thời gian tồn trữ động, rút ngắn thời gian trễ thông, dẫn đến rút ngắn rõ rệt thời gian truyền đạt trung bình.\n Hiện nay mạch điện hình 2.2.18.b là cổng NAND TTL được dùng rộng.",
        "Summary": "\"Mạch cải tiến 2.2.18b sử dụng mạch tích cực T6, Rb, Rc thay thế R3 trong mạch 2.2.18a để điều khiển mạch phóng điện cho bazơ T5, cải thiện đặc tính truyền đạt điện áp và thời gian truyền đạt. Mạch cải tiến loại bỏ phần tuyến tính trên đặc tuyến truyền đạt điện áp, tăng mức tạp âm cho phép. Khi T5, T6 bắt đầu thông, T5 nhận xung dòng lớn giúp giảm thời gian trễ thông mạch. Sau khi T6 thông, nó phân dòng cho bazơ T5, giảm độ bão hòa và tăng tốc quá trình ngắt mạch của T5. Nhờ đó, mạch cải tiến rút ngắn thời gian tồn trữ động, thời gian trễ thông, và thời gian truyền đạt trung bình. Mạch điện cải tiến này (hình 2.2.18.b) là cổng NAND TTL được sử dụng rộng rãi.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và theo một trình tự hợp lý."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào mục đích cải tiến của mạch và kết quả đạt được."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, bao quát được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00042",
        "Article": "Quá trình quản trị marketing TMĐT về cơ bản bao gồm 6 bước cụ thể: Bước 1: Phân tích tình thế chiến lược marketing TMĐT. Hoạch định chiến lược marketing TMĐT không có nghĩa là bắt đầu từ vạch xuất phát. Việc khởi đầu từ chính những mô hình kinh doanh hiện tại và từ kế hoạch marketing truyền thống là điểm hợp lý nhất để bắt đầu. Vận dụng ma trận TOWS, xem xét lại kế hoạch marketing hiện tại và xem xét lại các mục tiêu đề ra trong hoạt động kinh doanh ứng dụng TMĐT của DN, xem xét lại các chiến lược và phương thức tổ chức thực thi hiện tại chính là nội dung chính của bước này. Ví dụ: Phân tích TOWS tình thế chiến lược marketing TMĐT của một DN. Thời cơ: Thị trường dành cho giới trẻ ngày càng được mở rộng, chi phí gửi thư qua bưu điện giảm nhờ marketing qua email. Đe dọa: Luật an toàn mạng sắp ra đời có nghĩa chi phí để nâng cấp phần mềm tăng lên, đối thủ cạnh tranh X của DN ngày càng mạnh. Điểm mạnh: Dịch vụ khách hàng tốt, hệ thống cơ sở dữ liệu và website tốt. Điểm yếu: Văn hóa hợp tác kỹ thuật trong DN kém, nguồn vốn hạn hẹp. Mục tiêu ứng dụng TMĐT trong kinh doanh của DN: Bắt đầu áp dụng TMĐT thành công ngay trong năm thứ hai. Mục tiêu hoạt động: Đạt doanh thu 10 tỷ VNĐ từ TMĐT trong năm thứ nhất. Bước 2: Gắn kết mô hình ứng dụng TMĐT và thiết lập các mục tiêu chiến lược marketing TMĐT. Jeff Bezos - người sáng lập và đồng thời là chủ tịch của Amazon.com, một trong những DN kinh doanh qua mạng hàng đầu thế giới với doanh số năm 2005 khoảng 7 tỷ USD, đã phát biểu rằng: “Mọi DN đều phải chú trọng tới khách hàng, hướng tới nhu cầu của khách hàng trước khi đề cập tới sản phẩm của mình, cho dù trong thời đại CNTT hay các thời đại khác.” Trong mục trên đã giới thiệu các mô hình ứng dụng TMĐT phổ biến, ứng với mỗi mô hình là một cấu trúc tương ứng các dịch vụ TMĐT cho một loại hoặc đoạn thị trường khách hàng điện tử mục tiêu, đòi hỏi một kết cấu hạ tầng CNTT-TT tương hợp và có ảnh hưởng, làm điều kiện cho các dự báo và thiết lập mục tiêu marketing TMĐT trong dài hạn. Đối với DN, mục tiêu của marketing TMĐT không khác với marketing truyền thống, đều là doanh số, lợi nhuận, thị phần,... Điều này cho thấy, trong thời đại CNTT và Internet hiện nay, marketing TMĐT hay truyền thống đều hướng tới cùng một đối tượng, đó là khách hàng. Tuy nhiên, mục tiêu marketing TMĐT phải đảm bảo: đưa ra được nhiệm vụ cụ thể, đo được về số lượng, và có giới hạn thời gian nhất định. Trên thực tế, phần lớn kế hoạch marketing TMĐT hướng tới hoàn thiện nhiều mục tiêu, ví dụ như: tăng thị phần, tăng doanh thu, giảm chi phí, đạt được mục tiêu nhãn hiệu (tăng sự hiểu biết về nhãn hiệu sản phẩm), tăng cường hệ thống cơ sở dữ liệu, đạt được mục tiêu quan hệ khách hàng, cải thiện quản trị chuỗi cung ứng.",
        "Summary": "Quá trình quản trị marketing TMĐT gồm 6 bước, bắt đầu bằng **phân tích tình thế chiến lược** sử dụng ma trận TOWS để đánh giá mô hình kinh doanh hiện tại và kế hoạch marketing truyền thống, xác định cơ hội, thách thức, điểm mạnh, điểm yếu. Sau đó, **gắn kết mô hình ứng dụng TMĐT và thiết lập mục tiêu chiến lược marketing TMĐT**, chú trọng vào nhu cầu khách hàng và lựa chọn mô hình phù hợp, đồng thời đặt ra các mục tiêu cụ thể, đo lường được và có giới hạn thời gian (ví dụ: tăng thị phần, doanh thu, giảm chi phí, tăng nhận diện thương hiệu).",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các bước chính trong quản trị marketing TMĐT và mục tiêu của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về quá trình quản trị marketing TMĐT. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00043",
        "Article": "Mỗi chương trình bao gồm một số thành phần có ý nghĩa khác nhau: dữ liệu, lệnh, hàm, ngăn xếp.v.v., tuy nhiên, khi phân trang, chương trình được chia thành các trang kích thước đều nhau, không quan tâm đến tổ chức lôgic và ý nghĩa các thành phần. Bộ nhớ được coi như một khối duy nhất các byte hoặc các từ. Một cách tổ chức khác cho phép tính tới tổ chức lôgic của chương trình là phân đoạn (segmentation). Chương trình được chia thành những phần kích thước khác nhau gọi là đoạn (segment) tuỳ theo ý nghĩa của chúng. Chẳng hạn, ta có thể phân biệt: đoạn chương trình, chứa mã toàn bộ chương trình, hay một số hàm hoặc thủ tục của chương trình; đoạn dữ liệu, chứa các biến toàn cục, các mảng; đoạn ngăn xếp, chứa ngăn xếp của tiến trình trong quá trình thực hiện. Không gian địa chỉ lôgic của tiến trình khi đó sẽ gồm tập hợp các đoạn. Mỗi đoạn tương ứng với không gian địa chỉ riêng, được phân biệt bởi tên và độ dài của mình. Ngoài cách dùng tên, đoạn cũng có thể được đánh số để phân biệt. Mỗi địa chỉ lôgic do CPU sinh ra khi đó sẽ gồm hai phần: số thứ tự của đoạn và độ dịch trong đoạn. Việc chia chương trình thành các đoạn có thể do người lập trình thực hiện, chẳng hạn khi lập trình bằng assembly, hoặc do chương trình dịch tự của ngôn ngữ bậc cao tự động chia. Người lập trình khi đó cần biết kích thước tối đa được phép của đoạn, ví dụ để không khai báo mảng vượt kích thước tối đa này. Phân đoạn bộ nhớ giống với phân chương động ở chỗ bộ nhớ được cấp phát theo từng vùng kích thước thay đổi. Tuy nhiên, khác với phân chương động, mỗi chương trình có thể chiếm những đoạn bộ nhớ không nằm liền kề nhau. Mỗi khi có yêu cầu cấp phát bộ nhớ cho các đoạn, thuật toán cấp phát first-fit hoặc best-fit như phân chương động sẽ được sử dụng. Cũng như phân chương động, phân đoạn không sinh phân mảnh trong nhưng lại tạo phân mảnh ngoài. Mức độ phân mảnh ngoài phụ thuộc vào kích thước trung bình của đoạn. Đoạn càng nhỏ thì phân mảnh ngoài càng giảm. Trường hợp đặc biệt, nếu kích thước đoạn là một byte hay một từ tức là bằng đơn vị thông tin nhỏ nhất được đánh địa chỉ của bộ nhớ thì sẽ hoàn toàn không có phân mảnh ngoài. Tuy nhiên, số lượng đoạn tăng làm tăng kích thước của bảng phân đoạn và tăng thời gian quản lý các đoạn. Kích thước đoạn thường phụ thuộc kích thước bộ nhớ. Bộ nhớ càng lớn thì kích thước đoạn cũng được chọn càng lớn. Nhìn chung, phân mảnh ngoài khi phân đoạn nhỏ hơn phân chương động do tiến trình đã được chia thành các đoạn kích thước nhỏ hơn.",
        "Summary": "Phân đoạn bộ nhớ chia chương trình thành các đoạn có kích thước khác nhau dựa trên ý nghĩa của chúng, như đoạn chương trình, đoạn dữ liệu, và đoạn ngăn xếp. Mỗi địa chỉ lôgic do CPU sinh ra sẽ gồm số thứ tự đoạn và độ dịch trong đoạn. Mặc dù phân đoạn giúp tổ chức bộ nhớ linh hoạt và giảm phân mảnh trong, nó có thể gây phân mảnh ngoài, đặc biệt khi các đoạn nhỏ. Kích thước đoạn và số lượng đoạn phụ thuộc vào bộ nhớ, với phân mảnh ngoài ít hơn khi đoạn có kích thước nhỏ.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của phân đoạn bộ nhớ, ưu điểm và nhược điểm của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về phân đoạn bộ nhớ. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00044",
        "Article": "Thành phần cơ bản của PKI\n Dưới góc độ các hoạt động quản lý hệ thống PKI, những đối tượng tham gia vào hệ\n thống PKI bao gồm: các đối tượng sử dụng (EE), các đối tượng quản lý thẻ xác nhận (CA) và\n các đối tượng quản lý đăng ký (RA) và các hệ thống lưu trữ.\n - Thực thể cuối – Đối tượng sử dụng (EE – End Entity)91\n Là đối tượng sử dụng chứng nhận (chứng thư số): có thể là một tổ chức, một người cụ\n thể hay một dịch vụ máy chủ.\n - Tổ chức chứng nhận CA (Certificate Authority)\n Là cơ quan chuyên cung cấp và xác thực chứng chỉ số. CA có chức năng:\n + Có nhiệm vụ phát hành, quản lý và hủy bỏ các chứng thư số\n + Là thực thể quan trọng trong một PKI và được thực thể cuối tin cậy\n + Gồm tập hợp các con người và các hệ thống máy tính có độ an toàn cao.\n - Tổ chức đăng ký chứng nhận RA (Registration Authority)\n Là một cơ quan thẩm tra trên mạng máy tính, xác minh các yêu cầu của người dùng\n muốn sử dụng hoặc xác thực một chứng chỉ số và sau đó yêu cầu CA đưa ra kết quả. Mục\n đích chính của RA là để giảm tải công việc của CA. Chức năng thực hiện của một RA cụ thể\n sẽ khác nhau tùy theo nhu cầu triển khai PKI nhưng chủ yếu bao gồm các chức năng sau:\n + Được ủy quyền và có quyền thực hiện công việc mà CA cho phép\n + Tiếp nhận thông tin đăng ký chứng nhận\n + Gắn kết giữa khóa công khai và định danh của người giữ chứng nhận\n + Xác thực cá nhân, chủ thể đăng ký chứng thư số.\n + Kiểm tra tính hợp lệ của thông tin do chủ thể cung cấp.\n + Xác nhận quyền của chủ thể đối với những thuộc tính chứng thư số được yêu cầu.\n + Kiểm tra xem chủ thể có thực sự sở hữu khóa riêng đang được đăng ký hay không,\n điều này thường được đề cập đến như sự chứng minh sở hữu.\n + Tạo cặp khóa bí mật, công khai.\n + Phân phối bí mật được chia sẻ đến thực thể cuối (ví dụ khóa công khai của CA).\n + Thay mặt chủ thể thực thể cuối khởi tạo quá trình đăng ký với CA.\n + Lưu trữ khóa riêng.\n + Khởi sinh quá trình khôi phục khóa.\n + Phân phối thẻ bài vật lý (thẻ thông minh).\n - Hệ thống lưu trữ chứng nhận CR (Certificate Repository)\n Hệ thống lưu trữ chứng nhận CR có chức năng:\n + Hệ thống (có thể tập trung hoặc phân tán) lưu trữ chứng thư và danh sách các chứng\n thư bị thu hồi.\n + Cung cấp cơ chế phân phối chứng thư và danh sách thu hồi chứng thư (CRLs –\n Certificate Revocatio Lists).\n - Chứng chỉ số\n Chứng chỉ số là một tệp tin điện tử được sử dụng để nhận diện một cá nhân, một máy\n chủ, một công ty…trên Internet. Giống như bằng lái xe, hộ chiếu, chứng minh thư hay những\n giấy tờ nhận diện cá nhân thông thường khác, chứng chỉ số cung cấp bằng chứng cho sự nhận\n diện của một đối tượng.\n Để có chứng minh thư, bạn phải được cơ quan Công an sở tại cấp. Chứng chỉ số cũng92\n vậy, phải do một tổ chức đứng ra chứng nhận những thông tin của bạn là chính xác, được gọi\n là Nhà cung cấp chứng thực số (Certificate Authority, viết tắt là CA). CA phải đảm bảo về độ\n tin cậy, chịu trách nhiệm về độ chính xác của chứng chỉ số mà mình cấp.\n - Ủy quyền xác nhận hợp lệ - Validation Authority (VA)\n Validation Authority (VA) – Ủy quyền xác nhận hợp lệ: Xác nhận tính hợp lệ thẻ\n chứng thực số của một đối tác trao đổi thông tin. Hoặc VA là một thực thể cung cấp dịch vụ\n được sử dụng để xác minh tính hợp lệ của chứng chỉ kỹ thuật số theo các cơ chế được mô tả\n trong tiêu chuẩn X.509 và RFC 5280",
        "Summary": "\"Hệ thống PKI bao gồm các thành phần chính: đối tượng sử dụng (EE) là người dùng chứng thư số, tổ chức chứng nhận (CA) chịu trách nhiệm phát hành, quản lý và hủy bỏ chứng thư số, tổ chức đăng ký chứng nhận (RA) thẩm tra và xác minh yêu cầu chứng thư số, hệ thống lưu trữ chứng nhận (CR) lưu trữ chứng thư và danh sách thu hồi, và chứng chỉ số dùng để xác định danh tính trên Internet do CA cấp. Ngoài ra, còn có Ủy quyền xác nhận hợp lệ (VA) để xác nhận tính hợp lệ của chứng thư số.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các thành phần của hệ thống PKI được liệt kê rõ ràng và mối quan hệ giữa chúng được mô tả một cách logic. Câu văn trôi chảy và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các thành phần chính của hệ thống PKI và chức năng của chúng, loại bỏ các chi tiết không cần thiết. Các ý chính được giữ lại và trình bày một cách ngắn gọn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về các thành phần cơ bản của hệ thống PKI. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00045",
        "Article": "Bản thân Dữ liệu lớn được hình thành dựa trên lý thuyết. Ví dụ, nó sử dụng các lý thuyết thống kê và toán học, và đôi khi sử dụng cả khoa học máy tính. Đúng, chúng không phải là những lý thuyết về động lực quan hệ nhân quả của một hiện tượng đặc biệt như trọng lực, nhưng dù sao chúng vẫn là những lý thuyết. Và, như chúng ta đã chỉ ra, các mô hình dựa trên chúng có khả năng dự đoán rất hữu ích. Thật ra, dữ liệu lớn có thể cung cấp một cái nhìn tươi mát và những hiểu biết mới mẻ một cách chính xác vì nó không bị cản trở bởi lối suy nghĩ thông thường và những thành kiến cố hữu tiềm ẩn trong các lý thuyết của một lĩnh vực cụ thể. Hơn nữa, vì việc phân tích dữ-liệu-lớn được dựa trên các lý thuyết, ta không thể thoát khỏi chúng. Chúng định hình cả các phương pháp và các kết quả của chúng ta. Trước tiên là cách chúng ta lựa chọn dữ liệu. Các quyết định của chúng ta có thể được định hướng bởi sự tiện lợi: Phải chăng dữ liệu đã có sẵn? Hoặc bởi tính kinh tế: Liệu có thể thu thập được dữ liệu một cách ít tốn kém? Lựa chọn của chúng ta bị ảnh hưởng bởi các lý thuyết. Những gì chúng ta chọn sẽ ảnh hưởng tới những gì chúng ta tìm thấy, như các nhà nghiên cứu công nghệ số Danah Boyd và Kate Crawford đã lập luận. Xét cho cùng, Google đã sử dụng các từ khóa tìm kiếm như một phương tiện đo lường cho dịch cúm, chứ không sử dụng độ dài của tóc người. Tương tự như vậy, khi phân tích dữ liệu, chúng ta chọn những công cụ dựa trên các lý thuyết. Và khi giải thích kết quả, chúng ta lại áp dụng các lý thuyết. Thời đại của dữ liệu lớn rõ ràng không phải là không có lý thuyết - chúng có mặt khắp mọi nơi, với tất cả những gì chúng thừa hưởng. Anderson xứng đáng được vinh danh khi nêu lên những câu hỏi xác đáng - và đặc biệt là ông đã làm thế sớm hơn những người https://thuviensach.vn khác. Dữ liệu lớn có thể không chỉ rõ vào “Sự kết thúc của lý thuyết” , nhưng nó chuyển đổi một cách cơ bản cách chúng ta cảm nhận thế giới. Sự thay đổi này sẽ đòi hỏi rất nhiều công sức để làm quen. Nó thách thức nhiều tổ chức. Tuy nhiên, giá trị to lớn mà nó mang lại sẽ làm cho nó không chỉ là một sự đánh đổi đáng giá, mà còn là thứ không thể tránh khỏi. Tuy nhiên trước khi đạt tới đó, cũng đáng để lưu tâm xem chúng ta đã tới đây như thế nào. Nhiều người trong ngành kỹ thuật cao muốn gán công trạng chuyển đổi cho các công cụ kỹ thuật số mới, từ các chip nhanh tới phần mềm hiệu quả, bởi vì họ là những người làm ra công cụ. Sự kỳ diệu của kỹ nghệ là quan trọng, nhưng không quan trọng nhiều như người ta tưởng. Lý do sâu xa hơn của những xu hướng này là chúng ta có nhiều dữ liệu hơn rất nhiều. Và lý do chúng ta có nhiều dữ liệu hơn là vì chúng ta đã đưa nhiều khía cạnh hơn của thực tế vào một định dạng dữ liệu, cũng chính là chủ đề của chương kế tiếp.",
        "Summary": "Dữ liệu lớn được hình thành dựa trên các lý thuyết thống kê, toán học và khoa học máy tính, cung cấp cái nhìn mới mẻ do không bị ảnh hưởng bởi những thành kiến cố hữu. Các lý thuyết định hình cách lựa chọn dữ liệu, công cụ phân tích và giải thích kết quả, dù là dựa trên sự tiện lợi hay kinh tế. Dữ liệu lớn không loại bỏ lý thuyết mà chuyển đổi cách chúng ta cảm nhận thế giới, đòi hỏi sự thích nghi và mang lại giá trị to lớn, một phần nhờ vào việc số hóa nhiều khía cạnh của thực tế.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy và xác minh trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng để đảm bảo rằng bản tóm tắt phản ánh chính xác nội dung quan trọng nhất của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và súc tích về văn bản gốc. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00046",
        "Article": "Câu hỏi ở đây là: Nhà có chứa một phòng bếp hay không (House HAS-A Kitchen)? Nếu câu trả lời là \"Có\", điều đó có nghĩa House có một biến thực thể kiểu Kitchen. Nói cách khác, House có một tham 108 chiếu tới một đối tượng Kitchen, chứ House không chuyên biệt hóa Kitchen hay ngược lại. Quan hệ HAS-A trong Java được cài đặt bằng tham chiếu đặt tại đối tượng chứa chiếu tới đối tượng thành phần. Quan hệ HAS-A giữa hai lớp thể hiện một trong ba quan hệ: kết hợp (association), tụ hợp (aggregation) và hợp thành (composition) mà các tài liệu về thiết kế hướng đối tượng thường nói đến. Giữa hai lớp có quan hệ kết hợp nếu như các đối tượng thuộc lớp này cần biết đến đối tượng thuộc lớp kia để có thể thực hiện được công việc của mình. Chẳng hạn, một người nhân viên chịu sự quản lý của một người quản lý, ta có quan hệ kết hợp nối từ Employee tới Manager, thể hiện ở việc mỗi đối tượng Employee có một tham chiếu boss kiểu Manager. Hợp thành và tụ hợp là các quan hệ giữa một đối tượng và thành phần của nó (cũng là đối tượng). Khác nhau ở chỗ, với quan hệ hợp thành, đối tượng thành phần là phần không thể thiếu được của đối tượng chứa nó, còn với quan hệ tụ hợp thì ngược lại. Ví dụ, một cuốn sách bao gồm nhiều trang sách và một cuốn sách không thể tồn tại nếu không có trang nào. Do đó giữa Book (sách) và Page (trang) có quan hệ hợp thành. Thư viện có nhiều sách, nhưng thư viện không có cuốn sách nào vẫn là một thư viện, nên quan hệ giữa Library (thư viện) và Book là quan hệ tụ hợp. Java không có cấu trúc nào dành riêng để cài đặt các quan hệ tụ hợp hay hợp thành. Ta chỉ cài đặt đơn giản bằng cách đặt vào đối tượng chủ các tham chiếu tới đối tượng thành phần, hay nói cách khác là phân rã thành các quan hệ HAS-A, chẳng hạn quan hệ hợp thành giữa Book và Page có thể được phân rã thành 'Book HAS-A ArrayList<Page>' và nhiều quan hệ 'ArrayList<Page> HAS-A Page'. Các ràng buộc khác được đảm bảo bởi các phương thức có nhiệm vụ khởi tạo hay sửa các tham chiếu đó.",
        "Summary": "Văn bản mô tả quan hệ HAS-A trong thiết kế hướng đối tượng, thể hiện bằng tham chiếu giữa các đối tượng trong Java. Ba loại quan hệ chính được đề cập là kết hợp, tụ hợp và hợp thành, phân biệt nhau bởi mức độ phụ thuộc giữa đối tượng chứa và đối tượng thành phần. Java không hỗ trợ trực tiếp các quan hệ tụ hợp và hợp thành, mà thực hiện thông qua các tham chiếu (ví dụ: `Book HAS-A ArrayList<Page>`), với các ràng buộc được đảm bảo bởi các phương thức quản lý tham chiếu. Bản chất của HAS-A là một đối tượng sở hữu tham chiếu tới đối tượng khác, chứ không phải là sự kế thừa.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy và kiểm chứng trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo rằng người đọc có thể hiểu được bản chất của quan hệ HAS-A và các loại quan hệ liên quan mà không bị lạc trong các chi tiết vụn vặt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất cao. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00047",
        "Article": "Các phân tích ở phần trên cho thấy, việc cấp phát khối liên tiếp có nhiều nhược điểm đáng kể và do vậy ít khi được sử dụng. Một phương pháp cho phép khắc phục những nhược điểm này là sử dụng danh sách kết nối (linked list). Trong phương pháp này, các khối thuộc về mỗi file được nối với nhau thành một danh sách móc nối. Trên hình 4.8 là ví dụ một file bắt đầu từ khối 1 và bao gồm các khối 1,3, 8,17,6. Mỗi khối chứa con trỏ tới khối tiếp theo. Để chứa con trỏ, hệ điều hành dành ra một số byte ở đầu mỗi khối. Chẳng hạn, với khối kích thước là 512 byte, ta có thể dành 508 byte chứa dữ liệu của file, còn 4 byte chứa con trỏ tới khối tiếp theo. Khác với cách cấp phát khối ở phần trước, các khối thuộc về một file có thể nằm bất cứ chỗ nào trên đĩa chứa không nhất thiết nằm liền kề nhau. Để xác định vị trí file trên đĩa, khoản mục của thư mục sẽ chứa con trỏ tới khối đầu tiên của file. Khi mới tạo file, con trỏ này có giá trị nil (dấu hiệu kết thúc file và có thể có các giá trị khác nhau tuỳ vào hệ thống cụ thể). Mỗi khi file được cấp thêm khối mới, khối vừa cấp được thêm vào cuối danh sách. Để truy cập file, hệ điều hành đọc lần lượt từng khối và sử dụng con trỏ để xác định khối tiếp theo. Do các khối thuộc về một file có thể nằm bất cứ chỗ nào trên đĩa, không nhất thiết phải nằm cạnh nhau nên phương pháp cấp phát này cho phép tránh được hiện tượng phân mảnh ngoài. Không có khối trống nào bị bỏ phí. Phương pháp cấp phát này cũng không yêu cầu biết trước kích thước khi tạo file. Kích thước file có thể tăng dễ dàng sau khi đã được tạo. Để tăng kích thước file, hệ điều hành chỉ việc thêm khối trống vào danh sách và sửa lại con trỏ ở khối cuối. Mặc dù giải khắc phục được các nhược điểm của phương pháp cấp khối liên tục, sử dụng danh sách kết nối cũng có một số nhược điểm. Nhược điểm lớn nhất là phương pháp này chỉ hỗ trợ truy cập tuần tự mà khôngcho phép truy cập file trực tiếp. Để đọc một khối nào đó ta phải theo tất cả các con trỏ từ khối đầu tiên cho tới khối cần đọc. Do con trỏ nằm ngay trong các khối và khối là đơn vị nhỏ nhất có thể tiến hành đọc nên để xác định con trỏ, ta phải đọc cả khối. Như vậy, Để đọc một khối, ta phải đọc lần lượt tất cả các khối nằm trước bắt đầu từ khối đầu tiên. Nhược điểm thứ hai liên quan tới tốc độ truy cập file. Do các khối thuộc về một file có thể nằm rải rác ở nhiều nơi trên đĩa nên đầu từ của đĩa phải thực hiện nhiều thao tác di chuyển mới truy cập được hết dữ liệu của file. Việc liên kết các khối thuộc về một file bằng con trỏ cũng làm giảm độ tin cậy và tính toàn vẹn của hệ thống file. Trong trường hợp giá trị các con trỏ bị thay đổi không đúng do lỗi việc xác định khối nào thuộc file nào sẽ không chính xác. Chi tiết về tính toàn vẹn của hệ thống file sẽ được trình bầy trong một phần sau.",
        "Summary": "\"Phương pháp cấp phát khối bằng danh sách liên kết khắc phục nhược điểm của cấp phát khối liên tiếp bằng cách cho phép các khối của file nằm rải rác trên đĩa và được liên kết bằng con trỏ. Điều này giúp tránh phân mảnh ngoài và không cần biết trước kích thước file. Tuy nhiên, phương pháp này chỉ hỗ trợ truy cập tuần tự, làm chậm tốc độ truy cập do đầu đọc phải di chuyển nhiều và làm giảm độ tin cậy do con trỏ có thể bị lỗi.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, tập trung vào ưu điểm và nhược điểm của phương pháp cấp phát khối bằng danh sách liên kết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt ngắn gọn, đầy đủ, trung thực, mạch lạc và liên quan. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00048",
        "Article": "Phát triển phần mềm hướng đối tượng (Object-Oriented Software Development) là một phương pháp tiếp cận hiện đại và phổ biến trong việc thiết kế và xây dựng hệ thống phần mềm. Phương pháp này dựa trên nguyên lý mô hình hóa thế giới thực thông qua các đối tượng (objects), trong đó mỗi đối tượng là sự kết hợp giữa dữ liệu (thuộc tính) và hành vi (phương thức). Các đối tượng tương tác với nhau thông qua việc gửi và nhận thông điệp, tạo thành hệ thống phần mềm linh hoạt, dễ mở rộng và bảo trì. Các đặc điểm cốt lõi của phương pháp hướng đối tượng bao gồm: tính đóng gói (encapsulation), giúp che giấu chi tiết cài đặt và bảo vệ dữ liệu bên trong đối tượng; tính kế thừa (inheritance), cho phép lớp con kế thừa thuộc tính và hành vi từ lớp cha để tái sử dụng và mở rộng hệ thống; tính đa hình (polymorphism), giúp các đối tượng có thể xử lý các thông điệp theo cách riêng của mình tùy vào ngữ cảnh cụ thể. Việc phát triển phần mềm theo hướng đối tượng thường bắt đầu bằng phân tích hướng đối tượng, sử dụng các sơ đồ như Use Case, sơ đồ lớp, sơ đồ trình tự để xác định yêu cầu và mô hình hóa hệ thống. Sau đó, thiết kế hướng đối tượng được tiến hành để xác định cấu trúc lớp, quan hệ giữa các lớp, cách triển khai phương thức, từ đó chuyển sang lập trình bằng ngôn ngữ hướng đối tượng như Java, C++, C#, Python,... Hướng đối tượng giúp dễ quản lý hệ thống lớn, tái sử dụng mã nguồn và giảm chi phí bảo trì. Tuy nhiên, để áp dụng hiệu quả phương pháp này, lập trình viên cần có tư duy mô hình hóa tốt, nắm rõ nguyên lý thiết kế phần mềm và có khả năng tổ chức mã nguồn khoa học. Đây là lý do vì sao phương pháp hướng đối tượng được giảng dạy rộng rãi và trở thành nền tảng trong nhiều chương trình đào tạo công nghệ phần mềm.",
        "Summary": "Phát triển phần mềm hướng đối tượng là phương pháp tổ chức phần mềm theo các đối tượng mô phỏng thực tế, giúp tăng tính tái sử dụng và mở rộng hệ thống. Các đối tượng bao gồm dữ liệu và các phương thức xử lý, liên kết chặt chẽ với nhau. Phương pháp này giúp dễ bảo trì, dễ mở rộng và thích hợp với các hệ thống lớn, phức tạp. Hướng đối tượng thường đi kèm với các khái niệm như đóng gói, kế thừa và đa hình, tạo nên cấu trúc phần mềm linh hoạt, dễ thích ứng với thay đổi trong suốt vòng đời phát triển.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ thông điệp cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00049",
        "Article": "Thuật toán tìm kiếm tổng quát như vậy sinh ra một cây tìm kiếm, trong đó mỗi trạng thái tương ứng với một nút trên cây, mỗi nhánh tương ứng với một chuyển động tại nút đang xét. Trạng thái xuất phát tương ứng với gốc cây, những trạng thái được mở rộng tạo thành các nút thế hệ tiếp theo. Trên hình 2.4 là ví dụ một phần cây tìm kiếm sinh ra cho bài toán đố 8 ô. Sau đây là một số thuật ngữ sử dụng khi trình bày về thuật toán tìm kiếm: • Mở rộng nút là áp dụng các chuyển động lên trạng thái tương ứng để sinh ra các nút • Nút lá là các nút không có nút con tại thời điểm đang xét. • Các nút biên (còn gọi là nút mở): là tập các nút lá có thể mở rộng tiếp. • Tập các nút đã được mở rộng được gọi là tập các nút đóng, hay đơn giản là tập đóng. Hình 2.4. Cây tìm kiếm cho bài toán 8 ô Nguyên lý tìm kiếm vừa trình bầyđược thể hiện qua thuật toán tìm kiếm tổng quát trên hình 2.5. Thuật toán duy trì tập các nút biên O được khởi tạo bằng tập trạng thái xuất phát. Qua mỗi vòng lặp, thuật toán lấy ra một nút từ tập biện O, kiểm tra xem nút này có phải đích không. Nếu nút được lấy ra là đích, thuật toán trả về kết quả. Trong trường hợp ngược lại, nút này được mở rộng, tức là dùng hàm chuyển động để sinh ra các nút con. Các nút mới sinh ra lại được thêm vào tập O. Thuật toán kết thúc khi tìm thấy trạng thái đích hoặc khi O rỗng.",
        "Summary": "Sau đây là một số thuật ngữ sử dụng khi trình bày về thuật toán tìm kiếm Mở rộng nút là áp dụng các chuyển động lên trạng thái tương ứng để sinh ra các nút Nút lá là các nút không có nút con tại thời điểm đang xét.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt trích dẫn chính xác các định nghĩa về 'Mở rộng nút' và 'Nút lá' từ văn bản gốc. Không có thông tin nào bị thêm hoặc thay đổi."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liệt kê hai định nghĩa liên tiếp nhau, tạo ra một sự liên kết nhất định. Tuy nhiên, việc thiếu ngữ cảnh có thể làm giảm tính mạch lạc tổng thể. Cần thêm một câu dẫn nhập để tăng tính mạch lạc."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tập trung vào các định nghĩa, nhưng bỏ qua ý chính về thuật toán tìm kiếm tổng quát và cách nó sinh ra cây tìm kiếm. Điều này làm giảm tính liên quan của tóm tắt đến mục đích chính của văn bản gốc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt trung thực nhưng chưa đủ liên quan và mạch lạc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát và thêm một câu dẫn nhập để cải thiện tính mạch lạc. "
            }
        }
    },
    {
        "Index": "00050",
        "Article": "LẬP TRÌNH SOCKET Socket là một phương pháp để thiết lập kết nối truyền tin giữa một chương trình yêu cầu dịch vụ và một chương trình cung cấp dịch trên mạng và đôi khi trong máy tính. Theo định nghĩa các chức năng mỗi tầng trong mô hình OSI, tầng mạng đảm nhiệm liên kết giữa đầu cuối với đầu cuối thì tầng vận tải đảm nhiệm liên kết giữa hai tiến trình. Mỗi socket là một điểm cuối trong một kết nối và có thể được xem như kết hợp của tầng mạng và tầng vận tải, do đó nó phải bao gồm một cặp địa chỉ logic của tầng mạng và số hiệu cổng của tầng vận tải. Một socket trên máy yêu cầu dịch vụ có địa chỉ mạng được cấp sẵn để gọi một socket trên máy cung cấp dịch vụ. Một khi socket đã được thiết lập phù hợp, hai máy tính có thể trao đổi dịch vụ và dữ liệu. 5.1 Khái niệm về socket Khái niệm lập trình socket do trường đại học Berkeley để xuất vào những năm 1980, xuất hiện lần đầu tiên trong hệ điều hành Unix là Berkeley Sockets Interface, một chương trình thiết bị được thiết kế để giúp máy tính nối mạng có thể trao đổi thông tin với nhau. Giữa những năm 1990, Microsoft đã tạo riêng socket của họ là Windows Sockets (còn gọi là WinSock), nhờ vậy các ứng dụng Windows có thể trao đổi thông tin với nhau qua mạng máy tính. 5.1.1 Mô hình khách/chủ Mô hình khách/chủ cung cấp một cách tiếp cận tổng quát để chia sẻ tài nguyên trong các hệ thống phân tán, trong đó tiến trình cung cấp dịch vụ gọi là tiến trình chủ (server) và ngược lại tiến trình sử dụng dịch vụ gọi là tiến trình khách (client). Tài nguyên sẽ được quản lý bởi một tập các tiến trình gọi là các tiến trình server và mọi tiến trình client muốn thực hiện truy xuất tới tài nguyên thông qua tiến trình server đó. Bản thân các tiến trình server cũng cần phải truy xuất tới các tài nguyên dùng chung được quản lý bởi một tiến trình khác, vì vậy một số tiến trình có thể đóng cả hai vai trò client và server. Các tiến trình khách gửi yêu cầu tới tiến trình chủ, nếu yêu cầu hợp lệ thì tiến trình chủ sẽ thực hiện yêu cầu và trả về kết quả cho tiến trình trên máy khách.",
        "Summary": "Socket là phương pháp thiết lập kết nối truyền tin giữa chương trình yêu cầu và cung cấp dịch vụ trên mạng. Mỗi socket là một điểm cuối kết nối, bao gồm địa chỉ mạng và số hiệu cổng. Mô hình khách/chủ (client/server) là cách tiếp cận tổng quát để chia sẻ tài nguyên trong hệ thống phân tán, trong đó tiến trình chủ (server) cung cấp dịch vụ và tiến trình khách (client) sử dụng dịch vụ. Các tiến trình server quản lý tài nguyên và tiến trình client gửi yêu cầu đến server để truy xuất tài nguyên.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt trích dẫn chính xác các định nghĩa về 'Mở rộng nút' và 'Nút lá' từ văn bản gốc. Không có thông tin nào bị thêm hoặc thay đổi."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liệt kê hai định nghĩa liên tiếp nhau, tạo ra một sự liên kết nhất định. Tuy nhiên, việc thiếu ngữ cảnh có thể làm giảm tính mạch lạc tổng thể. Cần thêm một câu dẫn nhập để tăng tính mạch lạc."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tập trung vào các định nghĩa, nhưng bỏ qua ý chính về thuật toán tìm kiếm tổng quát và cách nó sinh ra cây tìm kiếm. Điều này làm giảm tính liên quan của tóm tắt đến mục đích chính của văn bản gốc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt trung thực nhưng chưa đủ liên quan và mạch lạc. Cần bổ sung thêm thông tin về thuật toán tìm kiếm tổng quát và thêm một câu dẫn nhập để cải thiện tính mạch lạc. "
            }
        }
    },
    {
        "Index": "00051",
        "Article": "Đơn vị mới thâm nhập thị trường Đổi mới kỹ thuật số đã giảm các rào cản chi phí, cho phép nhiều đơn vị mới tham gia. Những đơn vị mới tham gia thị trường không yêu cầu đầu tư vào các điểm truy cập vật lý như chi nhánh, máy ATM hoặc đại lý. Mặc dù sự kết hợp “phygital” giữa cơ sở hạ tầng kỹ thuật số và vật lý tiếp tục cần thiết để phục vụ khách hàng (ngay cả người dùng tài sản tiền điện tử cũng được cung cấp máy ATM bitcoin), khả năng tương tác ngày càng tăng và dễ dàng sắp xếp thuê ngoài được mô tả trước đó cho phép các nhà cung cấp không có mạng lưới vật lý hợp tác với những người khác để cung cấp các dịch vụ đó khi cần thiết. Mạng vật lý yêu cầu quy mô và mao dẫn, nhưng một vài mạng lưới đại lý, chi nhánh và ATM có thể phục vụ thị trường mà không cần mọi nhà cung cấp phải tạo và duy trì. Làn sóng đổi mới công nghệ tài chính hiện nay được đánh dấu bằng sự gia nhập của một bên là các công ty khởi nghiệp (công ty công nghệ tài chính) và mặt khác là các công ty công nghệ lớn (công ty công nghệ lớn). Những công ty thứ nhất thường có nguồn lực dồi dào nhờ lãi suất đầu tư mạo hiểm tích cực, nhưng không có lợi ích từ cơ sở khách hàng hiện tại và thường sử dụng các phương pháp tích cực để giành thị phần từ những công ty đương nhiệm trên các sản phẩm cụ thể. Loại thứ hai có lợi thế là có cơ sở khách hàng và dòng doanh thu hiện tại và có thể tận dụng những điều này để mở rộng quy mô nhanh chóng và tích hợp các dịch vụ tài chính vào các sản phẩm và dịch vụ hiện có của họ. Các loại đơn vị tham gia khác nhau có thể có những tác động rất khác nhau đối với cấu trúc thị trường và mang những tác động khác nhau đối với các chính sách điều tiết tài chính, cạnh tranh và bảo vệ người tiêu dùng. Các nhà cung cấp thích hợp có thể cung cấp các sản phẩm và dịch vụ phù hợp và tìm một cơ sở khách hàng quan tâm. Mặc dù họ vẫn phải phát triển danh tiếng đáng tin cậy, nhưng việc loại bỏ nhiều chi phí cố định và giảm chi phí biến đổi và chuyển đổi giúp nhà cung cấp chi phí thấp có thể tham gia thị trường từ quan điểm khả thi kinh tế. Tuy nhiên, rủi ro và các lực lượng kinh tế cứng đầu hơn chi phí. Rủi ro tín dụng, thanh khoản, thị trường và hoạt động có thể được giảm bớt hoặc chuyển giao, nhưng không được loại bỏ hoàn toàn. Quy mô tấn công của bọn tội phạm mạng đã trở nên lớn hơn, vì khả năng kết nối lẫn nhau và sự phân chia dịch vụ tạo ra nhiều liên kết hơn cho từng chuỗi sản phẩm và giao diện người dùng. Những người trả lời Khảo sát những người tham gia thị trường công nghệ tài chính đã được hỏi liệu họ mong muốn khách hàng bán lẻ và doanh nghiệp vừa và nhỏ có một mối quan hệ tài chính cốt lõi duy nhất hay sử dụng nhiều nhà cung cấp mà không có mối quan hệ cốt lõi nào. 36% số người được hỏi mong muốn khách hàng sử dụng nhiều nhà cung cấp mà không có mối quan hệ cốt lõi và 16% mong đợi rằng khách hàng sẽ có mối quan hệ cốt lõi với thị trường hoặc nhà cung cấp nền tảng.",
        "Summary": "Thị trường kỹ thuật số đã giảm rào cản gia nhập, cho phép nhiều đơn vị mới tham gia mà không cần đầu tư vào cơ sở hạ tầng vật lý. Các công ty khởi nghiệp công nghệ tài chính (Fintech) và các công ty công nghệ lớn (Big Tech) là những đối tượng tham gia chính, mang lại những tác động khác nhau đến cấu trúc thị trường. Fintech tận dụng vốn đầu tư mạo hiểm để cạnh tranh thị phần, trong khi Big Tech tận dụng cơ sở khách hàng hiện tại để mở rộng dịch vụ tài chính. Mặc dù chi phí giảm, rủi ro tín dụng, thanh khoản, thị trường và hoạt động vẫn tồn tại, đặc biệt là rủi ro từ tội phạm mạng. Phần lớn người tham gia thị trường dự đoán khách hàng sẽ sử dụng nhiều nhà cung cấp dịch vụ tài chính thay vì tập trung vào một mối quan hệ cốt lõi duy nhất.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00052",
        "Article": "3.1.2.2. Quy trình sử dụng chữ ký số để ký các thông điệp dữ liệu Để ký một chứng từ điện tử, người gửi sẽ sử dụng khóa bí mật và phần mềm ký điện tử để mã hóa chứng từ đó thành chữ ký số rồi gửi cho người nhận. Tuy nhiên, về nguyên tắc, để tạo điều kiện thuận lợi cho người nhận trong quá trình kiểm tra tính toàn vẹn của nội dung chứng từ và xác thực chữ ký, người gửi có thể gửi kèm theo thông điệp đã ký khóa công khai và chứng thư điện tử của mình hoặc địa chỉ để truy cập chứng thư điện tử của mình. Với khóa công khai và chứng thư điện tử, người nhận sẽ dễ dàng xác thực được chữ ký và nội dung thông điệp. H 2.6. Minh họa quy trình ký số và xác thực chữ ký số Quy trình tạo và chứng thực chữ ký số đem lại ba lợi thế cho chữ ký số: - Chữ ký số là duy nhất đối với từng văn bản được ký vì yếu tố đầu vào thứ nhất là bản thân chính văn bản đó; B1. Rút gọn văn bản cần ký bằng phần mềm rút gọn (hash function) B2. Tạo chữ ký số bằng khóa bí mật & văn bản đã rút gọn B3. Gửi văn bản gốc, chữ ký số, khóa công khai, chứng chỉ số cho người nhận B4. Giải mã chữ ký số của người gửi bằng khóa công khai được văn bản rút gọn 1 B5. Rút gọn văn bản gốc nhận được để có văn bản rút gọn 2 B6. So sánh hai văn bản rút gọn thu được để kiểm tra tính toàn vẹn của nội dung - Chữ ký số là duy nhất đối với chủ thể ký vì yếu tố đầu vào thứ hai là khóa bí mật gắn với chủ thể đó; - Trong trường hợp cần xác thực thông tin người đã ký có thể sử dụng chứng chỉ số và khóa công khai của cơ quan chứng thực để kiểm tra Quy trình thực hiện ký số cũng tạo điều kiện để xác thực chữ ký số dễ dàng hơn so với chữ ký tay trên giấy. Việc xác thực chữ ký được thực hiện căn cứ vào ba yếu tố đầu vào gồm: (i) văn bản được ký; (ii) chữ ký số và (iii) khóa công khai. Quy trình kiểm tra chữ ký số được phần mềm thực hiện và cho kết quả đúng và sai. Nếu đúng có nghĩa văn bản và chữ ký số là xác thực nếu sai có nghĩa một trong hai yếu tố xác thực đã bị thay đổi hoặc sai lệch. Việc tạo ra chữ ký số có thể do máy tính hoặc các thiết bị điện tử cầm tay thực hiện, các thiết bị này có thể truy cập đến khóa bí mật được lưu tại một vị trí bí mật trong hoặc ngoài thiết bị đó. Có nhiều loại chữ ký điện tử khác được sử dụng hỗ trợ chữ ký số như thẻ thông minh (smartcard), dấu hiệu sinh học (biometrics) và mật khẩu (passwords). Lợi ích nổi bật nhất của chữ ký số là giải quyết được việc ràng buộc trách nhiệm của các bên trong giao dịch điện tử. Thông thường, khi một bên xác nhận sự đồng ý với nội dung giao dịch thông qua việc kích chuột vào nút “I agree” hoặc “Confirm” trên website nếu xảy ra tranh chấp sẽ rất khó để xác minh hoặc tìm lại vị trí của các nút trên. Đồng thời cũng rất khó xác định xem đó có phải là nút “I agree” đã được sử dụng cho giao dịch hay không, đặc biệt khi các website luôn thay đổi về nội dung và hình thức. Trong các giao dịch điện tử với giá trị nhỏ được thực hiện tự động chữ ký số được gắn vào các hóa đơn điện tử sẽ ràng buộc trách nhiệm của người bán và tạo được sự tin tưởng của người mua tốt hơn.",
        "Summary": "Để ký một chứng từ điện tử, người gửi mã hóa chứng từ bằng khóa bí mật và phần mềm ký điện tử để tạo chữ ký số, sau đó gửi kèm khóa công khai và chứng thư điện tử cho người nhận để xác thực. Quy trình này đảm bảo tính duy nhất của chữ ký đối với văn bản và chủ thể ký, đồng thời tạo điều kiện xác thực dễ dàng hơn thông qua văn bản, chữ ký số và khóa công khai. Chữ ký số ràng buộc trách nhiệm của các bên trong giao dịch điện tử, đặc biệt quan trọng trong các giao dịch tự động và hóa đơn điện tử, tạo sự tin tưởng giữa người mua và người bán.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các ý chính được giữ nguyên và trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được sắp xếp hợp lý, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết thừa hoặc không cần thiết. Bản tóm tắt tập trung vào quy trình ký số, lợi ích và ứng dụng của nó trong giao dịch điện tử."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00053",
        "Article": "Mô hình quan hệ ra đời từ nhu cầu cấp thiết về một phương pháp quản lý dữ liệu hiệu quả hơn trong thời kỳ công nghệ thông tin phát triển mạnh mẽ. Trước thập niên 1970, dữ liệu chủ yếu được lưu trữ và xử lý qua hệ tập tin truyền thống, nơi mỗi ứng dụng phải tự định nghĩa cách tổ chức tệp, dẫn đến sự phụ thuộc chặt chẽ giữa phần mềm và phần cứng. Ví dụ, để quản lý sinh viên, một tệp có thể chứa tất cả thông tin như mã sinh viên, họ tên, điểm thi, nhưng nếu muốn thêm môn học mới, phải viết lại chương trình, gây tốn kém và dễ lỗi. Các mô hình sớm như phân cấp (Hierarchical Model) và mạng (Network Model) cải tiến bằng cách tổ chức dữ liệu theo cây hoặc đồ thị, nhưng vẫn phức tạp và thiếu linh hoạt khi truy vấn dữ liệu không theo cấu trúc cố định. Năm 1970, E.F. Codd, nhà khoa học tại IBM, giới thiệu mô hình quan hệ trong bài báo “A Relational Model of Data for Large Shared Data Banks”, đề xuất dùng bảng (table) để biểu diễn dữ liệu và các phép toán đại số để truy vấn. Ông nhấn mạnh tính độc lập dữ liệu, tách logic (cách người dùng nhìn bảng) khỏi vật lý (cách lưu trên đĩa), giúp thay đổi phần cứng mà không cần sửa ứng dụng. Ý nghĩa của mô hình quan hệ nằm ở sự đơn giản và mạnh mẽ: dữ liệu được chia thành các bảng như Sinh viên (MASV, HOTEN), Môn học (MAMH, TENMH), Kết quả (MASV, MAMH, DIEMTHI), liên kết qua khóa, giảm dư thừa và tăng hiệu quả. Ví dụ, thay vì lặp lại họ tên trong mọi dòng điểm thi, ta chỉ lưu một lần ở Sinh viên, dùng MASV để tham chiếu. Công trình của Codd đặt nền móng cho ngôn ngữ SQL và các hệ quản trị như Oracle, MySQL, thay đổi cách quản lý dữ liệu từ giáo dục, ngân hàng đến thương mại điện tử, trở thành tiêu chuẩn vàng trong ngành công nghệ thông tin hiện đại.",
        "Summary": "Mô hình quan hệ ra đời từ nhu cầu tổ chức dữ liệu một cách khoa học, dễ truy xuất và phù hợp với công nghệ máy tính hiện đại. Dữ liệu được biểu diễn dưới dạng bảng, mỗi bảng gồm các dòng (bản ghi) và cột (thuộc tính). Mô hình này hỗ trợ các phép toán đại số quan hệ và ngôn ngữ truy vấn SQL, cho phép xử lý dữ liệu hiệu quả. Sự đơn giản và rõ ràng của mô hình quan hệ khiến nó trở thành chuẩn mực trong nhiều hệ thống thông tin.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu văn liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào những ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ thông điệp quan trọng nhất của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng cô đọng thông tin một cách hiệu quả, giúp người đọc nhanh chóng nắm bắt được nội dung cốt lõi của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00054",
        "Article": "8.2. CÁC PHƯƠNG PHÁP ĐẶC TẢMÔ HÌNH Hình 8.1: Quy trình kiểm thửdựa trên mô hình [KJ02]. Định nghĩa 8.1. Máy trạng thái hữu hạn là một bộbốn (S, Act, T, q0), trong đó S là tập hữu hạn các trạng thái, T là tập các chuyển trạng thái, Act là các tập các sựkiện (còn có tên khác là bảng ký hiệu) và q0 là trạng Hình 8.2 mô tảmột ví dụvềmột máy hữu hạn trạng thái đặc tảhành vi của một hệthống chuyển công tắc đèn [KJ02]. Trong hình này, off là trạng thái khởi đầu của hệthống. Ởtrạng thái này, đèn đang bịtắt. Với đầu vào là turn on, hệthống sẽchuyển đến trạng thái normal với đèn có độsáng bình thường. Tại trạng thái này, chúng ta có thểtắt đèn (ứng với đầu vào turn off và hệthống sẽchuyển vềtrạng thái off ), tăng độsáng của đèn (ứng với đầu vào increase intensity và hệthống sẽchuyển vềtrạng thái bright) và giảm độsáng của đèn (ứng với đầu vào decrease intensity và hệthống sẽchuyển vềtrạng thái dim). Tại các trạng thái dim và bright, chúng ta có thểtắt đèn, tăng và giảm độsáng tương ứng. Bảng 8.1 là một dạng đặc tảkhác của máy hữu hạn trạng thái trên dưới dạng bảng chuyển. Chúng ta sẽdùng cấu trúc dữliệu này làm đầu vào cho các công cụkiểm thửtựđộng. Hình 8.2: Một ví dụvềmáy hữu hạn trạng thái. Bảng 8.1: Bảng chuyển của máy hữu hạn trạng thái trong hình 8.2 Ôtômat đơn định hữu hạn trạng thái Tương tựnhư FSM, ôtômat đơn định hữu hạn trạng thái (Deterministic Finite state Automaton - DFA) cũng rất hiệu quảtrong việc đặc tảhành vi dựa trên việc chuyển trạng thái của các hệthống. Một cách hình thức, DFA được định nghĩa như sau.",
        "Summary": "CÁC PHƯƠNG PHÁP ĐẶC TẢMÔ HÌNH Hình 8. 1 Quy trình kiểm thửdựa trên mô hình KJ02. Chúng ta sẽdùng cấu trúc dữliệu này làm đầu vào cho các công cụkiểm thửtựđộng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt trung thực, tuy nhiên, việc trích dẫn mỗi hai câu từ văn bản gốc mà không có sự liên kết rõ ràng có thể gây khó hiểu cho người đọc."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc. Hai câu trích dẫn không liên kết với nhau về mặt ý nghĩa, tạo cảm giác rời rạc và khó hiểu."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chỉ chọn lọc một vài chi tiết nhỏ từ văn bản gốc, bỏ qua các ý chính quan trọng như định nghĩa về máy trạng thái hữu hạn (FSM) và ôtômat đơn định hữu hạn trạng thái (DFA). Do đó, tính liên quan của bản tóm tắt rất thấp."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt hiện tại có chất lượng rất kém. Nó thiếu tính mạch lạc, tính liên quan và không truyền tải được thông tin chính của văn bản gốc. Cần cải thiện bằng cách xác định rõ các ý chính của văn bản gốc, tóm tắt chúng một cách ngắn gọn và liên kết các ý này một cách logic."
            }
        }
    },
    {
        "Index": "00055",
        "Article": "Đóng gói sản phẩm bao gồm các công việc sau: + Xây dựng tài liệu, gồm: • Tài liệu hướng dẫn sử dụng • Tài liệu kỹ thuật (tài liệu hướng dẫn cấu hình hệ thống) + Cài đặt với dữ liệu thực của khách hàng: • Cài đặt trên một hệ quản trị cơ sở dữ liệu cụ thể • Nhập dữ liệu thực tiễn để thực thi và đánh giá … + Đóng gói chương trình: Có các tiện tích để đóng gói chương trình thành các gói để dễ dàng cài đặt chương trình lên hệ thống như Install Anywhere, InstallShield… Thường thì các bước đóng gói sản phẩm phần mềm sẽ bao gồm: • Bước 1: Tổ chức các thư mục • Bước 2: Tổ chức các thành phần cho người dùng chọn khi cài đặt. • Bước 3: Liệt kê danh sách các tập tin DLL cần dùng • Bước 4: Liệt kê danh sách các tập tin OCX cần dùng • Bước 5: Liệt kê danh sách các Dabatase Drivers cần cài đặt • Bước 6: Liệt kê danh sách các Printer Drivers • Bước 7: Liệt kê danh sách các FONT cần cài đặt • Bước 8: Soạn thảo các tập tin : Readme, INI • Bước 9: Liệt kê danh sách các Utilities Software cài thêm • Bước 10: Liệt kê danh sách các logo, hình ảnh giới thiệu trong quá trình cài đặt. • Bước 11: Tạo file Script • Bước 12: Tạo License Key • Bước 13: Tạo Demo cho sản phẩm • Bước 14: Tạo File Help • Bước 15 : Thực hiện đóng gói. • Bước 16 : Viết tài liệu đóng gói. Các thành phần cơ bản trong bản đóng gói • Thông tin về sản phẩm (Add/Remove program) • Tổ chức thư mục lưu trữ (Program Files,…) • Components: DLL và ActiveX Control (OCX) • Shortcut • Database file DB Script file DB Sample • Registry • INI file • Web server (IIS) • Windows Service • Tài liệu hướng dẫn (User guide, Admin guide,…) • Bản cài đặt (Setup.exe…)",
        "Summary": "\"Đóng gói sản phẩm bao gồm xây dựng tài liệu hướng dẫn sử dụng và kỹ thuật, cài đặt với dữ liệu thực của khách hàng, và đóng gói chương trình bằng các tiện ích như Install Anywhere, InstallShield. Quá trình đóng gói thường bao gồm tổ chức thư mục, chọn thành phần cài đặt, liệt kê các tập tin DLL, OCX, Database Drivers, Printer Drivers, FONT cần thiết, soạn thảo Readme, INI, liệt kê Utilities Software, logo, tạo file Script, License Key, Demo, File Help, thực hiện đóng gói và viết tài liệu. Bản đóng gói cơ bản chứa thông tin sản phẩm, tổ chức thư mục, các components (DLL, OCX), shortcut, database file, DB script, registry, INI file, web server, Windows Service, tài liệu hướng dẫn và bản cài đặt (Setup.exe).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các ý được trình bày theo một trình tự nhất định, tuy nhiên, việc liệt kê quá nhiều thành phần trong một câu có thể làm giảm tính trôi chảy và gây khó khăn cho người đọc trong việc nắm bắt thông tin một cách nhanh chóng. Ví dụ, câu 'Quá trình đóng gói thường bao gồm tổ chức thư mục, chọn thành phần cài đặt, liệt kê các tập tin DLL, OCX, Database Drivers, Printer Drivers, FONT cần thiết, soạn thảo Readme, INI, liệt kê Utilities Software, logo, tạo file Script, License Key, Demo, File Help, thực hiện đóng gói và viết tài liệu' có thể được chia thành nhiều câu nhỏ để tăng tính mạch lạc."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt có tính liên quan cao, tập trung vào các ý chính của văn bản gốc về quy trình và các thành phần của việc đóng gói sản phẩm. Tuy nhiên, có một số chi tiết nhỏ có thể được lược bỏ để bản tóm tắt trở nên súc tích hơn, ví dụ như việc liệt kê quá chi tiết các loại file (DLL, OCX, Database Drivers, Printer Drivers, FONT)."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và liên quan. Tuy nhiên, để cải thiện hơn nữa, nên tập trung vào việc tăng tính mạch lạc bằng cách chia các câu dài thành các câu ngắn hơn và lược bỏ một số chi tiết không quá quan trọng để bản tóm tắt trở nên súc tích và dễ đọc hơn."
            }
        }
    },
    {
        "Index": "00056",
        "Article": "Trong trường hợp thư mục có chứa thư mục mức dưới hoặc file, việc xoá thư mục sẽ ảnh hưởng tới các thư mục mức dưới và file đó. Nói chung có hai cách giải quyết trong trường hợp này. Một số hệ điều hành như MS-DOS không cho phép xoá thư mục khi thư mục không rỗng. Người dùng phải xoá hết các file và thư mục mức dưới của một thư mục trước khi xoá thư mục đó. Ngược lại, một số hệ điều hành như UNIX, Linux cho phép xoá các thư mục không rỗng. Khi một thư mục bị xoá (bằng lệnh rm), tất cả các các file và thư mục mức dưới chứa trong đó cũng bị xoá theo. Cách này rất tiện lợi, cho phép tiết kiệm thời gian và công sức khi cần xoá số lượng thư mục. Tuy nhiên việc cho phép xoá thư mục không rỗng có thể gây mất mát nhiều file và thư mục con do một lệnh xoá vô ý có thể xoá cả một nhánh lớn của cây thư mục. Người dùng phải hết sức cẩn thận khi sử dụng nhãng lệnh xoá như vậy. Tại mỗi thời điểm, người dùng làm việc với một thư mục gọi là thư mục hiện thời hay thư mục làm việc. Trong quá trình làm việc, người dùng có thể di chuyển sang thư mục khác tức là thay đổi thư mục hiện thời. Việc thay đổi thư mục được thực hiện bằng lời gọi hệ thống tương ứng. Nếu người dùng gõ lệnh đổi thư mục từ bộ dịch lệnh (shell) thì bộ dịch lệnh sẽ gọi lời gọi hệ thống này. Trong trường hợp người dùng truy cập một file mà không thông báo cụ thể thư mục chứa file đó thì file được tìm kiếm trước tiên trong thư mục hiện thời sau đó mở rộng sang các thư mục được quy định trong đường tìm kiếm (search path) như mô tả trong phần thư mục hai mức.",
        "Summary": "Khi xoá thư mục có chứa thư mục con hoặc file, có hai cách giải quyết: một số hệ điều hành như MS-DOS yêu cầu người dùng phải xoá hết các file và thư mục con trước khi xoá thư mục, trong khi UNIX và Linux cho phép xoá thư mục không rỗng và tự động xoá tất cả các thư mục và file bên trong. Tuy nhiên, cách sau có thể gây mất mát dữ liệu nếu lệnh xoá không được sử dụng cẩn thận. Người dùng có thể thay đổi thư mục hiện thời trong quá trình làm việc, và nếu không chỉ định rõ thư mục chứa file, hệ thống sẽ tìm kiếm file trong thư mục hiện thời và các thư mục theo đường tìm kiếm.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các phương pháp xóa thư mục và cách hệ thống tìm kiếm file."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Các ý chính được trình bày rõ ràng và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00057",
        "Article": "Các tham số và giá trị trả về được sử dụng đắc lực nhất trong các phương thức có nhiệm vụ truy nhập dữ liệu của đối tượng. Có hai loại phương thức truy nhập: • Các phương thức đọc dữ liệu của đối tượng và trả về dữ liệu đọc được. Chúng thường được đặt tên là getDữLiệuGìĐó, nên còn được gọi là các phương thức get. • Các phương thức ghi dữ liệu vào các biến thực thể của đối tượng, chúng nhận dữ liệu mới qua các tham số rồi ghi vào các biến liên quan. Chúng thường được đặt tên là setDữLiệuGìĐó, nên còn được gọi là các phương thức set. Ví dụ như trong Hình 5.6 class Cow à Cow String name; int age; name age void setName(String aName) à getName() name = aName; setName() â getAge() String getName() à setAge() return name; â void setAge(int anAge) à age = anAge; â int getAge() à return age; â â Hình 5.6: Lớp Cow với các hàm đọc/ghi Cho đến nay, ta đã lờ đi một trong những nguyên tắc quan trọng nhất của lập trình hướng đối tượng, đó là đóng gói và che giấu thông tin. Nguyên tắc này nói rằng \"Đừng để lộ cấu trúc dữ liệu bên trong\". Trong tất cả các ví dụ từ đầu cuốn sách đến giờ, ta đã để lộ tất cả dữ liệu. 'Để lộ' ở đây có nghĩa là từ bên ngoài lớp có thể dùng một tham chiếu tới đối tượng kèm theo toán tử dấu chấm (.) để truy nhập biến thực thể của đối tượng đó. Ví dụ: theCow.age = 2; Nói cách khác là ta đang cho phép dùng tham chiếu để trực tiếp sửa biến thực thể của đối tượng. Đây là công cụ nguy hiểm nếu đặt trong tay những ai muốn phá hoại hoặc không biết dùng đúng cách. Nó cho phép người ta làm những việc chẳng hạn như cho một đối tượng Cow có tuổi là số âm: 75 theCow.age = -2; Để ngăn chặn nguy cơ này, ta cần cài các phương thức set cho các biến thực thể và tìm cách buộc các đoạn mã khác phải gọi các phương thức set thay vì truy nhập trực tiếp đến dữ liệu. Khi đã đảm bảo được rằng gọi một phương thức set là cách duy nhất để sửa một biến thực thể, ta có thể kiểm tra tính hợp lệ của dữ liệu mới và bảo vệ không cho phép bất cứ ai gán một giá trị không hợp lệ cho biến thực thể đó.",
        "Summary": "Văn bản mô tả cách sử dụng phương thức `get` và `set` trong lập trình hướng đối tượng để truy cập và thao tác dữ liệu của đối tượng, nhấn mạnh tầm quan trọng của đóng gói và che giấu thông tin. Các phương thức `get` trả về giá trị của biến thực thể, trong khi `set` cập nhật giá trị này, cho phép kiểm soát và xác thực dữ liệu trước khi ghi. Việc truy cập trực tiếp vào biến thực thể bị coi là nguy hiểm vì có thể dẫn đến việc gán giá trị không hợp lệ. Do đó, sử dụng phương thức `set` là cách thức an toàn và hiệu quả để bảo vệ tính toàn vẹn dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Nội dung dễ hiểu và không gây khó khăn cho người đọc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào mục đích sử dụng của phương thức get/set và tầm quan trọng của việc đóng gói thông tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Tóm tắt đã làm nổi bật được các ý chính và trình bày chúng một cách rõ ràng, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00058",
        "Article": "Cấu trúc bề mặt đĩa : z Ổ đĩa cứng gồm nhiều đĩa quay với vận tốc 5400 đến 7200vòng / phút , trên các bề mặt đĩa là các đầu từ di chuyển để đọc và ghi dữ liệu. https://thuviensach.vn Các đĩa ghi dữ liệu và đầu từ ghi - đọc z Dữ liệu được ghi trên các đường tròn đồng tâm gọi là Track hoặc Cylinder, mỗi Track lại chia thành nhiều cung - gọi là Sector và mỗi cung ghi được 512 Byte dữ liệu . + Track và Sector có được là do các nhà sản xuất đĩa cứng sử dụng một chương trình đặc biệt để định dạng vật lý hay định dạng cấp thấp cho đĩa. Bề mặt của đĩa cứng, tín hiệu ghi trên các đường tròn đồng tâm gọi là Track, mỗi Track được chia làm nhiều Sector z Với đĩa cứng khoảng 10G => có khoảng gần 7000 đường Track trên mỗi bề mặt đĩa và mỗi Track được chia thành khoảng 200 Sector . z Để tăng dung lượng của đĩa thì trong các đĩa cứng ngày nay, các Track ở ngoài được chia thành nhiều Sector hơn và mỗi mặt đĩa cũng được chia thành nhiều Track hơn và như vậy đòi hỏi thiết bị phải có độ chính xác rất cao . 4. Nguyên tắc lưu trữ từ trên đĩa cứng https://thuviensach.vn z Trên bề mặt đĩa người ta phủ một lớp mỏng chất có từ tính, ban đầu các hạt từ tính không có hướng , khi chúng bị ảnh hưởng bởi từ trường của đầu từ lướt qua , các hạt có từ tính được sắp xếp thành các hạt có hướng. z Đầu từ ghi - đọc được cấu tạo bởi một lõi thép nhỏ hình chữ U, một cuộn dây quấn trên lõi thép để đưa dòng điện vào (khi ghi) hay lấy ra (khi đọc), khe hở gọi là khe từ lướt trên bề mặt đĩa với khoảng cách rất gần, bằng 1/10 sợi tóc . Đầu từ ghi - đọc và lớp từ tính trên đĩa z Trong quá trình ghi, tín hiệu điện ở dạng tín hiệu số 0,1 được đưa vào đầu từ ghi lên bề mặt đĩa thành các nam châm rất nhỏ và đảo chiều tuỳ theo tín hiệu đưa vào là 0 hay 1 . z Trong quá trình phát, đầu từ đọc lướt qua bề mặt đĩa dọc theo các đường Track đã được ghi tín hiệu, tại điểm giao nhau của các nam châm có từ trường biến đổi và cảm ứng lên cuộn dây tạo thành một xung điện, xung điện này rất yếu được đưa vào khuếch đại để lấy ra tín hiệu 0,1 ban đầu . Ghi chú : Tín hiệu 0 , 1 là tín hiệu số ( Digital ) - Xem phần Tín hiệu số . Chú ý : z Đĩa cứng được ghi theo nguyên tắc cảm ứng từ , vì vậy nếu ta để các đĩa cứng gần các vật có từ tính mạnh như Nam châm thì có thể dữ liệu trong đĩa cứng sẽ bị hỏng !",
        "Summary": "\"Đĩa cứng gồm nhiều đĩa quay tốc độ cao, dữ liệu được ghi trên các đường tròn đồng tâm (Track/Cylinder) chia thành các cung (Sector), mỗi Sector chứa 512 Byte. Các Track ở ngoài có thể được chia thành nhiều Sector hơn để tăng dung lượng. Dữ liệu được lưu trữ bằng cách từ hóa lớp vật liệu từ tính trên đĩa thông qua đầu từ, tạo ra các nam châm nhỏ biểu diễn bit 0 và 1. Khi đọc, đầu từ cảm nhận sự thay đổi từ trường và tạo ra xung điện để khôi phục dữ liệu ban đầu. Đĩa cứng nhạy cảm với từ trường mạnh bên ngoài, có thể gây mất dữ liệu.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, giúp người đọc dễ dàng nắm bắt thông tin. Các câu liên kết với nhau một cách trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào cấu trúc, nguyên tắc lưu trữ và tính nhạy cảm của đĩa cứng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00059",
        "Article": "Một cách phòng ngừa deadlock là sử dụng thứ tự ưu tiên và cuộn lại quá trình. Với thứ tự ưu tiên, một giao dịch T2 yêu cầu một khóa bị giữ bởi giao dịch T1 , khóa đã cấp cho T1 có thể bị lấy lại và cấp cho T2 , T1 bị cuộn lại. Để điều khiển ưu tiên, ta gán một nhãn thời gian duy nhất cho mỗi giao dịch. Hệ thống sử dụng các nhãn thời gian này để quyết định một giao dịch phải chờ hay cuộn lại. Khóa vẫn được sử dụng để điều khiển tương tranh. Nếu một giao dịch bị cuộn lại, nó vẫn giữ nhãn thời gian cũ của nó khi tái khởi động. Hai sơ đồ phòng ngừa deadlock sử dụng nhãn thời gian khác nhau được đề nghị: \n 1. Sơ đồ Wait-Die dựa trên kỹ thuật không ưu tiên. Khi giao dịch Ti yêu cầu một mục dữ liệu bị chiếm bởi Tj , Ti được phép chờ chỉ nếu nó có nhãn thời gian nhỏ hơn của Tj nếu không Ti bị cuộn lại (die). \n 2. Sơ đồ Wound-Wait dựa trên kỹ thuật ưu tiên. Khi giao dịch Ti yêu cầu một mục dữ liệu hiện đang bị giữ bởi Tj , Ti được phép chờ chỉ nếu nó có nhãn thời gian lớn hơn của Tj , nếu không Tj bị cuộn lại (Wounded). \n Một điều quan trọng là phải đảm bảo rằng, mỗi khi giao dịch bị cuộn lại, nó không bị “chết đói” (starvation) có nghĩa là nó sẽ không bị cuộn lại lần nữa và được phép tiến triển. \n Cả hai sơ đồ Wound-Wait và Wait-Die đều tránh được sự chết đói: tại một thời điểm, có một giao dịch với nhãn thời gian nhỏ nhất. Giao dịch này không thể bị yêu cầu cuộn lại trong cả hai sơ đồ. Do nhãn thời gian luôn tăng và do các giao dịch không được gán nhãn thời gian mới khi chúng bị cuộn lại, một giao dịch bị cuộn lại sẽ có nhãn thời gian nhỏ nhất (vào thời gian sau) và sẽ không bị cuộn lại lần nữa. \n Tuy nhiên, có những khác nhau lớn trong cách thức hoạt động của hai sơ đồ: \n • Trong sơ đồ Wait-Die, một giao dịch già hơn phải chờ một giao dịch trẻ hơn giải phóng mục dữ liệu. Như vậy, giao dịch già hơn có xu hướng bị chờ nhiều hơn. Ngược lại, trong sơ đồ Wound-Wait, một giao dịch già hơn không bao giờ phải chờ một giao dịch trẻ hơn. \n • Trong sơ đồ Wait-Die, nếu một giao dịch Ti chết và bị cuộn lại vì nó đòi hỏi một mục dữ liệu bị giữ bởi giao dịch Tj , khi đó Ti có thể phải tái phát ra cùng dãy các yêu cầu khi nó khởi động lại. Nếu mục dữ liệu vẫn bị chiếm bởi Tj , Ti bị chết lần nữa. Như vậy, Ti có thể bị chết vài lần trước khi nhận được mục dữ liệu cần thiết. Trong sơ đồ Wound-Wait, giao dịch Ti bị thương và bị cuộn lại do Tj yêu cầu mục dữ liệu nó chiếm giữ. Khi Ti khởi động lại, và yêu cầu mục dữ liệu, bây giờ, đang bị Tj giữ, Ti chờ. Như vậy, có ít cuộn lại hơn trong sơ đồ Wound-Wait. \n Một vấn đề nổi trội đối với cả hai sơ đồ là có những cuộn lại không cần thiết vẫn xảy ra.",
        "Summary": "Để phòng ngừa deadlock, một phương pháp là sử dụng thứ tự ưu tiên dựa trên nhãn thời gian duy nhất cho mỗi giao dịch. Hệ thống sử dụng nhãn thời gian này để quyết định giao dịch nào phải chờ hoặc cuộn lại. Có hai sơ đồ chính: Wait-Die (giao dịch trẻ hơn chờ giao dịch già hơn, ngược lại thì cuộn lại) và Wound-Wait (giao dịch già hơn chờ giao dịch trẻ hơn, ngược lại thì cuộn lại). Cả hai sơ đồ đều tránh \"chết đói\" vì giao dịch có nhãn thời gian nhỏ nhất sẽ không bị cuộn lại. Tuy nhiên, Wait-Die khiến giao dịch già hơn chờ nhiều hơn, và có thể bị \"chết\" nhiều lần trước khi nhận được mục dữ liệu. Wound-Wait ít cuộn lại hơn nhưng cả hai sơ đồ đều có thể gây ra cuộn lại không cần thiết.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt được trình bày một cách mạch lạc và logic. Các ý được liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin dễ hiểu. Cách diễn đạt rõ ràng, không gây khó khăn cho người đọc trong việc nắm bắt nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Chỉ những ý chính và quan trọng nhất được giữ lại, trong khi các chi tiết không cần thiết đã được loại bỏ. Bản tóm tắt tập trung vào các khái niệm cốt lõi và so sánh giữa hai sơ đồ phòng ngừa deadlock."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Điểm mạnh của bản tóm tắt là khả năng cô đọng thông tin một cách hiệu quả, đồng thời vẫn giữ được ý nghĩa chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00060",
        "Article": "Bài tập cơ bản Biến, biểu thức và toán tử Bài 1: Chuỗi ký tự nào sau đây không thể là tên biến được? BASICSALARY _basic basic-hra #MEAN group. 422 population in 2006 over time mindovermatter FLOAT hELLO queue. team’svictory Plot # 3 2015_DDay nhiệt van_toc lai suat Bài 2: Chỉ ra biểu thức C/C++ lỗi (nếu có) a) int = 314.562 * 150; b) name = 'Ajay'; c) varchar = '3'; d) 3.14 * r * r * h = vol_of_cyl; e) k = ( a * b ) ( c + ( 2.5a + b ) ( d + e ); f) m_inst = rate of interest * amount in rs; g) si = principal * rateofinterest * numberofyears / 100; h) area = 3.14 * r ** 2; i) volume = 3.14 * r ^ 2 * h; j) k = ( (a * b ) + c ) ( 2.5 * a + b ); k) a = b = 3 = 4; l) count = count + 1; m) date = '2 Mar 04'; Bài 3: Xác định thứ tự thực hiện các phép toán và tính giá trị của biểu thức 27 Chương 3 KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN a) g = big / 2 + big * 4 / big - big + abc / 3; (abc = 2.5, big = 2, giả sử g có kiểu float) b) on = ink * act / 2 + 3 / 2 * act + 2 + tig;(ink = 4,act = 1,tig = 3.2, giả sử on có kiểu int) c) s = qui * add / 4 - 6 / 2 + 2 / 3 * 6 / god;(qui = 4,add = 2,god = 2, giả sử s có kiểu int) d) s = 1 / 3 * a / 4 - 6 / 2 + 2 / 3 * 6 / g; (a = 4, g = 3, giả sử s có kiểu int) Bài 4: Xác định toán hạng cho các phép toán trong biểu thức a) g = 10 / 5 / 2 / 1; b) b = 3 / 2 + 5 * 4 / 3; c) a = b = c = 3 + 4;",
        "Summary": "Bài tập bao gồm các vấn đề về đặt tên biến trong C/C++, xác định lỗi cú pháp trong các biểu thức, tính toán giá trị biểu thức theo thứ tự ưu tiên toán tử và xác định toán hạng. Bài 1 kiểm tra hiểu biết về quy tắc đặt tên biến hợp lệ. Bài 2 tập trung vào việc nhận biết lỗi cú pháp trong các biểu thức C/C++. Bài 3 và 4 yêu cầu tính toán giá trị của các biểu thức số học, bao gồm cả việc áp dụng quy tắc ưu tiên toán tử và hiểu rõ về kiểu dữ liệu số nguyên và số thực.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, giúp người đọc dễ dàng nắm bắt được nội dung chính của bài tập."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của bài tập, bao gồm các vấn đề về tên biến, lỗi cú pháp, tính toán biểu thức và xác định toán hạng, mà không đi vào các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về nội dung của bài tập. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00061",
        "Article": "Hình 4.14. Ví dụ minh hoạ cách loại trừ biến cho trường hợp đơn giản. b) Thuật toán loại trừ biến Ví dụ trên cho thấy nguyên tắc cơ bản của phương pháp loại trừ biến trên một mạng Bayes đơn giản. Ý tưởng là tính toán sẵn và lưu các thành phần lặp lại, sau đó sử dụng các giá trị đã lưu để tiết kiệm số phép tính cần thực hiện theo nguyên tắc quy hoạch động. Tiếp theo, ta sẽ xem xét thuật toán loại trừ biến cho trường hợp tổng quát. Để trình bầy thuật toán, trước hết cần biết khái niệm thừa số và thừa số hoá. Thừa số hoá một phân phối xác suất đồng thời là phân tích xác suất đó thành các thành phần, mỗi thành phần phụ thuộc vào một hoặc một số biến ngẫu nhiên, sao cho tích các thành phần đó là giá trị xác suất đồng thời. Có nhiều cách để thừa số hoá một phân bố xác suất. Như trong ví dụ ở trên, một trong các cách thừa số hoá cho ta các thành phần sau F = {P(A), P(B | A), P(C | B), P(D |C)} Mỗi thành phần sau khi thừa số hoá gọi là một thừa số. Như trong ví dụ trên, ta có P(A), P(B | A) ... P(D | C) là các thừa số. Lưu ý rằng, mỗi thừa số là hàm của một số biến ngẫu nhiên, chẳng hạn P(A) là hàm phụ thuộc vào A, P(D | C) là hàm và phụ thuộc vào D, C. Giá trị của mỗi thừa số là một ma trận, chẳng hạn nếu các biến là nhị phân thì P(A) là ma trận kích thước 2x1, trong khi P(D | C) là ma trận kích thước 2x2 do mỗi biến D và C có thể nhận 2 giá Thuật toán loại trừ biến được thực hiện bằng cách loại trừ dần các biến khỏi biểu thức tính phân bố xác suất đồng thời (từ đây mà có tên gọi của phương pháp là “loại trừ biến”). Việc loại trừ một biến khỏi biểu thức tính xác suất đồng thời được thực hiện bằng cách loại trừ các thừa số chứa biến đó khỏi biểu thức như đã thấy trong ví dụ ở phần trên. Lưu ý rằng, (a)1 1 0 1 0 1 0 0 0 1 1 0 sau khi loại từ một biến, ta được một danh sách các thừa số khác sao cho tích các thừa số đó bằng giá trị xác suất đồng thời nhưng chứa ít biến ngẫu nhiên hơn.",
        "Summary": "b Thuật toán loại trừ biến Ví dụ trên cho thấy nguyên tắc cơ bản của phương pháp loại trừ biến trên một mạng Bayes đơn giản. Giá trị của mỗi thừa số là một ma trận, chẳng hạn nếu các biến là nhị phân thì PA là ma trận kích thước 2x1, trong khi PD C là ma trận kích thước 2x2 do mỗi biến D và C có thể nhận 2 giá Thuật toán loại trừ biến được thực hiện bằng cách loại trừ dần các biến khỏi biểu thức tính phân bố xác suất đồng thời từ đây mà có tên gọi của phương pháp là loại trừ biến.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu có liên kết với nhau, tuy nhiên, việc trích dẫn các câu từ văn bản gốc một cách rời rạc khiến cho tính mạch lạc chưa được tối ưu. Cần có sự chỉnh sửa để các câu văn liên kết chặt chẽ hơn."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính liên quan đến thuật toán loại trừ biến. Tuy nhiên, một vài chi tiết như kích thước ma trận có thể được lược bỏ để tăng tính cô đọng cho bản tóm tắt."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, đảm bảo tính trung thực và liên quan. Tuy nhiên, cần cải thiện tính mạch lạc bằng cách diễn đạt lại các ý chính thay vì chỉ trích dẫn nguyên văn. Ngoài ra, nên lược bỏ một số chi tiết không quá quan trọng để bản tóm tắt ngắn gọn và tập trung hơn."
            }
        }
    },
    {
        "Index": "00062",
        "Article": "Chiều dài gói dữ liệu (datagram length): đây là tổng độ dài tính theo byte của gói dữ liệu IP kể cả phần tiêu đề lẫn phần dữ liệu. Độ dài trường này là 16 bit nên về lý thuyết kích thước tối đa của gói dữ liệu IP là 65.535 byte. Tuy nhiên, hiếm khi kích thước gói dữ liệu vượt quá 1500 bytes và thường giới hạn là 576 bytes. - Định danh, cờ và vị trí phân đoạn (Identifer, Flags, Fragmention Offset): 3 trường này được sử dụng khi phân mảnh gói dữ liệu IP, phiên bản mới IPv6 không cho phép phân mảnh gói dữ liệu tại các thiết bị định tuyến. - Thời gian sống (Time-To-live-TTL): Trường thời gian tồn tại TTL được sử dụng để bảo đảm gói dữ liệu không được lưu chuyển mãi mãi để tránh trường hợp một gói tin có thể lặp theo vòng trong mạng. Mỗi lần gói tin đi qua một Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 148 thiết bị định tuyến sẽ bị giảm đi một (- 1), nếu trường TTL bằng 0 thì thiết bị định tuyến sẽ loại bỏ gói tin. - Giao thức tầng trên (Upper Protocol): Trường này chỉ được sử dụng khi gói dữ liệu IP đến được máy tính đích, giá trị của trường này xác định giao thức tầng vận tải ở máy tính đích sẽ nhận được phần dữ liệu trong gói dữ liệu IP. Ví dụ giá trị 6 có ý nghĩa phần dữ liệu cần chuyển tới thực thể TCP, giá trị 17 có ý nghĩa phần dữ liệu phải chuyển đến thực thể UDP, RFC 1700 liệt kê các giá trị này. Vai trò của trường giao thức trong gói dữ liệu IP tương tự vai trò trường số hiệu cổng trong đoạn tin của tầng vận tải. Trường giao thức được xem là điểm nối giữa tầng mạng và tầng vận tải cũng như trường số hiệu cổng là điểm nối giữa tầng vận tải với ứng dụng cụ thể.",
        "Summary": "\"Gói dữ liệu IP bao gồm các trường quan trọng sau: **Chiều dài gói dữ liệu** (tối đa 65.535 byte, thường dưới 1500 byte); **Định danh, cờ và vị trí phân đoạn** (dùng khi phân mảnh, không còn được dùng trong IPv6); **Thời gian sống - TTL** (giảm mỗi khi qua router, tránh lặp vô hạn); **Giao thức tầng trên** (xác định giao thức tầng vận tải đích nhận dữ liệu, tương tự vai trò số hiệu cổng).\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và logic, có sự liên kết chặt chẽ giữa các phần. Cách diễn đạt dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các trường quan trọng trong gói dữ liệu IP và chức năng của chúng."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan. Đã làm nổi bật được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm cần cải thiện."
            }
        }
    },
    {
        "Index": "00063",
        "Article": "Bài tập 1.1: Nêu các đặc điểm của ngôn ngữ lập trình Java?Java là một ngôn ngữ lập trình hướng đối tượng, được phát triển bởi Sun Microsystems (nay thuộc Oracle). Một số đặc điểm nổi bật của Java bao gồm:Độc lập nền tảng: Java biên dịch mã nguồn thành bytecode, chạy trên mọi hệ điều hành có Java Virtual Machine (JVM).Hướng đối tượng: Java hỗ trợ lập trình theo mô hình đối tượng (OOP), giúp quản lý và tái sử dụng mã hiệu quả hơn.Bảo mật cao: Nhờ kiến trúc bảo vệ bằng JVM, Java cung cấp môi trường an toàn cho chạy các chương trình, đặc biệt là các ứng dụng mạng.Tự động quản lý bộ nhớ: Java có cơ chế Garbage Collector giúp giải phóng bộ nhớ không còn được sử dụng.Thư viện phong phú: Java cung cấp nhiều thư viện dựng sẵn phục vụ cho các tác vụ phổ biến như xử lý chuỗi, mạng, cơ sở dữ liệu, GUI, v.v.Bài tập 1.2: Nêu vai trò của cấu trúc dữ liệu và giải thuật?Cấu trúc dữ liệu và giải thuật đóng vai trò then chốt trong lập trình và phát triển phần mềm.Cấu trúc dữ liệu giúp tổ chức và lưu trữ dữ liệu một cách hiệu quả, đảm bảo truy xuất và xử lý dữ liệu nhanh chóng. Ví dụ như mảng, danh sách liên kết, ngăn xếp (stack), hàng đợi (queue), cây (tree), đồ thị (graph), v.v.Giải thuật là tập hợp các bước rõ ràng để giải quyết một bài toán cụ thể. Việc lựa chọn giải thuật phù hợp giúp cải thiện hiệu suất chương trình. Các giải thuật như sắp xếp, tìm kiếm, duyệt đồ thị, quy hoạch động… là nền tảng cho nhiều ứng dụng phức tạp.Bài tập 1.3: Vẽ lưu đồ thuật toán nhập vào số nguyên n, xuất ra màn hình từ 1 đến n.Phân tích:Nhập số nguyên nKhởi tạo biến đếm i = 1Lặp: nếu i <= n thì in i, tăng i lên 1 và lặp lạiKết thúc khi i > nBài tập 1.4: Vẽ lưu đồ thuật toán giải phương trình bậc 2?Phân tích:Nhập a, b, cNếu a == 0, chuyển về phương trình bậc nhất bx + c = 0Nếu a ≠ 0:• Tính Δ = b² - 4ac• Nếu Δ < 0 → vô nghiệm• Nếu Δ = 0 → nghiệm kép x = -b/2a• Nếu Δ > 0 → hai nghiệm phân biệt x1, x2Xuất nghiệmBài tập 1.5: Vẽ lưu đồ thuật toán tính tổng:Phân tích:Nhập vào một số nguyên nKhởi tạo tong = 0, i = 1Lặp: cộng i vào tong, tăng i lên 1Khi i > n thì dừngIn ra tổng",
        "Summary": "Bài viết trình bày các đặc điểm chính của Java: hướng đối tượng, độc lập nền tảng nhờ JVM, bảo mật cao, tự động quản lý bộ nhớ và thư viện phong phú. Ngoài ra, bài viết nhấn mạnh vai trò quan trọng của cấu trúc dữ liệu (mảng, danh sách liên kết, cây, đồ thị,...) và giải thuật (sắp xếp, tìm kiếm,...) trong lập trình. Cuối cùng, bài viết đề cập đến việc thiết kế lưu đồ thuật toán cho các bài toán cơ bản như in số từ 1 đến n, giải phương trình bậc hai và tính tổng dãy số.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các đặc điểm của Java, vai trò của cấu trúc dữ liệu và giải thuật, cũng như việc thiết kế lưu đồ thuật toán, đúng như nội dung chính của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00064",
        "Article": "Hướng dẫn cách đăng ký domain Khi bạn muốn đăng ký domain là bạn sẽ đăng ký tên miền bạn muốn sử dụng với một tổ chức được gọi là InterNIC thông qua một nhà đại lý thường được gọi là Registrar. Ví dụ bạn muốn trang web của bạn tên là “www.trangweb.com” thì bạn sẽ phải đến một đại lý, trả chi phí đăng ký và dịch vụ thường thì nằm trong khoảng $10 – $35 tuỳ theo domain mà bạn sẽ đăng ký. Sau khi trả tiền xong xuôi, người ta sẽ cho phép bạn sở hữu tên miền đó trong thời hạn một năm và bạn cần phải gia hạn cho domain này hàng năm. Bạn có thể chọn mua domain đến tận 5 năm nếu bạn muốn. Hiện nay rất nhiều dịch vụ cung cấp host đều khuyến mãi domain free trong vòng từ 1 đến 2 năm, từ những năm sau là bạn phải trả tiền. Tuy nhiên, theo kinh nghiệm của tôi, bạn nên tự đăng ký domain riêng cho mình và không nên đi chung với nơi cung cấp dịch vụ host cho bạn. Bằng cách tự đăng ký, bạn sẽ được là chủ sở hữu, người quản lý và hỗ trợ ký thuật cho domain đó. Khi đã là chủ sở hữu duy nhất của domain đó, bạn được toàn quyền quyết định về “vận mạng” của domain này mà không sợ bị ai chi phối. Trước đây khi chưa biết nhiều về web, lần đầu tiên tôi đi đăng ký domain với một nhà cung cấp của Việt Nam. Tôi mua cả host và domain của họ. Sau này mới biết rằng vì họ sợ mình chuyển domain đó sang đại lý khác, nên họ lock domain đó lại. Muốn thay đổi gì phải email cho họ, rất mất thời gian và không tiện lợi. Quay lại vấn đề ở trên, nếu vì bạn muốn tiết kiệm chút tiền ban đầu và để dịch vụ host mua domain cho bạn. Và nếu dịch vụ host đó lại để tên chủ sở hữu chính là họ thì sau này bạn có thể gặp rắc rối nếu trang web của bạn ăn lên làm ra. Lúc đó người ta sẽ bắt bạn trả tiền để được phép “thuê” domain của họ. Tiếp theo là những thông tin khác như Administrative và Technical contact. Tuy nó không thực sự quan trọng như là Owner, nhưng nếu bạn muốn chuyển domain ra khỏi host, bạn cần sự đồng ý của Administrative Contact. Nếu người này không liên lạc được thì Technical Contact sẽ được sử dụng. Domain luôn được đăng ký với tốc độ chóng mặt, do vậy bạn cần lẹ tay khi đăng ký domain. Nếu bạn nghĩ ra một tên nào đó phù hợp và hay, bạn nên đăng ký ngay trước khi bị người khác đăng ký mất. Tôi cũng có một kinh nghiệm để đời về việc này khi chỉ do dự có mấy phút mà tôi bị mất một cái domain .com và cuối cùng phải xài .net.",
        "Summary": "Để đăng ký domain, bạn cần liên hệ với Registrar (đại lý) và trả phí đăng ký (thường từ $10-$35/năm). Bạn nên tự đăng ký domain để làm chủ sở hữu, tránh rắc rối về sau nếu website phát triển. Cần chú ý đến thông tin Owner (chủ sở hữu), Administrative và Technical contact. Domain được đăng ký rất nhanh, nên đăng ký ngay khi tìm được tên phù hợp.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và dễ hiểu, tạo thành một dòng chảy thông tin liên tục và có ý nghĩa."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và súc tích về văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00065",
        "Article": "Mô hình OSI là mô hình tham chiếu được ISO xây dựng nhằm tạo một chuẩn phục vụ việc nối kết các hệ thống mở. Tuy nhiên mô hình OSI chỉ dừng lại ở mức độ lý thuyết, trong thực tế mô hình TCP/IP đang được sử dụng rộng rãi nhất hiện nay và còn gọi là mô hình Internet, hầu hết tất cả các hệ điều hành đều có cài đặt bộ giao thức TCP/IP. Bộ giao thức này được đặt tên theo hai giao Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 27 thức chính của nó là giao thức điều khiển truyền (TCP - Transmission Control Protocol) và giao thức liên mạng (IP - Internet protocol). Về mặt lịch sử, mô hình TCP/IP ra đời trước khi có mô hình OSI. Giống như mô hình OSI, mô hình cũng được phân thành bốn tầng, mỗi tầng gồm bộ giao thức đảm nhiệm các chức năng riêng biệt. Tuy số lượng tầng ít hơn, nhưng mô hình TCP/IP vẫn phải đảm nhiệm đầy đủ các chức năng đã nêu trong mô hình OSI. Mô hình TCP/IP chia theo 4 tầng: truy nhập mạng, mạng, vận tải và ứng dụng. Mô hình OSI Mô hình TCP/IP Tầng ứng dụng Tầng trình diễn Tầng phiên Tầng ứng dụng Tầng vận tải Tầng vận tải Tầng mạng Tầng Internet Tầng liên kết dữ liệu Tầng vật lý Tầng truy nhập mạng Hình 2.7 Các tầng trong bộ giao thức TCP/IP Mô hình TCP/IP là mô hình giao thức cới các tiêu chuẩn mở, các qui định chuẩn và các giao thức trên diễn đàn công khai và tài liệu của chúng được ghi trong các văn bản gọi là yêu cầu dẫn giải RFC (Requests for Comments). Các RFC bao gồm các đặc tả chính thức về các giao thức truyền dữ liệu và các nguồn mô tả việc sử dụng các giao thức. Các văn bản này cũng chứa các tài liệu kỹ thuật và tổ chức mạng Internet, bao gồm các đặc tả kỹ thuật và chính sách do ủy ban công nghệ Internet (IETF - Internet Engineering Task Force ) soạn thảo. Mô hình TCP/IP mô tả tính năng của các giao thức được cài đặt trên bên máy gửi lẫn máy nhận, chúng tương tác với nhau để phân phát thông tin của các ứng dụng đầu cuối đến đầu cuối, quá trình được thực hiện qua bảy bước: - Tạo dữ liệu ở tầng ứng dụng bên gửi. - Phân đoạn và đóng gói dữ liệu lớp ứng dụng sau đó chuyển xuống tầng dưới. - Chuyển đổi dữ liệu và đưa tới môi trường truyền dẫn. - Vận chuyển dữ liệu qua các mạng, đó là môi trường truyền dẫn và các thiết bị trung chuyển. - Nhận dữ liệu từ mạng - Bóc tách và tập hợp dữ liệu - Chuyển dữ liệu lên tầng ứng dụng của bên nhận. Bài giảng Mạng máy tính – Ths. Nguyễn Xuân Anh 28 Khuôn dạng dữ liệu trên mỗi tầng gọi là đơn vị dữ liệu của giao thức (PDU - Protocol Data Unit). Khi dữ liệu của ứng dụng được chuyển xuống ngăn xếp giao thức để truyền qua môi trường mạng, tại mỗi tầng thông tin điều khiển sẽ được thêm vào dữ liệu của tầng trên, quá trình này gọi là đóng gói dữ liệu. Đơn vị dữ liệu PDU trên mỗi tầng có tên gọi khác nhau: tầng ứng dụng gọi chung là dữ liệu, tầng vận tải gọi là đoạn (Segment), tầng Intetnet gọi là gói (Packet) và tầng truy nhập mạng gọi là khung (Frame).",
        "Summary": "Mô hình OSI là một chuẩn lý thuyết cho việc kết nối các hệ thống, nhưng mô hình TCP/IP (mô hình Internet) mới là mô hình được sử dụng rộng rãi, với bộ giao thức TCP/IP được cài đặt trên hầu hết các hệ điều hành. Mô hình TCP/IP, ra đời trước OSI, gồm bốn tầng: truy nhập mạng, mạng (Internet), vận tải và ứng dụng, đảm nhiệm đầy đủ các chức năng của mô hình OSI. Các tiêu chuẩn và giao thức của TCP/IP được công bố công khai trong các RFC. Quá trình truyền dữ liệu sử dụng TCP/IP bao gồm tạo dữ liệu, phân đoạn và đóng gói, chuyển đổi và vận chuyển dữ liệu qua mạng, sau đó nhận, bóc tách và chuyển dữ liệu lên tầng ứng dụng ở bên nhận. Dữ liệu trên mỗi tầng được gọi là đơn vị dữ liệu giao thức (PDU), với tên gọi khác nhau tùy theo tầng: dữ liệu (ứng dụng), đoạn (vận tải), gói (Internet) và khung (truy nhập mạng). Quá trình thêm thông tin điều khiển vào dữ liệu khi truyền qua các tầng được gọi là đóng gói dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực, mọi thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc, các ý được trình bày một cách rõ ràng và logic. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan, chỉ tập trung vào các ý chính và quan trọng của văn bản gốc. Không có chi tiết nào thừa hoặc không liên quan được đưa vào."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00066",
        "Article": "Có thể nói mật mã là con đẻ của toán học nên sự phát triển của mật mã đi liền với sự phát triển của toán học. Tuy nhiên, do nhiều giải thuật mật mã đòi hỏi khối lượng tính toán lớn nên mật mã chỉ thực sự phát triển mạnh cùng với sự ra đời và phát triển của máy tính điện tử. Sau đây là một số mốc trong sự phát triển của mật mã và ứng dụng mật mã: - Các kỹ thuật mã hoá thô sơ đã được người cổ Ai cập sử dụng cách đây 4000 năm. - Người cổ Hy lạp, Ấn độ cũng đã sử dụng mã hoá cách đây hàng ngàn năm. - Các kỹ thuật mã hoá chỉ thực sự phát triển mạnh từ thế kỷ 1800 nhờ công cụ toán học, và phát triển vượt bậc trong thế kỷ 20 nhờ sự phát triển của máy tính và ngành công nghệ thông tin. - Trong chiến tranh thế giới thứ I và II, các kỹ thuật mã hóa được sử dụng rộng rãi trong liên lạc quân sự sử dụng sóng vô tuyến. Quân đội các nước đã sử dụng các công cụ phá mã, thám mã để giải mã các thông điệp của quân địch. - Năm 1976 chuẩn mã hóa DES (Data Encryption Standard) được Cơ quan mật vụ Hoa Kỳ (NSA – National Security Agency) thừa nhận và sử dụng rộng rãi. - Năm 1976, hai nhà khoa học Whitman Diffie và Martin Hellman đã đưa ra khái niệm mã hóa khóa bất đối xứng (Asymmetric key cryptography), hay mã hóa khóa công khai (Public key cryptography). Điều này đã đem đến những thay đổi lớn trong kỹ thuật mật mã. Theo đó, các hệ mã hóa khóa công khai bắt đầu được sử dụng rộng rãi nhờ khả năng hỗ trợ trao đổi khóa dễ dàng hơn trong khi các hệ mã hóa khóa bí mật gặp khó khăn trong quản lý và trao đổi khóa, đặc biệt khi số lượng người dùng lớn. - Năm 1977, ba nhà khoa học Ronald Rivest, Adi Shamir, và Leonard Adleman giới thiệu giải thuật mã hóa khóa công khai RSA. Từ đó, RSA trở thành giải thuật mã hóa khóa công khai được sử dụng rộng rãi nhất do RSA có thể vừa được sử dụng để mã hóa thông tin và sử dụng trong chữ ký số. - Năm 1991, phiên bản đầu tiên của chuẩn PGP (Pretty Good Privacy) ra đời. - Năm 2001, chuẩn mã hóa AES (Advanced Encryption Standard) được thừa nhận và ứng dụng rộng rãi.",
        "Summary": "Mật mã phát triển cùng với toán học và bùng nổ nhờ sự ra đời của máy tính. Các mốc quan trọng gồm: kỹ thuật mã hóa thô sơ từ 4000 năm trước, sự phát triển mạnh trong thế kỷ 20 nhờ công nghệ thông tin, chuẩn mã hóa DES năm 1976, khái niệm mã hóa khóa công khai của Diffie-Hellman năm 1976, giải thuật RSA năm 1977, chuẩn PGP năm 1991 và chuẩn AES năm 2001.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, theo trình tự thời gian phát triển của mật mã. Câu mở đầu tóm tắt ý chính, sau đó liệt kê các mốc quan trọng một cách có hệ thống."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và các mốc thời gian quan trọng trong sự phát triển của mật mã, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về sự phát triển của mật mã một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00067",
        "Article": "Ví dụ 7-1. Viết chương trình liệt kê các số nguyên tố từ 1 tới N, với N là một số nguyên dương, sử dụng kỹ thuật lập trình RMI. Phương thức kiểm tra số nguyên tố được triệu gọi từ xa. Bước 1: Tạo 2 project RMI_Prime_Client và RMI_Prime_Server. 93 Bước 2: Trong project RMI_Prime_Server tạo một package đặt tên là Core. Trong package này tạo một interface đặt tên là PrimeInterface như sau: public interface PrimeInterface extends Remoteà public boolean isPrime(int x) throws RemoteException; â Chú ý rằng trong kỹ thuật lập trình RMI các Interface phải kế thừa lớp Remote, các phương thức của nó phải throws RemoteException. Phương thức isPrime(int x) dùng để kiểm tra một số x có phải là số nguyên tố hay không. Phương thức này chưa được hiện thực mà mới chỉ khai báo. Sao chép package Core sang project RMI_Prime_Client (bao gồm cả PrimeInterface). Bước 3: Hiện thực PrimeInterface phía Server. Trong project RMI_Prime_Server tạo một package mới đặt tên là RMI. Trong package này tạo một lớp mới đặt tên là Prime. Hiện thực hóa interface trong lớp này như sau: public class Prime extends UnicastRemoteObject implements PrimeInterfaceà //Constructor public Prime() throws RemoteException à â @Override public boolean isPrime(int x) throws RemoteException à for (int i = 2; i <= Math.sqrt(x); i++) à if (x%i == 0) à return false; â â return true; â â Bước 4: Lập trình cho Server. Trong package RMI tạo class đặt tên là Server. Chúng ta tạo một Registry trên cổng bất kỳ (chẳng hạn 3210) rồi ràng buộc (bind) một PrimeService cho một đối tượng thuộc lớp Prime trên đó. public class Server à private final int PORT = 3210; public static void main(String[] args) à new Server().run(); â public void run() à try à Registry reg = LocateRegistry.createRegistry(PORT); reg.rebind(\"PrimeService\", new Prime()); System.out.println(\"Máy chủ đang chạy...\"); â catch (RemoteException ex) à 94 System.out.println(\"Không thể khởi chạy máy chủ!!!\"); â â â Bước 5: Lập trình cho Client. Trong project RMI_Prime_Client tạo một package đặt tên là RMI. Trong package này tạo một JFrame Form đặt tên là Client. Thiết kế giao diện cho Client như sau: Hình 7.4: Thiết kế giao diện liệt kê số nguyên tố Lập trình cho sự kiện người dùng nhấp chuột vào nút Lấy kết quả như sau: private void btGetActionPerformed(java.awt.event.ActionEvent evt) à try à String host = tfHost.getText(); int port = Integer.parseInt(tfPort.getText()); int max = Integer.parseInt(tfMax.getText()); taResults.setText(\"\"); Registry reg = LocateRegistry.getRegistry(host, port); NumberInterface prime = (NumberInterface)reg.lookup(\"PrimeService\"); int count = 0; for (int i = 2; i <= max; i++) à if (prime.isPrime(i)) à taResults.append(i + \" \"); count++; â if (count == 10) à taResults.append(\"\\n\"); count = 0; â â â catch (RemoteException ex) à JOptionPane.showMessageDialog(null, \"Không kết nối được tới máy chủ!!!\", \"Lỗi\", 0); 95 â catch (NumberFormatException ex) à JOptionPane.showMessageDialog(null, \"Giá trị lớn nhất phải là số nguyên!!!\", \"Lỗi\", 0); â catch (NotBoundException ex) à JOptionPane.showMessageDialog(null, \"Không tìm thấy dịch vụ!!!\", \"Lỗi\", 0); â â Chạy Server trước, sau đó chạy Client. Trong form xuất hiện, nhập giá trị lớn nhất bất kỳ, giả sử là 500. Nhấn nút Lấy kết quả, chúng ta nhận được như hình bên dưới: Hình 7.5: Kết quả liệt kê số nguyên tố với máy chủ RMI",
        "Summary": "Ví dụ này minh họa việc sử dụng RMI (Remote Method Invocation) trong Java để liệt kê số nguyên tố. Ứng dụng bao gồm một server cung cấp phương thức `isPrime()` để kiểm tra số nguyên tố thông qua giao diện `PrimeInterface`, và một client yêu cầu server kiểm tra các số từ 1 đến N, hiển thị kết quả lên giao diện người dùng. Server sử dụng `LocateRegistry` để tạo registry và ràng buộc đối tượng `Prime` thực hiện `PrimeInterface`. Client kết nối đến server thông qua registry, gọi phương thức `isPrime()` từ xa và hiển thị danh sách số nguyên tố. Quá trình xử lý bao gồm việc tạo hai project, hiện thực giao diện và lớp, và thiết lập kết nối client-server thông qua RMI.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất để người đọc có thể hiểu được mục đích và cách thức hoạt động của chương trình RMI liệt kê số nguyên tố."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về ví dụ RMI liệt kê số nguyên tố. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00068",
        "Article": "Thành phần này được gọi bằng nhiều tên khác nhau như bộ dịch lệnh (command interpreter) hoặc vỏ (shell). Thực chất, đây là giao diện giữa người dùng với hệ điều hành và cần phân biệt với các lời gọi hệ thống (system calls), vốn là giao diện giữa các chương trình và hệ điều hành. Bộ dịch lệnh hay vỏ có nhiệm vụ nhận lệnh từ người dùng và thực hiện các lệnh này, có thể bằng cách sử dụng dịch vụ do các phần khác của hệ điều hành cung cấp. Một số bộ dịch lệnh phổ biến có thể kể đến như cmd.exe của Windows và bash của Linux. Người dùng nhập các lệnh trực tiếp dưới dạng văn bản, với số lượng lệnh có thể từ vài chục đến hàng trăm, bao gồm cả các lệnh thông dụng như liệt kê thư mục (dir, ls), sao chép tệp tin (copy), cũng như các lệnh nâng cao để thiết lập cấu hình mạng hoặc quản lý hệ thống. Trong các hệ điều hành hiện đại, bộ dịch lệnh truyền thống thường được thay thế bằng các hệ giao diện đồ họa. Thay vì nhập lệnh dưới dạng văn bản, người dùng có thể thao tác trực quan với các đối tượng đồ họa như cửa sổ, biểu tượng và menu. Điều này giúp cải thiện trải nghiệm người dùng, giảm bớt yêu cầu về kiến thức kỹ thuật và giúp hệ thống trở nên dễ sử dụng hơn. Một số giao diện đồ họa phổ biến có thể kể đến như Windows Explorer của Windows hoặc X Windows của Linux. Các giao diện đồ họa không chỉ cung cấp cách thức tương tác tiện lợi mà còn tích hợp nhiều tính năng mở rộng như kéo thả tệp tin, hiển thị biểu đồ hệ thống và tùy chỉnh môi trường làm việc. Bên cạnh đó, một số hệ điều hành vẫn duy trì cả hai dạng giao diện: giao diện dòng lệnh dành cho những người dùng có kinh nghiệm và giao diện đồ họa cho người dùng phổ thông. Ví dụ, trên hệ điều hành Linux, người dùng có thể sử dụng giao diện đồ họa như GNOME hoặc KDE, nhưng vẫn có thể truy cập terminal để sử dụng bash hoặc zsh. Tương tự, Windows cung cấp giao diện đồ họa Windows Explorer nhưng cũng hỗ trợ PowerShell và Command Prompt để thực hiện các tác vụ hệ thống một cách linh hoạt. Nhờ đó, hệ điều hành có thể phục vụ nhiều nhóm người dùng với nhu cầu và trình độ khác nhau.",
        "Summary": "Bộ dịch lệnh (shell) là giao diện giữa người dùng và hệ điều hành, nhận và thực thi lệnh, với các ví dụ như cmd.exe trên Windows và bash trên Linux. Trong các hệ điều hành hiện đại, giao diện đồ họa như Windows Explorer hoặc GNOME thay thế giao diện dòng lệnh truyền thống, nhưng vẫn duy trì cả hai dạng giao diện để phục vụ người dùng phổ thông và người dùng có kinh nghiệm.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng và có sự liên kết logic. Câu mở đầu giới thiệu khái niệm, tiếp theo là ví dụ và cuối cùng là sự thay đổi trong hệ điều hành hiện đại, tạo thành một dòng chảy thông tin dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, ví dụ và sự thay đổi của giao diện người dùng trong hệ điều hành."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan đến văn bản gốc. Bản tóm tắt đã làm nổi bật được các ý chính của văn bản gốc một cách hiệu quả. Không có đề xuất cải thiện nào."
            }
        }
    },
    {
        "Index": "00069",
        "Article": "Dò tìm điểm bất thường Ngoài các ứng dụng về nén và phân loại, PCA còn được sử dụng trong nhiều lĩnh vực khác. Dò tìm điểm bất thường (abnormal detection hoặc outlier detection) là một trong số đó [SCSC03, LCD04]. 286 Machine Learning cơ bản https://thuviensach.vn Chương 21. Phân tích thành phần chính u2 u1 Hình 21.8. PCA cho bài toán dò tìm điểm bất thường. Giả sử các sự kiện bình thường chiếm đa số và nằm gần một không gian con nào đó. Khi đó, nếu làm PCA trên toàn bộ dữ liệu, không gian con thu được gần với không gian con của tập các sự kiện bình thường. Lúc này, các điểm hình tròn to đậm hơn có thể được coi là các sự kiện bất thường vì chúng nằm xa không gian con chính. Ý tưởng cơ bản là giả sử tồn tại một không gian con mà các sự kiện bình thường nằm gần trong khi các sự kiện bất thường nằm xa không gian con đó. Hơn nữa, số sự kiện bất thường có một tỉ lệ nhỏ. Như vậy, PCA có thể được sử dụng trên toàn bộ dữ liệu để tìm ra các thành phần chính, từ đó suy ra không gian con mà các điểm bình thường nằm gần. Việc xác định một điểm là bình thường hay bất thường được xác định bằng cách đo khoảng cách từ điểm đó tới không gian con tìm được. Hình 21.8 minh hoạ cho việc xác định các sự kiện bất thường bằng PCA. 21.7. Thảo luận • PCA là phương pháp giảm chiều dữ liệu dựa trên việc tối đa lượng thông tin được giữ lại. Lượng thông tin được giữ lại được đo bằng tổng các phương sai trên mỗi thành phần của dữ liệu. Lượng dữ liệu sẽ được giữ lại nhiều nhất khi các chiều dữ liệu còn lại tương ứng với các vector riêng của trị riêng lớn nhất của ma trận hiệp phương sai. • Với các bài toán quy mô lớn, đôi khi việc tính toán trên toàn bộ dữ liệu là không khả thi vì vấn đề bộ nhớ. Giải pháp là thực hiện PCA lần đầu trên một tập con dữ liệu vừa với bộ nhớ, sau đó lấy một tập con khác để từ từ (incrementally) cập nhật nghiệm của PCA tới khi hội tụ. Ý tưởng này khá giống với mini-batch gradient descent, và được gọi là incremental PCA [ZYK06]. • Ngoài ra, còn rất nhiều hướng mở rộng của PCA, bạn đọc có thể tìm kiếm theo từ khoá: Sparse PCA [dGJL05], Kernel PCA [MSS+99], Robust PCA [CLMW11].",
        "Summary": "\"PCA được ứng dụng trong dò tìm điểm bất thường, dựa trên giả định rằng các sự kiện bình thường chiếm đa số và nằm gần một không gian con. PCA được thực hiện trên toàn bộ dữ liệu để tìm các thành phần chính, từ đó xác định không gian con chứa các điểm bình thường. Điểm bất thường được xác định bằng cách đo khoảng cách từ điểm đó đến không gian con này. Với dữ liệu lớn, có thể sử dụng incremental PCA để cập nhật nghiệm PCA một cách tuần tự. Ngoài ra, còn có các mở rộng khác của PCA như Sparse PCA, Kernel PCA và Robust PCA.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về ứng dụng của PCA trong dò tìm điểm bất thường và các phương pháp liên quan. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00070",
        "Article": "Các thông số RAM Giải thích DDR 512MB bus 400 Kingston Thanh DDRam dung lượng 512MB / tốc độ Bus 400MHz / hãng Kingston DDR II 256MB bus 533 SamSung, KingMax DDRII 256MB / tốc độ Bus 533MHz / hãng Samsung DDRII có tốc độ từ 533 MHz trở lên và chúng không thay thế cho DDR được vì có điện áp khác nhau 4. Chuẩn bị thiết bị cho một bộ máy tính Một bộ máy tính tối thiểu cần những thiết bị sau 1. Case ( Hộp máy ) Case là vỏ máy, hãy chọn case sao cho đảm bảo được độ thoáng mát cho máy, bộ nguồn thường đi theo case hoặc bán rời, hiện nay ta nên dùng nguồn có công suất > = 350W https://thuviensach.vn 2. Mainboard Mainboard là thiết bị quan trọng nhất mà bạn cần quan tâm, Mainboard nó quyết định trực tiếp đến tốc độ và độ bền của máy, nên chọn mainboard của các hãng uy tín như Intel, Gigaby, Asus, và một số hãng khác và có sử dụng chipset của Intel Khi chọn Mainboard cần quan tâm đến Socket và FSB của CPU và Bus của RAM 3. CPU Phải chọn CPU thích hợp với Mainboard mà bạn đã chọn và CPU đó phải có tốc độ đảm bảo với yêu cầu công việc của khách hàng . https://thuviensach.vn 4. RAM Bạn phải chọ RAM có dung lượng đảm bảo cho yêu cầu công việc của khách hàng, còn tốc độ Bus thì phụ thuộc vào Bus của CPU 5. Card Video ( Nếu Mainboard chưa có ) Nếu như Mainboard chưa có Card Video on board thì bạn cần phải lắp thêm Card Video rời, dung lượng RAM trên Card video càng lớn thì cho phép bạn xử lý được các bức ảnh đẹp hơn và khi chơi Game ảnh không bị giật , còn tốc độ bao nhiêu \"x\" của Card phải phụ thuộc vào Mainboard 6. Ổ cứng HDD Bạn có thể mua ổ cứng từ 10GB trở lên là máy đã có thể chạy bình thường với Win XP, tuy nhiên bạn nên chọn dung lượng ổ gấp 2 lần dung lượng bạn sẽ sử dụng là tốt nhất, không nên dùng ổ quá lớn trong khi dung lượng sử dụng quá ít .",
        "Summary": "Bản tóm tắt:\n  \n  Bài viết liệt kê các thông số và thiết bị cần thiết cho một bộ máy tính. Về RAM, các thông số quan trọng là loại (DDR, DDRII), dung lượng (ví dụ: 512MB, 256MB), tốc độ Bus (ví dụ: 400MHz, 533MHz) và hãng sản xuất (ví dụ: Kingston, Samsung). Các thiết bị tối thiểu cho máy tính bao gồm: Case (chọn loại thoáng mát, nguồn >= 350W), Mainboard (chọn hãng uy tín như Intel, Gigabyte, Asus, chú ý Socket, FSB của CPU và Bus của RAM), CPU (phù hợp với Mainboard và đáp ứng yêu cầu công việc), RAM (dung lượng và Bus phù hợp), Card Video (nếu Mainboard không có card onboard, chọn dung lượng phù hợp) và Ổ cứng HDD (dung lượng từ 10GB trở lên, nên gấp đôi dung lượng dự kiến sử dụng).",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến nội dung chính của văn bản gốc. Các chi tiết được chọn lọc kỹ càng, tập trung vào những thông tin quan trọng nhất về thông số RAM và các thiết bị cần thiết cho một bộ máy tính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ về nội dung chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00071",
        "Article": "6.2.5. Khung pháp lý về thương mại điện tử của APEC Đứng trước sự phát triển không ngừng của thương mại điện tử, APEC cũng đang từng bước tiến hành ứng dụng thương mại điện tử. Tháng 11/1997, tại cuộc họp ở Vancouver, APEC đã vạch ra chương trình công tác về thương mại điện tử cho khu vực và thành lập “nhóm công tác chuyên trách về thương mại điện tử” do Singapore và Australia đồng chủ tịch. Mục tiêu là làm cho các nước thành viên hiểu rõ về thương mại điện tử, các hoạt động của nó, triển khai dần vào việc ứng dụng trong từng nước và giữa các nước thành viên trong khu vực. Tháng 11/1998, APEC tiến hành “chương trình hành động về thương mại điện tử” với các nội dung chủ yếu sau: - Tập trung nỗ lực phát triển thương mại điện tử ở các doanh nghiệp có điều kiện, có hiểu biết về thương mại điện tử. - Nâng cao vai trò của chính phủ trong việc tạo môi trường pháp lý. Hiện nay, APEC đã xây dựng xong chương trình hoạt động chung để thực hiện thương mại điện tử vào năm 2005 đối với các nước phát triển và năm 2010 đối với các nước đang phát triển. Trong khu vực Châu Á - Thái Bình Dương, Nhật là nước đi đầu trong lĩnh vực thương mại điện tử. Hội đồng phát triển thương mại điện tử của Nhật đang cố gắng đơn giản hóa thủ tục thương mại điện tử ở Nhật, thông qua việc tiến hành xây dựng lòng tin và đưa ra nhiều phương án để tiếp cận với khách hàng. Nhật cũng đã tiến hành nhiều dự án trong lĩnh vực giao dịch này nhằm tạo môi trường điện tử thân thiện ở Nhật. Hiện nay, Nhật đã cho ra đời văn bản pháp luật về chữ ký điện tử nhằm tạo điều kiện cho thương mại điện tử phát triển bền vững.",
        "Summary": "\"APEC đã thành lập nhóm công tác chuyên trách về thương mại điện tử năm 1997 để thúc đẩy ứng dụng thương mại điện tử trong khu vực. Năm 1998, APEC đưa ra chương trình hành động, tập trung vào phát triển thương mại điện tử ở các doanh nghiệp có điều kiện và nâng cao vai trò của chính phủ trong việc tạo môi trường pháp lý. Mục tiêu là thực hiện thương mại điện tử vào năm 2005 (nước phát triển) và 2010 (nước đang phát triển). Nhật Bản là nước đi đầu trong khu vực, đơn giản hóa thủ tục và xây dựng lòng tin trong thương mại điện tử, đồng thời ban hành luật về chữ ký điện tử.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch. Các sự kiện và số liệu (ví dụ: năm thành lập nhóm công tác, chương trình hành động, mục tiêu thực hiện thương mại điện tử) được trình bày chính xác."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày theo trình tự thời gian hợp lý (từ năm 1997 đến hiện tại), giúp người đọc dễ dàng theo dõi sự phát triển của thương mại điện tử trong APEC. Các câu liên kết với nhau một cách logic, tạo thành một dòng chảy thông tin liền mạch và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm việc thành lập nhóm công tác, chương trình hành động, mục tiêu thực hiện thương mại điện tử và vai trò tiên phong của Nhật Bản. Các chi tiết không quan trọng đã được lược bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào những thông tin quan trọng nhất."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về khung pháp lý thương mại điện tử của APEC. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00072",
        "Article": "Quan sát và phản ứng với các hoạt động đáng ngờ trong cơ quan/tổ chức là một khía cạnh phức tạp và thường bị bỏ qua của quản lý sự cố. Nếu không có phương tiện phát hiện sự cố, kẻ tấn công có thể xâm nhập hệ thống và duy trì quyền truy cập trong thời gian dài. Nếu không có đủ phương tiện để quan sát trạng thái hệ thống và phân tích trạng thái bảo mật của chúng, cơ quan/tổ chức chỉ có thể biết về sự cố khi nhận được kích hoạt bên ngoài, chẳng hạn như thông tin bí mật xuất hiện trên trang web tấn công hoặc các chi tiết nhạy cảm về cơ quan/tổ chức xuất hiện trên các phương tiện truyền thông.\n Các sự kiện log được tạo ra bởi công nghệ hiện đại nhất để chúng có thể được nhập vào bởi các hệ thống giám sát đặc biệt được gọi là hệ thống quản lý sự kiện và thông tin bảo mật (SIEM), cho phép các nhóm vận hành an ninh giám sát môi trường từ một vị trí (trung tâm vận hành an ninh). Các sự kiện bảo mật yêu cầu mức độ phân tích, tự động hoặc bởi người phân tích được đào tạo để hiểu và sử dụng thông tin để phát hiện các mối đe dọa tiềm ẩn. Nếu một sự kiện hoặc cảnh báo được phát hiện được coi là dấu hiệu của sự xâm phạm thì quy trình quản lý sự cố có thể được ban hành. Trung tâm vận hành an ninh trở thành hệ thống cảnh báo sớm sàng lọc hàng trăm nghìn sự kiện log để tìm kiếm các dấu hiệu của sự xâm phạm, dựa trên chữ ký, kinh nghiệm và các quy tắc tương quan được lập trình trước để phát hiện các véc-tơ tấn công đang được sử dụng.\n Có hai phương pháp mà nhóm an ninh có thể sử dụng khi điều tra một sự cố tùy thuộc vào hoàn cảnh của sự kiện. Loại đầu tiên được gọi là phân tích tinh (static analysis), thường cần sử dụng các công cụ phần mềm đặc biệt để xem phần mềm độc hại nào được cài đặt trên hệ thống và cách phần mềm độc hại đó có thể hoạt động. Tuy nhiên, phần mềm độc hại sẽ không được thực thi để xem xét hành vi của nó. Hình thức điều tra thứ hai liên quan đến việc thiết lập một môi trường thử nghiệm đặc biệt và sau đó chạy phần mềm độc hại, để có thể ghi lại phần mềm độc hại làm gì và sử dụng những kết quả đó để xác định cách nó hoạt động và tác động của nó đối với mục tiêu. Việc phân tích động đôi khi còn được gọi là phân tích hành vi.",
        "Summary": "Việc quan sát và phản ứng với các hoạt động đáng ngờ là yếu tố quan trọng trong quản lý sự cố. Các hệ thống SIEM giúp giám sát và phân tích sự kiện bảo mật để phát hiện các mối đe dọa. Khi phát hiện dấu hiệu xâm phạm, quy trình quản lý sự cố được kích hoạt. Có hai phương pháp điều tra sự cố: phân tích tĩnh (static analysis) sử dụng công cụ để xem xét phần mềm độc hại mà không thực thi nó, và phân tích động (dynamic analysis/behavioral analysis) chạy phần mềm độc hại trong môi trường thử nghiệm để ghi lại hành vi và tác động của nó.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không có sự diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết. Các thông tin được chọn lọc kỹ càng, đảm bảo truyền tải đầy đủ nội dung cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó đáp ứng đầy đủ các tiêu chí về tính trung thực, mạch lạc và liên quan. Điểm mạnh của bản tóm tắt là khả năng chọn lọc thông tin chính xác và trình bày một cách rõ ràng, dễ hiểu. Không có điểm cần cải thiện."
            }
        }
    },
    {
        "Index": "00073",
        "Article": "Một method trong java là một tập các câu lệnh được nhóm lại với nhau để thực hiện một hành động cụ thể. Cú pháp hàm: modifier returnType nameOfMethod (Parameter List) à // method body Giải thích: ▪ Modifiers (tạm dịch là phạm vi sửa đổi và truy cập): public hoặc static ▪ returnType: kiểu dữ liệu trả về ▪ nameOfMethod: tên của hàm(method) ▪ Parameter là các tham số đầu vào của hàm(có thể có nhiều tham số với nhiều kiểu dữ liệu khác nhau) ▪ // body: là các mã code bên trong hàm Ví dụ: Viết hàm tính tổng 2 chữ số a và b public static int sum(int a, int b) à return a + b; â Khi chúng ta đã viết xong một hàm rồi làm sao để chúng ta có thể sử dụng chúng đây ta! Trước tiên chúng ta sẽ có 2 loại hàm, mỗi loại sẽ có cách gọi khác nhau: ▪ Hàm có trả về kết quả ▪ Hàm không trả về kết quảĐối với hàm có kết quả trả về, chúng ta cần dùng từ khoá return để trả về kết qủa mà nó đã tính toán được. Khai báo biến có kiểu dữ kiệu tương ứng với kết quả trả về của hàm để nhận giá trị trả về. Như ví dụ tìm sum() của chúng ta, nhiệm vụ của nó là tính tổng của 2 số nguyên a, b nhập vào. Ví dụ 3.11: public class Main à public static int sum(int a, int b) à return a + b; â public static void main(String[] args) à int sum = sum(2,5); System.out.println(sum); â â Chúng ta sẽ dùng biến có kiểu dữ liệu tương ứng để nhận kết quả trả về từ hàm. Hàm sum() trả về int chúng ta dùng biến int sum để nhận kết quả.Đối với loại hàm này chúng ta chỉ cần gọi để sử dụng. Ví dụ: public static void printHello() à System.out.println(\"Hello\"); Hàm printHello() là một hàm không có kiểu trả về nên được thay thế thành void. Từ khoá void cho chúng ta biết là method đó sẽ không có kết quả trả về.Khi bạn gọi đến một hàm đã được định và nó có danh sách các thông số nhất định. Thì khi gọi các bạn sẽ phải truyền đúng thứ tự và kiểu dữ liệu cho từng tham số. Nếu sai xót trong quá trình này có thể dẫn đến biên dịch lỗi hoặc là kết quả không đúng như mong muốn. Ví dụ 3.12: public class Main à public static void swap(int a, int b) à int tam = a; a = b; b = tam; System.out.println(\"Ket qua swap: \" + \"a = \" + a + \" b= \" + b); â public static void main(String[] args) à int a = 5, b = 3; swap(a, b); System.out.println(\"a sau khi swap: \" + a); System.out.println(\"b sau khi swap: \" + b); â â Output: Ket qua swap: a = 3 b= 5 a sau khi swap: 5 b sau khi swap: 3 Nhìn vào kết quả trên, rõ ràng hàm swap đã được a thành b, b thành a, sao trong hàm main giá trị lại như cũ nhỉ? Đó chính là truyền thông số theo giá trị đó các bạn, các tham số truyền vào hàm sẽ chỉ nhận giá trị mà không tham chiếu đến 2 biến a, b của chúng ta. Thế nên đừng có viết hàm swap() như trên nữa nghen, hồi mình chuyển tử C/C++ sang java cũng đã cố gắng viết hàm swap mà không thành.",
        "Summary": "Văn bản mô tả methods trong Java, bao gồm cú pháp với các thành phần: modifiers (ví dụ: public, static), returnType (kiểu dữ liệu trả về), tên method, và danh sách tham số. Methods có hai loại: có trả về giá trị (sử dụng `return`) và không trả về giá trị (returnType là `void`). Việc truyền tham số vào method trong Java là truyền theo giá trị, nghĩa là thay đổi giá trị tham số trong method không ảnh hưởng đến biến gốc bên ngoài method, như ví dụ hàm `swap` minh họa. Điều này cần được lưu ý khi thiết kế và sử dụng methods trong Java.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào cú pháp method, các loại method và cách truyền tham số trong Java, là những điểm cốt lõi của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00074",
        "Article": "Phân tích lỗ hổng bảo mật (vulnerability assessment) là quá trình phát hiện, đo lường và đánh giá các điểm yếu trong hệ thống công nghệ thông tin có thể bị khai thác bởi các tác nhân độc hại. Việc thực hiện phân tích lỗ hổng định kỳ giúp tổ chức nhận diện các rủi ro tiềm ẩn trước khi kẻ tấn công có cơ hội lợi dụng, từ đó giảm thiểu khả năng xảy ra sự cố và tổn thất dữ liệu. Quy trình này thường bao gồm các bước như thu thập thông tin về tài sản CNTT, quét hệ thống bằng các công cụ chuyên dụng, phân loại lỗ hổng theo mức độ nghiêm trọng, xác định mức độ ưu tiên xử lý và xây dựng kế hoạch khắc phục. Một số công cụ phổ biến được sử dụng trong phân tích lỗ hổng gồm Nessus, OpenVAS, Qualys, Nexpose, Burp Suite… Các công cụ này có khả năng kiểm tra hàng trăm đến hàng nghìn lỗ hổng đã biết thông qua cơ sở dữ liệu được cập nhật thường xuyên. Tuy nhiên, cần lưu ý rằng kết quả phân tích lỗ hổng chỉ phản ánh trạng thái tại thời điểm thực hiện, vì vậy cần thực hiện kiểm tra định kỳ và sau mỗi lần cập nhật hệ thống. Ngoài ra, phân tích lỗ hổng nên được kết hợp với đánh giá rủi ro để xác định tác động thực tế của từng lỗ hổng đối với tổ chức. Đối với môi trường sản xuất, cần có kế hoạch quét lỗ hổng không gây ảnh hưởng đến hoạt động, đặc biệt với hệ thống thời gian thực. Một số tổ chức còn triển khai chương trình bug bounty nhằm khuyến khích cộng đồng an ninh mạng tìm kiếm và báo cáo lỗ hổng bảo mật với phần thưởng tương ứng. Kết hợp với kiểm thử xâm nhập, phân tích lỗ hổng là bước đầu trong việc xây dựng một hệ thống phòng thủ chủ động, giúp tổ chức chủ động đối phó với các nguy cơ thay vì chỉ phản ứng bị động.",
        "Summary": "Phân tích lỗ hổng bảo mật là quá trình xác định, đánh giá và xếp hạng mức độ nghiêm trọng của các điểm yếu trong hệ thống. Kỹ thuật này giúp tổ chức chủ động vá lỗi trước khi bị khai thác. Việc phân tích thường đi kèm công cụ tự động và đánh giá thủ công, đảm bảo độ chính xác cao. Kết quả phân tích là cơ sở để xây dựng kế hoạch cải thiện bảo mật và ưu tiên khắc phục lỗ hổng có rủi ro cao. Đây là hoạt động cần thực hiện định kỳ trong chiến lược bảo mật tổng thể.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các câu văn được liên kết chặt chẽ, tạo thành một dòng chảy thông tin logic và dễ hiểu. Các ý được trình bày rõ ràng, không gây khó khăn cho người đọc trong việc nắm bắt nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan đến văn bản gốc. Nó tập trung vào các ý chính như định nghĩa, mục đích, phương pháp và vai trò của phân tích lỗ hổng bảo mật, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về phân tích lỗ hổng bảo mật một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00075",
        "Article": "Trong hệ điều hành, quản lý bộ đệm (buffering) và lưu trữ tạm (caching) là hai kỹ thuật quan trọng giúp cải thiện hiệu suất truy xuất dữ liệu giữa CPU và các thiết bị ngoại vi. Do sự chênh lệch lớn về tốc độ giữa CPU và thiết bị I/O, hệ điều hành cần sử dụng các vùng nhớ trung gian để tạm lưu dữ liệu, tránh làm CPU phải chờ đợi hoặc thiết bị bị nghẽn. Buffering là kỹ thuật lưu trữ tạm thời dữ liệu trong bộ nhớ chính trước khi chuyển đến hoặc từ thiết bị ngoại vi. Có nhiều kiểu bộ đệm như single buffer, double buffer, và circular buffer. Trong đó, double buffer giúp tránh mất dữ liệu bằng cách cho phép một bộ đệm được sử dụng trong khi bộ đệm kia đang được làm đầy hoặc làm trống. Buffering rất hữu ích trong các thiết bị tốc độ thấp như máy in, bàn phím hoặc giao tiếp mạng. Caching, ngược lại, là kỹ thuật lưu trữ dữ liệu đã truy xuất gần đây trong bộ nhớ tốc độ cao (cache), nhằm tăng tốc độ truy cập nếu dữ liệu đó được sử dụng lại. Cache có thể xuất hiện ở nhiều cấp độ: bộ đệm đĩa (disk cache), cache bộ nhớ chính, hay cache CPU. Hệ điều hành sử dụng các thuật toán thay thế như LRU (Least Recently Used), FIFO hoặc Adaptive Replacement Cache để quản lý cache hiệu quả. Ngoài ra, hệ điều hành còn đảm nhiệm đồng bộ dữ liệu giữa cache và bộ nhớ chính, đặc biệt trong các thao tác ghi đĩa. Sử dụng buffering và caching hợp lý giúp tăng thông lượng I/O, giảm thời gian đáp ứng và cải thiện trải nghiệm người dùng. Tuy nhiên, cần cẩn trọng khi xử lý dữ liệu quan trọng, vì mất điện hoặc sự cố hệ thống có thể khiến dữ liệu trong bộ đệm bị mất nếu chưa được ghi xuống thiết bị vĩnh viễn.",
        "Summary": "Quản lý bộ đệm (buffering) là kỹ thuật cho phép lưu tạm dữ liệu khi truyền giữa các thiết bị và tiến trình, nhằm giảm thời gian chờ và tăng hiệu suất hệ thống. Bộ đệm giúp giải quyết sự không đồng bộ giữa tốc độ xử lý của CPU và thiết bị ngoại vi. Các kiểu bộ đệm gồm: đơn, kép hoặc luân phiên. Sử dụng đúng cách, bộ đệm không chỉ tối ưu hóa tài nguyên mà còn đảm bảo truyền dữ liệu an toàn và liên tục, đặc biệt trong các ứng dụng cần tốc độ cao và độ ổn định lớn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có một số chi tiết không hoàn toàn chính xác hoặc không đầy đủ so với văn bản gốc. Ví dụ, bản tóm tắt đề cập đến việc 'đảm bảo truyền dữ liệu an toàn', trong khi văn bản gốc lại nhấn mạnh nguy cơ mất dữ liệu trong bộ đệm nếu có sự cố. Ngoài ra, phần tóm tắt về các kiểu bộ đệm chưa đầy đủ so với văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, các ý được trình bày rõ ràng và có sự liên kết logic. Tuy nhiên, có thể cải thiện bằng cách làm rõ hơn mối quan hệ giữa các câu, ví dụ như sử dụng các từ nối để tăng tính trôi chảy."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tập trung vào các ý chính về buffering, tuy nhiên, việc lược bỏ hoàn toàn phần caching làm giảm đi tính bao quát của tóm tắt so với văn bản gốc. Một vài chi tiết có thể được lược bỏ để tập trung vào các khái niệm quan trọng hơn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức khá, nắm bắt được một số ý chính của văn bản gốc về buffering. Tuy nhiên, cần cải thiện về tính trung thực bằng cách đảm bảo thông tin chính xác và đầy đủ hơn, đồng thời cân nhắc việc đề cập đến caching để tăng tính bao quát. Cần xem xét lại việc lựa chọn thông tin để đảm bảo tính liên quan cao hơn."
            }
        }
    },
    {
        "Index": "00076",
        "Article": "Để có được kiểu sao chép hoàn toàn này, lập trình viên phải tự cài đặt quy trình sao chép. Java có hỗ trợ sao chép nông và sao chép sâu với phương thức clone và interface Cloneable. Tuy nhiên, nhiều chuyên gia, trong đó có Joshua Bloch – tác giả cuốn Effective Java [7], khuyên không nên sử dụng hỗ trợ này do nó có lỗi thiết kế và hiệu lực thực thi không ổn định, thay vào đó, nên dùng hàm khởi tạo sao chép. Hàm khởi tạo sao chép (copy constructor) là hàm khởi tạo với tham số duy nhất là một tham chiếu đối tượng và hàm này sẽ khởi tạo đối tượng mới sao cho có nội dung giống hệt đối tượng đã cho. Chẳng hạn: Trong đó, nội dung hàm khởi tạo Cow(Cow c) làm nhiệm vụ sao chép nội dung của đối tượng c vào đối tượng vừa tạo, ở đây chỉ là các phép gán giá trị cho các biến thực thể. Tuy nhiên, khi có quan hệ thừa kế, tình huống không phải lúc nào cũng đơn giản như ví dụ đó. Xét quan hệ thừa kế giữa Animal và Cat. Ta viết hàm khởi tạo sao chép cho cả hai lớp. Giả sử ta cần một tình huống đa hình chẳng hạn như một đoạn mã áp dụng cho các loại Animal nói chung, trong đó có Cat. Trong phương thức đó ta cần nhân bản các đối tượng mà không biết chúng thuộc lớp nào trong cây thừa kế Animal, chẳng hạn: Liệu trong tình huống này ta có thể dùng hàm khởi tạo sao chép của Animal để nhân bản các đối tượng thuộc các lớp con? Ta hãy thử xem. Hình 9.10: Hàm khởi tạo sao chép và quan hệ thừa kế. Ví dụ trong Hình 9.10 cho thấy câu trả lời là 'không thể'. Khi ta dùng lệnh new Animal(tom) gọi hàm khởi tạo sao chép nhằm tạo một bản sao của mèo Tom, thực ra ta đang tạo đối tượng Animal và dùng hàm khởi tạo của lớp Animal (nhớ lại rằng giữa các hàm khởi tạo không có quan hệ thừa kế do đó cũng không có đa hình). Cho nên kết quả của thao tác sao chép thứ hai không phải là một đối tượng mèo tên Tom mà là một đối tượng Animal tên Tom (phiên bản makeNoise() chạy cho đối tượng này in ra \"Huh?\" – đây là phiên bản của Animal chứ không phải phiên bản của Cat). Như vậy sử dụng hàm khởi tạo sao chép như trong tình huống này không cho ta kết quả mong muốn.",
        "Summary": "\"Java hỗ trợ sao chép nông và sâu thông qua phương thức clone và interface Cloneable, nhưng các chuyên gia khuyên dùng hàm khởi tạo sao chép thay thế. Hàm khởi tạo sao chép tạo một đối tượng mới có nội dung giống hệt đối tượng đã cho. Tuy nhiên, khi có quan hệ thừa kế, việc sử dụng hàm khởi tạo sao chép của lớp cha để nhân bản các đối tượng thuộc lớp con có thể không tạo ra bản sao chính xác của đối tượng con, mà chỉ tạo ra một đối tượng thuộc lớp cha với các thuộc tính được sao chép.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc dễ dàng nắm bắt được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào vấn đề sao chép trong Java, khuyến nghị sử dụng hàm khởi tạo sao chép và hạn chế của nó trong quan hệ thừa kế."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00077",
        "Article": "Các phương pháp trên đều không đảm bảo cá thể tốt nhất được lựa chọn. Trong phương pháp lựa chọn tinh hoa, một số lượng nhất định các cá thể tốt nhất được lựa chọn trước, sau đó phần còn lại được lựa chọn theo các phương pháp ru lét hay thi đấu như ở trên. Như vậy, các cá thể tốt nhất luôn được duy trì đoạn gen của mình sang thế hệ sau và tránh làm mất lời giải tốt nhất đã tìm - Loại bỏ các cá thể có hàm thích nghi nhỏ hơn một ngưỡng nhất định, sử dụng các cá thể còn lại để lai ghép và tạo quần thể mới. Xác suất lai ghép. Nếu xác suất lai ghép là 1 (100%) thì toàn bộ cá thể con sẽ được tạo ra do lai ghép. Ngược lại, nếu xác suất lai ghép là 0 thì toàn bộ cá thể con là bản sao của một số cá thể bố mẹ nhưng không nhất thiết quần thể tiếp theo trùng với quần thể cũ. Như đã nói ở trên, xác suất lai ghép được lựa chọn tương đối lớn, thường từ 0.5 trở lên. Xác suất đột biến. Nếu xác suất đột biến là 100% thì toàn bộ cá thể sau khi lai ghép sẽ bị thay đổi. Ngược lại, nếu xác suất này là 0 thì không cá thể nào bị thay đổi. Xác suất đột biến được lựa chọn rất nhỏ, ít khi vượt quá 0.1. Xác suất đột biến nhỏ để tránh cho thuật toán di chuyển theo kiểu ngẫu nhiên. Giải quyết vấn đề bằng tìm kiếm Kích thước quần thể N là số lượng cá thể được duy trì trong mỗi thế hệ. Nếu N quá nhỏ, thuật toán có ít lựa chọn để thực hiện lai ghép, dẫn tới chỉ một phần không gian tìm kiếm được khảo sát và do vậy có thể không tìm được lời giải tốt. Nếu N quá lớn, thuật toán sẽ thực hiện chậm do phải xử lý nhiều trong mỗi vòng lặp. Giá trị tốt của N phụ thuộc vào bài toán cụ thể và cách mã hoá lời giải. Tuy nhiên, nhiều kết quả thực nghiệm cho thấy, khi N tăng tới một mức độ nào đó, chất lượng lời giải không tăng, trong khi thuật toán sẽ chậm hơn.",
        "Summary": "Các phương pháp trên đều không đảm bảo cá thể tốt nhất được lựa chọn. Trong phương pháp lựa chọn tinh hoa, một số lượng nhất định các cá thể tốt nhất được lựa chọn trước, sau đó phần còn lại được lựa chọn theo các phương pháp ru lét hay thi đấu như ở trên.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt mạch lạc vì nó trích dẫn một đoạn văn liên tục từ văn bản gốc, đảm bảo tính liên kết và dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có liên quan, nhưng chưa đầy đủ. Nó chỉ tập trung vào một phần nhỏ của văn bản gốc (phương pháp lựa chọn tinh hoa) mà bỏ qua các ý chính khác như xác suất lai ghép, xác suất đột biến và kích thước quần thể. Do đó, nó chưa bao quát được toàn bộ nội dung quan trọng của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng ở mức khá về tính trung thực và mạch lạc, tuy nhiên cần cải thiện về tính liên quan. Để cải thiện, bản tóm tắt nên bao gồm thêm thông tin về xác suất lai ghép, xác suất đột biến và kích thước quần thể để phản ánh đầy đủ hơn nội dung chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00078",
        "Article": "HDFS Hadoop framwork của Apache là một nền tảng dùng để phân tích các tập dữ liệu rất lớn mà không thể xử lý trên được trên một máy chủ duy nhất. Hadoop trừu tượng hóa mô hình tính toán MapReduce, làm nó trở nên dễ tiếp cận hơn với các nhà phát triển. Hadoop có khả năng mở rộng vô số các nút lưu trữ và có thể xử lý tất cả hoạt động và phân phối liên quan đến việc phân loại dữ liệu. Tổng quan thiết kế của HDFS HDFS (Hadoop distributed file system) ra đời trên nhu cầu lưu trữ dữ liệu của Nutch, một dự án Search Engine nguồn mở. HDFS kế thừa các đặc tính chung của các hệ thống tập tin phân tán thế hệ trước như độ tin cậy, khả năng mở rộng và hiệu suất hoạt động. HDFS được thiết kế với những giả định như dưới đây: Thứ nhất, các lỗi về phần cứng sẽ thường xuyên xảy ra. Hệ thống HDFS sẽ chạy trên các cluster với hàng trăm hoặc thậm chí hàng nghìn nút. Các nút này được xây dựng từ các phần cứng thông thường, giá rẻ, tỷ lệ lỗi cao. Chất lượng và số lượng của các thành phần phần cứng như vậy sẽ tất yếu dẫn đến tỷ lệ xảy ra lỗi trên hệ thống cluster cao. Có thể điểm qua một số lỗi như lỗi của ứng dụng, lỗi của hệ điều hành, lỗi đĩa cứng, bộ nhớ, lỗi của các thiết bị kết nối, lỗi mạng, lỗi về nguồn điện… Vì thế, khả năng phát hiện lỗi, chống chịu lỗi và tự động phục hồi phải được tích hợp vào trong hệ thống HDFS. Thứ hai, do đặc thù lưu trữ dữ liệu có dung lượng lớn, HDFS được thiết kế để tối ưu cho bài toán lưu trữ các tập tin có kích thước lớn hàng GB, thậm chí TB. Để giải quyết bài toán này, dữ liệu của các tập tin lớn sẽ được chia nhỏ thành các khối lớn (ví dụ 64MB) và phân tán trên các nút lưu trữ. So với các hệ thống tập tin khác, HDFS không tối ưu cho bài toán lưu trữ hàng tỉ tập tin nhỏ với kích thước mỗi tập tin chỉ vài KB. Ưu điểm của thiết kế tập tin lớn là giảm tải cho hệ thống quản lý không gian tập tin, giảm thời gian thao tác trên các thư mục hay tìm kiếm tập tin. Thứ ba, HDFS ban đầu được thiết kế chỉ cho phép thay đổi nội dung các tập tin được lưu trữ qua phép toán thêm “append” dữ liệu vào cuối tập tin hơn là ghi đè lên dữ liệu hiện có. Việc ghi dữ liệu lên một vị trí ngẫu nhiên trong tập tin không được hỗ trợ. Một khi đã được tạo ra, các tập tin sẽ trở thành file chỉ đọc (read-only). Thiết kế này khác căn bản so với các hệ thống quản lý tập tin truyền thống do khác biệt về mục đích sử dụng. HDFS được thiết kế để tối ưu cho bài toán lưu trữ dữ liệu cho việc phân tích khi mà đầu vào có thể là các tập tin nhật ký logs hay dữ liệu liên tục đến từ các cảm biến. Với đầu vào dữ liệu này thì thao tác ghi ngẫu nhiên hay ghi đè dữ liệu là không cần thiết. Hơn nữa, đơn giản hóa hỗ trợ ghi dữ liệu cũng là nhân tố để HDFS tối ưu và tăng hiệu năng hệ thống. Ngày nay, Hadoop cluster và HDFS rất phổ biến trên thế giới. Nổi bật nhất là hệ thống của Yahoo với một cluster lên đến 1100 nút với dung lượng HDFS là 12 PB. Các công ty khác như Facebook, Adode, Amazon cũng đã xây dựng các cluster chạy HDFS với dung lượng hàng trăm, hàng nghìn TB.",
        "Summary": "HDFS (Hadoop Distributed File System) là một phần của Hadoop, một nền tảng của Apache để phân tích dữ liệu lớn trên nhiều máy chủ. HDFS được thiết kế để đối phó với các lỗi phần cứng thường xuyên xảy ra trong các cluster lớn, lưu trữ hiệu quả các tập tin có kích thước lớn bằng cách chia nhỏ chúng thành các khối và phân tán trên các nút lưu trữ. HDFS ban đầu được tối ưu hóa cho việc thêm dữ liệu vào cuối tập tin thay vì ghi đè, phù hợp với việc lưu trữ dữ liệu cho phân tích, chẳng hạn như nhật ký hoặc dữ liệu từ cảm biến. Hadoop và HDFS ngày càng phổ biến và được sử dụng rộng rãi trong các công ty lớn như Yahoo, Facebook, Adobe và Amazon.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc dễ dàng nắm bắt được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, thiết kế, ưu điểm và ứng dụng của HDFS."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác nội dung quan trọng của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00079",
        "Article": "Tương tự kiểm thử đơn vị, kiểm thử hệ thống cũng có bộ các ca kiểm thử cho từng chức năng. Mỗi ca kiểm thử chức năng thường mô tả từng bước thực hiện ở mức sử dụng phần mềm để hoàn thành một tác vụ nào đó. Mỗi bước thực hiện có thể có dữ liệu đầu vào, thao tác thực hiện, và kết quả mong đợi quan sát được tương ứng để người kiểm thử khi thực hiện từng bước này sẽ kiểm tra xem phần mềm hoạt động đúng không.Trước đây việc thực hiện kiểm thử này phải làm bằng tay, tốn rất nhiều chi phí, cả máy móc, thời gian và sức người. Tuy nhiên gần đây việc thực hiện này đang được tự động hóa ngày càng nhiều nhờ có các công cụ mạnh đang được chú trọng nghiên cứu và phát triển tích cực. Một ví dụ có thể kể đến là Selenium - một công cụ có thể thực hiện các ca kiểm thử tự động cho các ứng dụng trên nền Web. Người kiểm thử có thể thực hiện thao tác kiểm thử lần đầu và cho Selenium ghi lại các thao tác của mình dưới dạng các mã dễ đọc của Selenium. Sau đó các ca kiểm thử này được chạy lại tự động. Người kiểm thử có thể chỉnh sửa mã Selenium sinh ra cho phù hợp hơn với ý đồ của ca kiểm thử. Khi phải kiểm tra tính tương thích của ứng dụng trên nhiều trình duyệt khác nhau, hoặc khi phải chạy lại các ca kiểm thử thì công cụ này giúp giảm đáng kể công sức phải thực hiện lại.Việc xây dựng các ca kiểm thử chức năng được gọi là việc thiết kế kiểm thử. Các ca kiểm thử chức năng nên được thiết kế chỉ dựa trên đặc tả chức năng của phần mềm, độc lập với thiết kế và cài đặt của phần mềm. Cách làm này giúp phát hiện các lỗi trong thiết kế vì nếu dựa trên thiết kế có lỗi, các ca kiểm thử sẽ được xây dựng cho đúng với thiết kế chứ không đúng theo đặc tả chức năng. Tuy nhiên, việc thiết kế kiểm thử hoàn toàn độc lập này có thể lại không giúp phát hiện các vấn đề với thiết kế. Do đó, trên thực tế chúng ta cần cân đối sử dụng một mức độ thông tin trong thiết kế và cài đặt để thiết kế ca kiểm thử. Mức độ này là bao nhiêu phụ thuộc rất nhiều vào tính chất của từng dự án và kinh nghiệm của người thiết kế kiểm thử. Cuối cùng, kiểm thử hệ thống có thể sử dụng lại các ca kiểm thử mức thấp hơn như kiểm thử tích hợp, kiểm thử đơn vị.Một khía cạnh khác nữa với kiểm thử hệ thống là việc tổ chức thực hiện. Chúng ta để một đội vừa phát triển vừa thực hiện kiểm thử hệ thống hay để hai đội độc lập thực hiện hai việc riêng biệt? Khi thực hiện độc lập, khối lượng công việc tăng lên vì đội thực hiện phải đọc lại tài liệu và hiểu hệ thống mới có thể thực hiện kiểm thử. Nhưng sự khách quan này thường giúp phát hiện nhiều vấn đề trong hệ thống và kết quả cho phép kiểm thử chấp nhận dễ dàng vượt qua hơn. Nếu đội phát triển thực hiện kiểm thử hệ thống, yếu tố chủ quan sẽ giúp việc kiểm thử tập trung vào một số điểm yếu của hệ thống, tuy nhiên đội sẽ bị ảnh hưởng bởi những thông tin đã biết về thiết kế và cài đặt của hệ thống nên thiếu tính khách quan trong thiết kế và thực hiện kiểm thử. Để giảm sự ảnh hưởng chủ quan này, trong các dự án phát triển theo quy trình linh hoạt, người ta phát triển các ca kiểm thử hệ thống ngay từ đầu, trong quá trình thu thập yêu cầu và trong quá trình xây dựng hệ thống.",
        "Summary": "\"Kiểm thử hệ thống sử dụng các ca kiểm thử chức năng để mô tả các bước thực hiện tác vụ, dữ liệu đầu vào và kết quả mong đợi. Việc kiểm thử này đang được tự động hóa bằng các công cụ như Selenium, giúp giảm chi phí và công sức. Các ca kiểm thử nên được thiết kế dựa trên đặc tả chức năng, độc lập với thiết kế để phát hiện lỗi thiết kế, nhưng cần cân đối với thông tin thiết kế và cài đặt. Kiểm thử hệ thống có thể sử dụng lại các ca kiểm thử mức thấp hơn. Việc tổ chức thực hiện kiểm thử hệ thống có thể do đội phát triển hoặc một đội độc lập thực hiện, mỗi cách có ưu và nhược điểm riêng. Trong quy trình linh hoạt, ca kiểm thử hệ thống được phát triển từ sớm để giảm ảnh hưởng chủ quan.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể tìm thấy trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý quan trọng từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các khía cạnh chính của kiểm thử hệ thống, bao gồm ca kiểm thử chức năng, tự động hóa, thiết kế kiểm thử, sử dụng lại các ca kiểm thử mức thấp hơn và tổ chức thực hiện."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã nắm bắt được những ý chính của văn bản gốc và trình bày chúng một cách súc tích và dễ hiểu. Không có đề xuất cải thiện nào."
            }
        }
    },
    {
        "Index": "00080",
        "Article": "Hiệu quả của một mô hình còn phụ thuộc vào các yếu tố khác ngoài thuật toán học ra, đó là các Sự phân bố các phân tử trong một lớp hay số lƣợng các phần tử khác nhau trong mỗi lớp và sự phân bổ chúng trong các lớp khác nhau có ảnh hƣởng rất lớn đối với hiệu quả phân lớp của một mô hình Chi phí của sự phân sai lớp Kích cỡ của tập dữ liệu dùng để huấn luyện và tập dùng để kiểm thử Đƣờng cong học trong hình vẽ dƣới đây thể độ chính xác thay đổi thế nào khi kích cỡ của tập huấn luyện thay đổi. Để vẽ đƣợc đƣờng cong này, chúng ta cần một lịch lấy mẫu để thay đổi kích cỡ lấy mẫu bằng cách lấy mẫu số học hoặc lấy mẫu dạng hình học. Hiệu quả của kích cỡ lấy mẫu nhỏ thể hiện trong sự sai khác về ƣớc lƣợng, phƣơng sai trong ƣớc lƣợng Các phƣơng pháp ƣớc lƣợng Phƣơng pháp giữ lại một phần (holdout): dùng 2/3 số bản ghi của tập dữ liệu cho việc huấn luyện và 1/3 còn lại cho việc kiểm thử. Việc lựa chọn 2/3 lƣợng bản ghi nào là ngẫu Phƣơng pháp lấy mẫu con: là cách dùng lại phƣơng pháp giữ một phần trình bày ở trên Phƣơng pháp xác nhận chéo: o Chia dữ liệu thành k tập con không giaonhau o Lặp lại k lần công việc sau: huấn luyện mô hình trên k-1 tập con và kiểm thử mô hình trên tập con thứ k còn lại o Trong trƣờng hợp đặc biết k=n có nghĩa là tập dữ liệu đƣợc chia thành n tập con (n là số bản ghi trong tập dữ liệu), mỗi lần huấn luyện sẽ dùng n-1 bản ghi và kiểm thử trên bản ghi còn lại. Lặp công việc đó n lần cho toàn bộ bản ghi trong Phƣơng pháp lấy mẫu: dùng các tập con của tập dữ liệu thu đƣợc bằng cách áp dụng các phƣơng pháp lấy mẫu để huấn luyện và kiểm thử mô hình. Cần quan tâm tới các vấn đề lấy mẫu với số lƣợng quá nhiều hoặc quá ít, khiến cho chất lƣợng huấn luyện mô hình và Phƣơng pháp khởi động nhanh: là cách lấy mẫu nhƣng có thay thế Khái niệm về phân tích phân cụm Cụm là một tập hợp các đối tƣợng dữ liệu giống nhau theo một tiêu chí nào đó, hai đối tƣợng giống nhau thì nằm trong cùng một cụm, hai đối tƣợng khác nhau thì nằm ở hai cụm khác nhau. Việc phân cụm các điểm thành 3 cụm (màu đỏ, màu tím và màu xanh) đƣợc mô tả trong hình dƣới đây trong đó chúng ta thấy khoảng cách giữa các phần tử trong cùng một cụm đƣợc tối thiểu hóa, còn khoảng cách giữa hai phần tử trong hai cụm khác nhau cần đƣợc tối đa hóa.",
        "Summary": "Việc lựa chọn 23 lƣợng bản ghi nào là ngẫu Phƣơng pháp lấy mẫu con là cách dùng lại phƣơng pháp giữ một phần trình bày ở trên Phƣơng pháp xác nhận chéo o Chia dữ liệu thành k tập con không giaonhau o Lặp lại k lần công việc sau huấn luyện mô hình trên k-1 tập con và kiểm thử mô hình trên tập con thứ k còn lại o Trong trƣờng hợp đặc biết kn có nghĩa là tập dữ liệu đƣợc chia thành n tập con n là số bản ghi trong tập dữ liệu, mỗi lần huấn luyện sẽ dùng n-1 bản ghi và kiểm thử trên bản ghi còn lại.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt trích dẫn trực tiếp một số câu từ trong văn bản gốc, nhưng không phải là một bản tóm tắt đầy đủ và chính xác. Các câu được trích dẫn không bị sai lệch so với văn bản gốc, tuy nhiên, việc lựa chọn các câu này có vẻ ngẫu nhiên và không phản ánh đầy đủ nội dung chính của văn bản gốc."
            },
            "Tính mạch lạc": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt thiếu mạch lạc. Các câu trích dẫn được liệt kê một cách rời rạc, không có sự liên kết logic rõ ràng giữa chúng. Điều này khiến cho người đọc khó hiểu được ý nghĩa tổng thể mà bản tóm tắt muốn truyền đạt."
            },
            "Tính liên quan": {
                "Điểm": 2,
                "Đánh giá": "Bản tóm tắt chỉ tập trung vào một phần nhỏ của văn bản gốc (các phương pháp lấy mẫu) và bỏ qua nhiều ý chính khác như các yếu tố ảnh hưởng đến hiệu quả của mô hình, khái niệm phân tích phân cụm. Do đó, tính liên quan của bản tóm tắt là khá thấp."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt này có chất lượng kém. Nó thiếu tính trung thực (do không bao quát được nội dung chính), tính mạch lạc (do các ý không liên kết với nhau) và tính liên quan (do bỏ qua nhiều thông tin quan trọng). Để cải thiện, cần tóm tắt đầy đủ hơn các ý chính của văn bản gốc, sắp xếp các ý một cách logic và đảm bảo sự liên kết giữa chúng."
            }
        }
    },
    {
        "Index": "00081",
        "Article": "b. Ghép kênh dòng chương trình & dòng truyền tải MPEG\n Dòng ghép kênh: Lớp hệ thống MPEG-2 mô tả cách thức các dòng sơ cấp của một\n chương trình hay của nhiều chương trình được ghép chung với nhau tạo ra một dòng số\n liệu thích hợp cho lưu trữ số hay truyền dẫn số.\n Chuẩn nén MPEG-2 được thiết kế cho tốc độ bit lớn hơn 4Mb/s. Tín hiệu video và audio\n được nén, xử lý đóng gói và ghép kênh tạo thành các dòng dữ liệu với tốc độ mong muốn.\n Các thông tin cần thiết sử dụng trong ghép kênh gồm:\n · Hệ thống các nhãn thời gian (Time - Stamp TS): Sử dụng để đảm bảo các dòng sơ\n cấp liên kết được phát lại một cách đồng bộ tại bộ giải mã.\n · Các bảng thông tin dịch vụ (Service Information): Mô tả các chi tiết về thông số\n mạng, về các chương trình đang được ghép kênh và về bản chất của các dòng sơ\n cấp khác nhau.\n · Các thông tin điều khiển việc xáo trộn (Scrambling) số liệu, các thông tin dùng để\n truy cập có điều kiện CA (Conditional Access).\n · Các kênh số liệu riêng (private data): Số liệu riêng là dòng số liệu mà nội dung\n của nó không được quy định bởi tiêu chuẩn MPEG. Ở MPEG đạt được sự đồng bộ thông qua việc sử dụng nhãn thời gian tần số và chuẩn\n đồng hồ (Clock system-CS).\n Ghép kênh dòng chương trình (Program stream-PS)\n Được thiết kế cho môi trường không có tạp nhiễu, một dòng chương trình là kết quả của\n ghép kênh một vài dòng cơ sở của một chương trình dùng chung một xung nhịp, bao gồm\n các gói PES có độ dài thay đổi. Dòng dữ liệu sau ghép kênh chứa dòng bit điều khiển bởi\n miêu tả chương trình. Dòng chương trình thường ứng dụng trên đĩa CD-ROM, DVD, HDDVD Như vậy, theo cách thức này:\n · Bộ mã hóa video mã hóa tín hiệu video số định dạng CCIR - 601 thành dòng sơ\n cấp video (video ES) có chiều dài gần như vô tận và chỉ chứa những thông tin tối\n cần thiết để có thể khôi phục lại hình ảnh ban đầu.\n · Bộ mã hóa audio mã hóa tín hiệu audio số định dạng AES/EBU thành dòng sơ cấp\n audio có chiều dài tùy ý (tần số lấy mẫu 48KHz, số bit mẫy 24 bit và tốc độ bit là\n 1152 Kbit/s).\n · Ban đầu, các dòng video, audio được đóng gói lại thành các dòng sơ cấp PES\n tương ứng với các gói có độ dài thay đổi. Mỗi gói PES bao gồm một header và\n một số liệu trích ra từ dòng sơ cấp.\n · Các gói PES lại được ghép với nhau tạo ra dòng chương trình PS.\n Dòng chương trình chỉ được thiết kế để truyền trong môi trường không có tạp nhiễu và\n sai nhầm, ví dụ như trong các ứng dụng CD – ROM vì hai nguyên nhân sau:\n · Dòng chương trình bao gồm các gói tương đối dài nối tiếp nhau và độ dài này lại\n luôn thay đổi. Mỗi gói bắt đầu bằng một tiêu đề (header). Mỗi lỗi xảy ra trong\n phần tiêu đề có thể làm mất thông tin của toàn gói. Vì các gói của chương trình có\n thể chứa vài chục Kbyte số liệu nên sự mất mát thông tin của một gói có thể làm\n mất hoặc gián đoạn cả một khung ảnh.\n · Độ dài gói không cố định khiến cho bộ giải mã không dự đoán được khi nào gói\n chấm dứt và khi nào gói mới bắt đầu. Thay vào đó, bộ giải mã đọc và dịch lại bộ\n thông tin về độ dài gói chứa trong mỗi tiêu đề, nếu thông tin về độ dài gói này bị\n lỗi, bộ giải mã sẽ mất đồng bộ và như vậy sẽ làm mất thông tin ít nhất là một gói.",
        "Summary": "Ghép kênh trong MPEG-2 kết hợp các dòng sơ cấp của một hoặc nhiều chương trình thành một dòng dữ liệu duy nhất, phù hợp cho lưu trữ hoặc truyền dẫn. Quá trình này sử dụng nhãn thời gian để đồng bộ hóa, bảng thông tin dịch vụ để mô tả chi tiết chương trình và mạng, thông tin điều khiển xáo trộn, và các kênh dữ liệu riêng. Ghép kênh dòng chương trình (PS) được thiết kế cho môi trường không nhiễu, ghép các dòng cơ sở của một chương trình sử dụng chung xung nhịp thành các gói PES có độ dài thay đổi, thường dùng trên CD-ROM, DVD. Tuy nhiên, PS dễ bị lỗi do độ dài gói thay đổi và tiêu đề gói dễ bị hỏng, gây mất đồng bộ và gián đoạn dữ liệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Người đọc có thể dễ dàng hiểu được nội dung chính của văn bản gốc."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào định nghĩa, các yếu tố sử dụng trong ghép kênh, đặc điểm và hạn chế của ghép kênh dòng chương trình (PS)."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã nắm bắt được đầy đủ các ý chính của văn bản gốc và trình bày chúng một cách súc tích, dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00082",
        "Article": "Kỹ thuật phân trang loại bỏ được hiện tượng phân mảnh ngoại vi vì mỗi khung trang đều có thể được cấp phát cho một tiến trình có yêu cầu. Tuy nhiên, phân mảnh nội vi vẫn có thể xảy ra nếu kích thước của tiến trình không đúng bằng bội số của kích thước một trang, dẫn đến trang cuối cùng không được sử dụng hết. Một lợi ích quan trọng của phân trang là sự phân biệt rõ ràng giữa góc nhìn của người dùng và bộ phận quản lý bộ nhớ vật lý. Đối với người dùng, bộ nhớ được nhìn nhận như một không gian liên tục, đồng nhất và chỉ chứa duy nhất tiến trình của họ. Trong khi đó, từ góc độ bộ nhớ vật lý, tiến trình của người dùng được lưu trữ phân tán khắp bộ nhớ cùng với các tiến trình khác. Phần cứng chịu trách nhiệm chuyển đổi địa chỉ logic thành địa chỉ vật lý, quá trình này hoàn toàn trong suốt đối với người sử dụng. Hệ điều hành duy trì một bảng khung trang để lưu trữ thông tin về tình trạng bộ nhớ vật lý, mỗi phần tử trong bảng mô tả trạng thái của một khung trang, có thể là đang tự do hoặc đã được cấp phát cho một tiến trình. Tuy nhiên, phân trang không phản ánh đúng cách thức người dùng cảm nhận về bộ nhớ. Người dùng thường tổ chức bộ nhớ thành các đối tượng chương trình như các đoạn mã (segments), thư viện, cũng như các đối tượng dữ liệu như biến toàn cục, stack, và vùng nhớ chia sẻ. Kỹ thuật phân đoạn giúp thể hiện cấu trúc logic của chương trình một cách tốt hơn, nhưng lại gây ra vấn đề phải cấp phát bộ nhớ với kích thước không cố định, phức tạp hơn so với cấp phát các trang có kích thước cố định trong phân trang. Một giải pháp dung hòa là kết hợp cả hai kỹ thuật bằng cách phân trang các phân đoạn. Điều này giúp tận dụng lợi ích của cả hai phương pháp: giữ được cấu trúc logic của chương trình trong phân đoạn, đồng thời tránh được vấn đề phân mảnh ngoại vi bằng cách phân trang từng phân đoạn.",
        "Summary": "Phân trang loại bỏ phân mảnh ngoại vi nhưng có thể gây phân mảnh nội vi nếu trang cuối không được sử dụng hết, đồng thời tách biệt góc nhìn của người dùng và bộ nhớ vật lý. Phân đoạn phản ánh cấu trúc logic của chương trình tốt hơn nhưng phức tạp trong cấp phát bộ nhớ. Kết hợp phân trang và phân đoạn giúp tận dụng ưu điểm của cả hai, giữ cấu trúc logic và tránh phân mảnh ngoại vi.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt súc tích giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào ưu nhược điểm của phân trang, phân đoạn và giải pháp kết hợp, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan, thể hiện đầy đủ các ý chính của văn bản gốc một cách súc tích và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00083",
        "Article": "Tại sao phải đổi trang Khi xẩy ra thiếu trang hệ điều hành tìm một khung trống trong bộ nhớ đọc trang thiếu vào khung và tiến trình sau đó hoạt động bình thường Tuy nhiên do kích thước của các tiến trình có thể lớn hơn kích thước bộ nhớ thực rất nhiều nên tới một lúc nào đó sẽ xảy ra tình trạng toàn bộ bộ nhớ đã được cấp phát hệ điều hành không thể tìm được khung trống để tải trang mới vào Cách giải quyết đơn giản nhất trong trường hợp đó là hệ điều hành kết thúc tiến trình do không thoả mãn được nhu cầu bộ nhớ Nhưng như ta đã biết mục đích của bộ nhớ ảo là cho phép các tiến trình sử dụng được không gian nhớ lớn hơn không gian nhớ thực và tăng tính đa chương trình của hệ thống Tiến trình và người dùng cần được đáp ứng nhu cầu về bộ nhớ Cách giải quyết thứ hai là tạm trao đổi tiến trình ra đĩa giải phóng toàn bộ không gian mà tiến trình chiếm trong bộ nhớ và chờ tới khi thuận lợi nhiều bộ nhớ trống hơn mới nạp lại tiến trình vào bộ nhớ để thực hiện tiếp Cách giải quyết này là cần thiết trong một số trường hợp Tuy nhiên nếu tất cả các tiến trình đều được đưa ra đĩa khi thiếu bộ nhớ thì hệ thống sẽ rơi vào tình trạng mất quá nhiều thời gian cho việc trao đổi tiến trình mà không thực sự thực hiện được công việc nào Cách giải quyết thứ ba được áp dụng trong đa số trường hợp Đó là sử dụng kỹ thuật đổi trang Kỹ thuật này cho phép thay thế một trang hiện có trong bộ nhớ bằng trang mới mà tiến trình cần truy cập mà không cần phải dừng tiến trình hoặc trao đổi toàn bộ tiến trình ra đĩa Để thực hiện điều này hệ điều hành cần một thuật toán quyết định trang nào sẽ bị thay thế Khi một trang được thay thế hệ điều hành kiểm tra xem trang đó đã được sửa đổi hay chưa Nếu chưa trang có thể bị ghi đè ngay lập tức Nếu đã bị sửa đổi thì trước khi thay thế hệ điều hành cần ghi nội dung của trang đó trở lại đĩa để đảm bảo dữ liệu không bị mất Do vậy lựa chọn trang nào để thay thế là một yếu tố quan trọng quyết định hiệu suất của hệ thống Các thuật toán thay thế trang sẽ được trình bày chi tiết trong các phần sau",
        "Summary": "Khi xảy ra thiếu trang, hệ điều hành tìm khung trống trong bộ nhớ để nạp trang mới. Nếu bộ nhớ đầy, hệ điều hành có thể kết thúc tiến trình, nhưng mục tiêu của bộ nhớ ảo là cho phép tiến trình sử dụng bộ nhớ lớn hơn bộ nhớ thực. Một giải pháp phổ biến là sử dụng kỹ thuật đổi trang, cho phép thay thế trang hiện có bằng trang mới mà không dừng tiến trình, với điều kiện dữ liệu trong trang phải được lưu lại đĩa nếu cần. Việc lựa chọn trang để thay thế ảnh hưởng lớn đến hiệu suất hệ thống.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự sai lệch hoặc thêm thông tin mới."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, dễ hiểu. Các câu liên kết với nhau một cách tự nhiên, tạo thành một dòng chảy thông tin liên tục."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về vấn đề đổi trang khi thiếu bộ nhớ, các giải pháp và tầm quan trọng của việc lựa chọn trang để thay thế. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00084",
        "Article": "Trong lập trình Arduino, biến số và hằng số là hai khái niệm cơ bản và quan trọng. Hằng số là các giá trị không thay đổi trong suốt quá trình thực thi chương trình. Các hằng số phổ biến trong Arduino bao gồm HIGH, LOW, INPUT, INPUT_PULLUP, OUTPUT, LED_BUILTIN, true, false, cũng như các hằng số nguyên và thực như số nguyên (integer constants) và số thực (floating point constants). Các hằng số này giúp cho việc lập trình dễ dàng hơn, đảm bảo tính rõ ràng và chính xác của mã lệnh. Kiểu dữ liệu trong Arduino rất đa dạng, bao gồm void, boolean, char, unsigned char, byte, int, unsigned int, word, long, unsigned long, short, float, double, array, string và String (object). Mỗi kiểu dữ liệu này phục vụ một mục đích khác nhau trong việc xử lý thông tin và tương tác với các thành phần phần cứng. Arduino cũng hỗ trợ chuyển đổi kiểu dữ liệu qua các hàm như char(), byte(), int(), word(), long(), và float(), giúp chuyển đổi giữa các kiểu dữ liệu khác nhau khi cần thiết. Phạm vi của biến được phân loại thành các loại như static (biến tĩnh), const (biến hằng) và volatile, với mỗi loại có một mục đích sử dụng riêng biệt trong việc quản lý bộ nhớ và hiệu suất của chương trình. Để hỗ trợ việc lập trình hiệu quả, Arduino cung cấp một số hàm hỗ trợ như sizeof() để xác định kích thước của dữ liệu. Hàm và thủ tục trong Arduino được chia thành các nhóm chức năng khác nhau như nhập xuất digital (pinMode(), digitalWrite(), digitalRead()), nhập xuất analog (analogReference(), analogRead(), analogWrite()), và các hàm thời gian như millis(), micros(), delay(), delayMicroseconds(). Các hàm toán học cơ bản như min(), max(), abs(), map(), pow(), sqrt() cũng rất hữu ích, cùng với các hàm lượng giác như cos(), sin(), tan(), asin() và các hàm xử lý chuỗi, số ngẫu nhiên, và giao tiếp như tone(), noTone(), shiftOut(), shiftIn(), pulseIn(). Các hàm ngắt và giao tiếp serial cũng hỗ trợ việc tương tác giữa các mạch Arduino và các thiết bị ngoại vi",
        "Summary": "Trong lập trình Arduino, biến số và hằng số là những khái niệm quan trọng, với hằng số có giá trị không thay đổi trong suốt chương trình. Arduino hỗ trợ nhiều kiểu dữ liệu khác nhau, bao gồm int, float, và string, cùng với các hàm chuyển đổi kiểu dữ liệu và xác định kích thước dữ liệu. Ngoài ra, Arduino cung cấp nhiều hàm hỗ trợ cho các chức năng như nhập xuất số, toán học, thời gian, và giao tiếp, giúp việc lập trình và tương tác với phần cứng hiệu quả hơn.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại các ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Bản tóm tắt tập trung vào các khái niệm cơ bản và các hàm hỗ trợ chính trong lập trình Arduino."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Tóm tắt trung thực, mạch lạc và liên quan đến nội dung chính của văn bản gốc. Bản tóm tắt đã làm nổi bật được những điểm quan trọng nhất về biến, hằng, kiểu dữ liệu và các hàm hỗ trợ trong lập trình Arduino. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00085",
        "Article": "Các chương trình thường cần phải lặp đi lặp lại một hoạt động nào đó. Ví dụ, một chương trình xếp loại học lực sẽ chứa các lệnh rẽ nhánh để gán xếp loại A, B, C… cho một sinh viên tùy theo điểm số của sinh viên này. Để xếp loại cho cả một lớp, chương trình sẽ phải lặp lại thao tác đó cho từng sinh viên trong lớp. Phần chương trình lặp đi lặp lại một lệnh hoặc một khối lệnh được gọi là một vòng lặp. Lệnh hoặc khối lệnh được lặp đi lặp lại được gọi là thân của vòng lặp. Cấu trúc lặp cho phép lập trình viên chỉ thị cho chương trình lặp đi lặp lại một hoạt động trong khi một điều kiện nào đó vẫn được thỏa mãn. Khi thiết kế một vòng lặp, ta cần xác định thân vòng lặp thực hiện hành động gì. Ngoài ra, ta còn cần một cơ chế để quyết định khi nào vòng lặp sẽ kết thúc. Mục này sẽ giới thiệu về các lệnh lặp mà Java cung cấp. Vòng while Vòng while lặp đi lặp lại chuỗi hành động, gọi là thân vòng lặp, nếu như điều kiện lặp vẫn còn được thỏa mãn. Cú pháp của vòng lặp while như sau: while (điều_kiện_lặp) thân_vòng_lặp Cấu trúc này bắt đầu bằng từ khóa while, tiếp theo là điều kiện lặp đặt trong một cặp ngoặc đơn, cuối cùng là thân vòng lặp. Thân vòng lặp hay chứa nhiều hơn một lệnh và khi đó thì phải được gói trong một cặp ngoặc à â. Khi thực thi một cấu trúc while, đầu tiên chương trình kiểm tra giá trị của biểu thức điều kiện, nếu biểu thức cho giá trị false thì nhảy đến điểm kết thúc lệnh while, còn nếu điều kiện lặp có giá trị true thì tiến hành thực hiện tập lệnh trong thân vòng lặp rồi quay trở lại kiểm tra điều kiện lặp, nếu không thỏa mãn thì kết thúc, nếu thỏa mãn thì lại thực thi thân vòng lặp rồi quay lại... Tập lệnh ở thân vòng lặp có thể làm thay đổi giá trị của biểu thức điều kiện từ true sang false để dừng vòng lặp.",
        "Summary": "Đoạn văn mô tả cấu trúc vòng lặp trong lập trình, đặc biệt là vòng lặp `while` trong Java. Vòng lặp `while` thực hiện lặp lại một khối lệnh (thân vòng lặp) cho đến khi điều kiện kiểm tra trở thành `false`. Cú pháp bao gồm từ khóa `while`, điều kiện trong ngoặc đơn và thân vòng lặp. Thân vòng lặp cần được thiết kế để điều kiện kiểm tra cuối cùng trở nên sai, đảm bảo vòng lặp kết thúc. Java cung cấp các cấu trúc lặp để xử lý các thao tác lặp đi lặp lại hiệu quả.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào định nghĩa vòng lặp, cấu trúc `while` và cách thức hoạt động của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00086",
        "Article": "Hình 9.5: Giao diện hiễn thịmã nguồn và đồthịdòng điều khiển. Công cụkiểm thửcho các đơn vịchương trình viết bằng Java, JUnit4, cung cấp một cơ sởhạtầng chuẩn cho việc thiết lập các bộkiểm thử. Một khi bộ kiểm thửđược thiết lập, nó có thểtựđộng chạy mỗi khi mã thay đổi. JUnit khuyến khích các nhà phát triển viết các kịch bản kiểm thử, chèn các mã kiểm thửvào mã nguồn Java và thực hiện chúng đểphát hiện các lỗi bên trong đơn vịchương trình. Khác với các công cụkhác, JUnit không hỗtrợ cơ chếsinh các ca kiểm thử. Hiện nay, JUnit đã được tích hợp trong Eclipse và hỗtrợrất đắc lực cho quá trình kiểm thử. 9.3. MỘT SỐCÔNG CỤKIỂM THỬTỰĐỘNG Hình 9.6: Báo cáo kiểm thửđược sinh bởi công cụJDFT. Quick Test Professional5 là phần mềm kiểm soát việc kiểm thửtựđộng các chức năng của các sản phẩm phần mềm cần kiểm thử. Sản phẩm này bao gồm một tập các mô-đun có thểtương tác với nhau nhằm quản lý toàn bộ quy trình kiểm thửphần mềm. Quick Test Professional là một công cụhỗ trợkiểm thửhàm (kiểm thửchức năng) và cho phép tiến hành kiểm thửhồi Apache JMeter6 được dùng đểkiểm thửkhảnăng chịu tải và kiểm thửhiệu năng cho các ứng dụng Web và một sốứng dụng khác. Công cụnày hỗtrợ kiểm thửhiệu năng của các mã nguồn được viết bằng các ngôn ngữkhác nhau như PHP, Java, ASP.NET, . . . Apache JMeter mô phỏng khảnăng chịu tải của các máy chủtrên máy sửdụng đểkiểm thửhệthống. Công cụ này hỗtrợgiao diện đồhọa giúp phân tích tốt hiệu suất khi kiểm thửđồng thời nhiều ca kiểm thử. Ngoài ra, Apache JMeter còn hỗtrợthêm nhiều tiện ích khác. Các tiện ích này được cung cấp tại 7. Load Runner8 giảlập một môi trường ảo gồm nhiều người dùng thực hiện các giao dịch cùng một lúc nhằm giám sát các thông sốxửlý của phần mềm cần kiểm thử.",
        "Summary": "Công cụkiểm thửcho các đơn vịchương trình viết bằng Java, JUnit4, cung cấp một cơ sởhạtầng chuẩn cho việc thiết lập các bộkiểm thử. Sản phẩm này bao gồm một tập các mô-đun có thểtương tác với nhau nhằm quản lý toàn bộ quy trình kiểm thửphần mềm. Quick Test Professional là một công cụhỗ trợkiểm thửhàm kiểm thửchức năng và cho phép tiến hành kiểm thửhồi Apache JMeter6 được dùng đểkiểm thửkhảnăng chịu tải và kiểm thửhiệu năng cho các ứng dụng Web và một sốứng dụng khác.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Các câu được liên kết với nhau một cách rõ ràng. Tuy nhiên, có thể cải thiện bằng cách sử dụng các từ nối để tăng tính trôi chảy giữa các ý."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến nội dung chính của văn bản gốc, tập trung vào các công cụ kiểm thử. Tuy nhiên, có thể lược bỏ bớt một vài chi tiết nhỏ để bản tóm tắt ngắn gọn và tập trung hơn vào các ý chính."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, đảm bảo tính trung thực và liên quan. Tuy nhiên, cần chú ý hơn đến tính mạch lạc và loại bỏ một số chi tiết thừa để bản tóm tắt trở nên súc tích và hiệu quả hơn."
            }
        }
    },
    {
        "Index": "00087",
        "Article": "Quá trình chơi cờ là quá trình mà Trắng và Đen thay phiên nhau đưa ra các nước đi hợp lệ cho đến khi dẫn đến trạng thái kết thúc cuộc chơi. Quá trình này biểu diễn bởi đường đi từ nút gốc tới nút lá trên cây trò chơi. Giả sử tại một đỉnh u nào đó trên đường đi, nếu u là đỉnh Trắng (Đen) thì cần chọn một nước đi nào đó đến một trong các đỉnh con Đen (Trắng) v của u. Tại đỉnh Đen (Trắng) v sẽ chọn đi tiếp đến một đỉnh con Trắng (Đen) w của v. Quá trình này tiếp tục cho đến khi đạt đến một đỉnh lá của cây. Chiến lược tìm nước đi của Trắng hay Đen là luôn tìm những nước đi dẫn tới trạng thái tốt nhất cho mình và tồi nhất cho đối thủ. Giả sử Trắng cần tìm nước đi tại đỉnh u, nước đi tối ưu cho Trắng là nước đi dẫn tới đỉnh con v sao cho v là tốt nhất trong số các đỉnh con của u. Đến lượt Đen chọn nước đi từ v, Đen cũng chọn nước đi tốt nhất cho mình. Để chọn nước đi tối ưu cho Trắng tại đỉnh u, cần xác định giá trị các đỉnh của cây trò chơi gốc u. Giá trị của các đỉnh lá ứng với giá trị của hàm kết cuộc. Đỉnh có giá trị càng lớn càng tốt cho Trắng, đỉnh có giá trị càng nhỏ càng tốt cho Đen. Để xác định giá trị các đỉnh của cây trò chơi gốc u, ta đi từ mức thấp nhất (các đỉnh lá) lên gốc u. Giả sử cần xác định giá trị của đỉnh v mà các đỉnh con của nó đã xác định. Khi đó, nếu v là đỉnh Trắng thì giá trị của nó là giá trị lớn nhất trong các đỉnh con, nếu v là đỉnh Đen thì giá trị của nó là giá trị nhỏ nhất trong các đỉnh con.",
        "Summary": "Quá trình chơi cờ được mô tả qua việc Trắng và Đen thay phiên nhau chọn nước đi hợp lệ, tiếp tục cho đến khi đạt trạng thái kết thúc. Chiến lược của mỗi người là chọn nước đi tốt nhất cho mình và tồi nhất cho đối thủ. Để xác định nước đi tối ưu tại mỗi đỉnh, ta tính giá trị của các đỉnh lá dựa trên hàm kết cuộc và đi ngược từ các lá lên gốc. Đỉnh của Trắng sẽ có giá trị lớn nhất trong các đỉnh con, còn đỉnh của Đen có giá trị nhỏ nhất.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Mọi thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết chặt chẽ với nhau, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào những ý chính của văn bản gốc, loại bỏ các chi tiết không cần thiết và giữ lại những thông tin quan trọng nhất để truyền tải thông điệp cốt lõi."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, đáp ứng đầy đủ các tiêu chí đánh giá. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00088",
        "Article": "2.2.3 Phần cứng cảm biến\n Một tổ chức muốn thực hiện giám sát an toàn mạng một cách thực sự nghiêm túc thì cần phải\n đầu tư vào phần cứng tin cậy, và phần cứng cho các cảm biến ở đây nên thuộc cấp độ của máy\n chủ (những loại khác thường chỉ được chấp nhận với kịch bản phòng thí nghiệm). Các yếu tố kỹ\n thuật cần thiết để xác định số lượng tài nguyên phần cứng cần thiết bao gồm các loại cảm biến\n được triển khai, số lượng dữ liệu được thu thập bởi các cảm biến, và số lượng dữ liệu cần được\n lưu giữ.\n Có một cách được sử dụng để xác định các yêu cầu phần cứng quan trọng của cảm biến là\n thiết lập và cấu hình một cảm biến tạm thời. Cảm biến này có thể là một máy chủ, máy trạm hoặc\n thậm chí là một máy tính xách tay. Vị trí của cảm biến cũng cần được xác định trước khi các cảm\n biến này được cài đặt, bao gồm cả vị trí vật lý và vị trí logic để xác định những gì mà các cảm\n biến trên mạng cần phải theo dõi.\n Sau khi các cảm biến tạm thời được cài đặt trên mạng, cần sử dụng một cổng SPAN (SPAN\n port) hoặc một bộ trích dữ liệu mạng (network tap) để dẫn lưu lượng dữ liệu vào thiết bị. Sau đó,\n có thể cài đặt các công cụ thu thập dữ liệu, phát hiện xâm nhập và phân tích dữ liệu vào các cảm\n biến để xác định các yêu cầu về hiệu suất của các công cụ riêng lẻ. Chú ý là không nhất thiết phải\n có một cảm biến tạm thời rất mạnh có khả năng xử lý tất cả những công cụ này khi chúng được\n kích hoạt đồng thời, mà chỉ cần kích hoạt các công cụ riêng để tính toán tải trọng hoạt động của\n nó, và sau đó sẽ tổng hợp kết quả từ tất cả các công cụ để đánh giá nhu cầu tổng thể.",
        "Summary": "Để giám sát an toàn mạng hiệu quả, tổ chức cần đầu tư vào phần cứng cảm biến cấp máy chủ. Để xác định yêu cầu phần cứng, nên thiết lập cảm biến tạm thời (máy chủ, máy trạm, laptop) ở vị trí vật lý và logic phù hợp để theo dõi mạng. Sử dụng cổng SPAN hoặc network tap để dẫn lưu lượng dữ liệu vào cảm biến tạm thời, sau đó cài đặt và kích hoạt riêng lẻ các công cụ thu thập, phát hiện xâm nhập và phân tích dữ liệu để đánh giá yêu cầu hiệu suất của từng công cụ, rồi tổng hợp kết quả để xác định nhu cầu phần cứng tổng thể.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có bất kỳ sự sai lệch hoặc thêm thông tin nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, theo đúng trình tự trong văn bản gốc. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng theo dõi và hiểu nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về yêu cầu phần cứng cho cảm biến trong giám sát an toàn mạng và phương pháp xác định các yêu cầu này. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, tóm gọn được các ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00089",
        "Article": "Dịch vụ chia sẻ và quản lý tập tin là một phần quan trọng trong việc quản lý tài nguyên trên hệ thống mạng. Với Windows Server, người quản trị có thể dễ dàng chia sẻ các thư mục và tài nguyên giữa các người dùng, đồng thời kiểm soát quyền truy cập và bảo mật của các tài nguyên này. Để chia sẻ một thư mục dùng chung, người quản trị cần đăng nhập với quyền quản trị (Administrators) hoặc là thành viên nhóm Server Operators. Sau đó, trong Windows Explorer, người quản trị chỉ cần nhấp chuột phải vào thư mục muốn chia sẻ, chọn Properties, và trong hộp thoại xuất hiện, chọn tab Sharing để cấu hình chia sẻ thư mục. Quá trình này cho phép các người dùng trên mạng truy cập và sử dụng thư mục một cách dễ dàng. Khi thiết lập chia sẻ thư mục, người quản trị cần cấu hình Share Permissions để cấp quyền cho các người dùng truy cập qua mạng. Share Permissions chỉ có hiệu lực khi người dùng truy cập qua mạng, không ảnh hưởng khi người dùng truy cập trực tiếp vào hệ thống. Các quyền chia sẻ bao gồm Full Control (toàn quyền quản lý thư mục), Change (thay đổi dữ liệu và xóa tập tin trong thư mục), và Read (chỉ đọc và thực thi các tập tin trong thư mục). Để cấp quyền, người quản trị cần nhấn Add, chọn người dùng hoặc nhóm và sau đó đánh dấu vào các quyền phù hợp. Trong môi trường mạng với số lượng người dùng lớn, việc quản lý các thư mục chia sẻ có thể gặp phải các vấn đề về hiệu suất và bảo mật. Để giải quyết vấn đề này, Windows Server cung cấp công cụ Computer Management, giúp người quản trị dễ dàng theo dõi và quản lý các thư mục đang được chia sẻ. Trong công cụ này, menu Shares hiển thị danh sách các thư mục chia sẻ, đường dẫn và thông tin liên quan như số lượng client kết nối. Các thư mục có dấu $ ở cuối là các thư mục chia sẻ ẩn. Ngoài ra, công cụ quản lý còn cho phép theo dõi các Sessions, hiển thị thông tin về người dùng đang truy cập vào thư mục chia sẻ, bao gồm tên tài khoản, máy tính đang kết nối, hệ điều hành sử dụng và thời gian kết nối. Menu Open Files giúp hiển thị các tập tin đang được mở trong thư mục chia sẻ, đồng thời cung cấp thông tin về trạng thái của các tập tin như có đang bị khóa hay không và liệu người dùng có quyền Read hay Write tập tin. Tóm lại, dịch vụ chia sẻ và quản lý tập tin trên Windows Server cung cấp các công cụ mạnh mẽ để quản lý tài nguyên mạng hiệu quả, đảm bảo bảo mật và tối ưu hiệu suất hệ thống.",
        "Summary": "Dịch vụ chia sẻ và quản lý tập tin trên Windows Server cho phép người quản trị dễ dàng chia sẻ tài nguyên và kiểm soát quyền truy cập. Người quản trị có thể chia sẻ thư mục bằng cách cấu hình Share Permissions để cấp quyền truy cập qua mạng. Các quyền chia sẻ gồm Full Control, Change và Read. Công cụ Computer Management giúp quản lý hiệu quả các thư mục chia sẻ, theo dõi các kết nối client và hiển thị các phiên làm việc, tập tin mở, cũng như trạng thái của các tập tin. Tóm lại, dịch vụ này giúp quản lý tài nguyên mạng, bảo mật và tối ưu hiệu suất hệ thống.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào các khía cạnh quan trọng của dịch vụ chia sẻ và quản lý tập tin trên Windows Server."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan về dịch vụ chia sẻ và quản lý tập tin trên Windows Server. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00090",
        "Article": "Để hạn chế không gian tìm kiếm lời giải của bài toán, chúng ta biểu diễn KB và q bằng chỉ các câu dạng chuẩn hội (xem mục 4), khi đó chúng ta chỉ cần áp dụng một loại luật là luật phân giải trên KB và mỗi phép chuyển là một phép phân giải hai câu có chứa ít nhất một literal là phủ định của nhau trong KB, kết quả của phép phân giải hai câu dạng chuẩn hội lại là một câu dạng chuẩn hội và được bổ sung vào KB, lặp lại áp dụng luật phân giải trên KB đến khi nào KB chứa câu q thì dừng. Chi tiết thuật toán suy diễn dựa trên luật phân giải KB╞ q được trình bày trong mục 7 của Chương này (thực tế thì thuật toán suy diễn phân giải trả lời bài toán tương đương (KB ∧ ¬q)╞ [].) Giải thuật suy diễn phân giải là giải thuật đầy đủ trong logic mệnh đề, tức là với mọi câu q mà kéo theo được từ KB (q đúng khi KB đúng) thì sử dụng giải thuật suy diễn phân giải đều có thể suy diễn được KB ╞ q (tức là không có câu nào kéo được từ KB là không suy diễn phân giải được); bởi vì bất cứ câu trong logic mệnh đề đều có thể biểu diễn được bằng câu dạng chuẩn hội (xem mục 4). Do liên tục phải bổ sung các câu mới vào KB và lặp lại tìm kiếm các cặp câu có thể phân giải với nhau được nên nhân tố nhánh của cây tìm kiếm lời giải tăng dần theo độ sâu của cây tìm kiếm. Vì vậy không gian và thời gian của giải thuật sẽ tăng rất nhanh, giải thuật phân giải làm việc không hiệu quả. Để khắc phục nhược điểm này, người ta tìm cách biểu diễn KB dạng các câu Horn và áp dụng chỉ một loại luật (tam đoạn luận, xem mục 5) để suy diễn (tam đoạn luận áp dụng trên 2 câu dạng Horn và sinh ra câu mới cũng là câu dạng Horn). Thuật giải suy diễn tiến/lùi trên cơ sở tri thức dạng Horn trình bày chi tiết trong mục 8, nó có độ phức tạp tuyến tính đối với số câu trong KB.",
        "Summary": "Chi tiết thuật toán suy diễn dựa trên luật phân giải KB q được trình bày trong mục 7 của Chương này thực tế thì thuật toán suy diễn phân giải trả lời bài toán tương đương KB q . Thuật giải suy diễn tiếnlùi trên cơ sở tri thức dạng Horn trình bày chi tiết trong mục 8, nó có độ phức tạp tuyến tính đối với số câu trong KB.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt gần như hoàn toàn trung thực. Tuy nhiên, có một chi tiết nhỏ cần xem xét: Biểu thức 'KB q' trong bản tóm tắt có thể gây hiểu nhầm vì thiếu ký hiệu '╞' (dẫn xuất logic). Trong văn bản gốc, biểu thức này xuất hiện dưới dạng 'KB╞ q', thể hiện rõ ràng mối quan hệ kéo theo logic. Việc lược bỏ ký hiệu này có thể làm thay đổi ý nghĩa một chút, dù không lớn."
            },
            "Tính mạch lạc": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc, nhưng sự liên kết giữa hai câu còn yếu. Việc liệt kê hai thuật toán mà không giải thích mối liên hệ hoặc mục đích chung của chúng khiến người đọc khó nắm bắt được ý chính. Cần có một câu dẫn nhập hoặc kết nối để làm rõ hơn vai trò của hai thuật toán này trong việc giải quyết vấn đề."
            },
            "Tính liên quan": {
                "Điểm": 3,
                "Đánh giá": "Bản tóm tắt có chọn lọc một số ý từ văn bản gốc, nhưng bỏ qua nhiều thông tin quan trọng khác. Ví dụ, văn bản gốc giải thích lý do tại sao giải thuật phân giải không hiệu quả và tại sao cần sử dụng dạng Horn. Bản tóm tắt hiện tại chỉ đơn thuần liệt kê hai thuật toán mà không cung cấp bối cảnh hoặc động cơ, làm giảm đi giá trị thông tin."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt ở mức trung bình. Điểm mạnh là trung thực với thông tin trong văn bản gốc. Tuy nhiên, bản tóm tắt thiếu tính mạch lạc và liên quan do bỏ qua nhiều chi tiết quan trọng, khiến người đọc khó hiểu được bức tranh toàn cảnh. Để cải thiện, cần bổ sung thêm thông tin về bối cảnh, mục đích của các thuật toán, và mối liên hệ giữa chúng. Đồng thời, cần đảm bảo tính chính xác tuyệt đối trong việc sao chép các ký hiệu logic."
            }
        }
    },
    {
        "Index": "00091",
        "Article": "Khi xây dựng cây quyết định, nếu để độ sâu tùy ý thì cây sẽ phân loại đúng hết các dữ liệu trong tập học, dẫn đến mô hình có thể dự đoán tệ trên tập kiểm thử. Khi đó mô hình bị quá khớp. Thuật toán Random Forests gồm nhiều cây quyết định, mỗi cây quyết định đều có những yếu tố ngẫu nhiên: 1. Lấy ngẫu nhiên dữ liệu để xây dựng cây quyết định. 2. Lấy ngẫu nhiên các thuộc tính để đặt vào một đỉnh. Do mỗi cây quyết định trong thuật toán học Random Forests không dùng tất cả dữ liệu luyện, cũng như không dùng tất cả các thuộc tính của dữ liệu để xây dựng cây nên mỗi cây có thể sẽ dự đoán không tốt, khi đó mỗi mô hình cây quyết định không bị quá khớp mà có thế bị kém khớp, hay nói cách khác là mô hình có high bias. Tuy nhiên, kết quả cuối cùng của thuật toán Random Forests lại tổng hợp từ nhiều cây quyết định, thế nên thông tin từ các cây sẽ bổ sung thông tin cho nhau, dẫn đến mô hình có độ lệch và phương sai bé, hay mô hình có kết quả dự đoán tốt. Random Forest là một thuật toán học máy phổ biến thuộc về phương pháp học có giám sát. Nó có thể được sử dụng cho cả bài toán Phân loại và Hồi quy trong Học máy. Nó dựa trên khái niệm học kết hợp, là một quá trình kết hợp nhiều bộ phân loại để giải quyết một vấn đề phức tạp và để cải thiện hiệu suất của mô hình. Rừng ngẫu nhiên cũng là một thuật toán học máy linh hoạt, dễ sử dụng, tạo ra kết quả tuyệt vời ngay cả khi không điều chỉnh siêu tham số. Nó cũng là một trong những thuật toán được sử dụng nhiều nhất, do tính đơn giản và đa dạng của nó. Như tên gọi của phương pháp học máy này, “Rừng ngẫu nhiên là một bộ phân loại chứa một số cây quyết định trên các tập con khác nhau của tập dữ liệu cũng như các tập con thuộc tính khác nhau và lấy giá trị dự đoán trung bình để cải thiện độ chính xác dự đoán của tập dữ liệu đó.”",
        "Summary": "Random Forests là một thuật toán học máy có giám sát, sử dụng nhiều cây quyết định được xây dựng ngẫu nhiên từ các tập dữ liệu và thuộc tính con. Mỗi cây có thể kém khớp (high bias) do không sử dụng toàn bộ dữ liệu và thuộc tính, nhưng kết quả cuối cùng được tổng hợp từ nhiều cây, bổ sung thông tin cho nhau, giúp giảm độ lệch và phương sai, mang lại kết quả dự đoán tốt. Thuật toán này linh hoạt, dễ sử dụng và hiệu quả cho cả bài toán phân loại và hồi quy.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày rõ ràng, logic và có sự liên kết chặt chẽ với nhau. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào bản chất của thuật toán Random Forests, ưu điểm và ứng dụng của nó."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về thuật toán Random Forests. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00092",
        "Article": "3.2. Sao chép, cắt dán, xóa văn bản\n Sao chép văn bản\n Trong quá trình soạn thảo, chỉnh sửa văn bản bạn thường xuyên có nhu cầu sao chép một phần, hoặc toàn\n bộ nội dung từ văn bản này sang văn bản khác hoặc giữa các đoạn trong cùng một văn bản. Để thực hiện\n bạn có thể làm theo các bước sau đây:\n Bước 1: Lựa chọn (bôi đen) nội dung văn bản cần sao chép\n Bước 2: Tiếp theo thực hiện theo một trong các cách sau đây:\n - Nhấn tổ hợp phím Ctrl + C\n - Nhấp phải chuột chọn Copy\n - Trong Tab Home trên thanh công cụ Ribbon tìm tới nhóm Clipboard chọn nút Copy.\n Cắt văn bản\n Trong một số trường hợp bạn cần di chuyển một đoạn văn bản từ vị trí này tới vị trí khác, hay từ văn bản\n này sang văn bản khác bạn có thể sử dụng chức năng Cut văn bản của Microsoft Word 2013. Cách thực\n hiện như sau:\n Bước 1: Chọn nội dung văn bản cần cắt (Cut).\n Bước 2: Thực hiện theo một trong các cách sau đây:\n - Nhấn tổ hợp phím Ctrl + X\n - Nhấp phải chuột chọn Cut\n - Nhấp chọn Tab Home trên thanh công cụ Ribbon, tìm tới nhóm Clipboard chọn biểu tượng Cut.\n Dán văn bản\n Sao khi sao chép hay cắt nội dung văn bản ở hai phần trước nhu cầu tiếp theo của bạn chắc chắn là cần\n phải dón nó vào một vị trí nào đó. Để thực hiện bạn làm như sau:\n Bước 1: Nhấp trỏ chuột tới vị trí cần dán văn bản.\n Bước 2: Thực hiện theo một trong các cách sau đây:\n - Nhấn tổ hợp phím Ctrl + V\n - Nhấp phải chuột trong mục Paste Options\n + Keep source formatting: Dán cả nội dung Text và dữ lại định dạng như nguyên gốc.\n + Merge formatting: Dán nội dung Text và hòa chộn định dạng gốc với định dạng của vị trí cần dán.\n + Keep Text Only: Chỉ dán mình nội dung Text, lấy định dạng theo định dạng của vị trí con trỏ hiện\n thời.\n - Nhấp chọn Tab Home trên thanh công cụ Ribbon chọn tới nhóm Clipboard.\n + Chọn biểu tượng Paste: Copy theo mặc định\n + Keep source formatting: Dán cả nội dung Text và dữ lại định dạng như nguyên gốc.\n + Merge formatting: Dán nội dung Text và hòa chộn định dạng gốc với định dạng của vị trí cần dán.\n + Keep Text Only: Chỉ dán mình nội dung Text, lấy định dạng theo định dạng của vị trí con trỏ hiện\n thời.\n - Nhấp chọn Tab Home trên thanh công cụ Ribbon chọn tới nhóm Clipboard.\n Xóa văn bản\n Bạn có thể thực hiện xóa chỉ một ký tự hoặc xoá một đoạn hay cả văn bản. Chương trình sẽ thực hiện\n lệnh xóa với những ký tự mà bạn đã chọn.\n - Xoá một ký tự: Đặt con trỏ Text trong văn bản, gõ phím Delete để xoá một ký tự ở bên phải con trỏ Text,\n gõ phím Backspace để xoá một ký tự ở bên trái con trỏ Text.\n - Xoá một đoạn văn bản: Đánh dấu chọn đoạn văn bản mà bạn cần xóa, nhấn phím Delete hoặc phím\n Backspace để xóa đoạn văn bản đó.",
        "Summary": "\"Văn bản hướng dẫn cách sao chép, cắt, dán và xóa văn bản trong Microsoft Word 2013. Để sao chép hoặc cắt văn bản, chọn nội dung cần thao tác, sau đó sử dụng tổ hợp phím (Ctrl+C/Ctrl+X), chuột phải hoặc lệnh trong nhóm Clipboard của tab Home. Để dán văn bản, di chuyển con trỏ tới vị trí cần dán và sử dụng tổ hợp phím (Ctrl+V), chuột phải (với các tùy chọn định dạng khác nhau) hoặc lệnh Paste trong nhóm Clipboard của tab Home. Để xóa văn bản, có thể xóa từng ký tự bằng phím Delete (xóa ký tự bên phải) hoặc Backspace (xóa ký tự bên trái), hoặc xóa cả đoạn văn bản bằng cách chọn đoạn văn bản và nhấn Delete hoặc Backspace.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, dễ hiểu. Các câu liên kết với nhau một cách trôi chảy, tạo thành một đoạn văn hoàn chỉnh."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào cách thực hiện các thao tác sao chép, cắt, dán và xóa văn bản."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã bao quát được các ý chính của văn bản gốc một cách ngắn gọn và dễ hiểu. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00093",
        "Article": "3.2. Phương pháp LSB\n Cách thay thế LSB là cách đơn giản để nhúng thông tin vào một tệp âm thanh kỹ thuật\n số. Phương pháp LSB cho phép một lượng lớn dữ liệu được nhúng, tốc độ truyền dữ liệu\n nhanh. Chi tiết về phương pháp thay thế LSB đã được trình bày trong chương 2 (kỹ thuật giấu\n tin trong ảnh). Điểm cần lưu ý đối với phương pháp LSB trong âm thanh là thông tin sẽ được\n giấu vào trong file âm thanh. Để thực hiện được điều đó thì người giấu tin cần thực hiện những\n thao tác sau:\n ü Bước 1: Đọc file âm thanh gốc. Chia âm thanh gốc thành các segmen. Thông thường,\n người giấu tin sẽ chia file âm thanh các segmen dựa trên độ dài bit của thông tin cần giấu. Sau\n đó các segmen này được vector giá trị của tín hiệu, rồi lưu vào mảng một chiều để thực hiện\n giấu tin.\n ü Bước 2: Chuyển đổi thông tin cần giấu sang dạng nhị phân, tính độ dài bit của thông\n tin rồi lưu vào L.62\n ü Bước 3: Chọn k là số bit LSB của tín hiệu âm thanh sẽ giấu sao cho phù hợp nhất.\n ü Bước 4: Chia chuỗi bit thông điệp thành các chuỗi con có độ dài k bit. Trong đó, mỗi\n chuỗi con này sẽ được thay thế vào k bit LSB của L k tín hiệu âm thanh để giấu đủ L bit thông\n điệp.\n ü Bước 5: Thực hiện giấu L bit đã tính vào các segmen. Để tăng độ an toàn cho kỹ thuật\n này, có thể sử dụng bộ sinh số ngẫu nhiên để sinh ra các vị trí các mẫu được chọn giấu chứ\n không phải các mẫu liên tục. Bộ sinh số này sử dụng một khóa bí mật như là phần tử khởi tạo\n bộ sinh số. Khóa được sử dụng trong cả quá trình giấu tin và giải tin.\n ü Bước 6: Lưu lại tệp âm thanh kết quả F’ được thông tin đã giấu Hình 3.2 thể hiện pháp thay thế LSB với trường hợp thay thế 1 bit LSB. Trong thực tế\n hiện nay cũng có một số hướng tiếp cận khác nhằm nâng cao chất lượng giấu tin trong kỹ thuật\n LSB. Ví dụ phương pháp sử dụng 4 bit LSB thay vì 1 bit LSB đơn lẻ hoặc phương pháp kết\n hợp giữa bít quan trọng nhất (MSB -Most Significant Bit) và LSB. Chi tiết các phương pháp\n này đã được trình bày trong một số bài báo [16, 17]. Hình 3.3 và 3.4 dưới đây mô tả quy trình\n giấu tin sử dụng 4 bit LSB và 7 bit MSB",
        "Summary": "\"Phương pháp LSB là một cách đơn giản để nhúng thông tin vào tệp âm thanh kỹ thuật số với tốc độ truyền dữ liệu nhanh. Để giấu tin, người dùng cần đọc file âm thanh gốc, chia thành các segment dựa trên độ dài bit của thông tin cần giấu, chuyển đổi thông tin cần giấu sang dạng nhị phân, chọn số bit LSB (k) phù hợp, chia chuỗi bit thông điệp thành các chuỗi con có độ dài k bit, thay thế vào k bit LSB của tín hiệu âm thanh, và lưu lại tệp âm thanh kết quả. Để tăng độ an toàn, có thể sử dụng bộ sinh số ngẫu nhiên để chọn vị trí giấu tin. Ngoài ra, có các phương pháp nâng cao chất lượng bằng cách sử dụng nhiều bit LSB hơn (ví dụ 4 bit) hoặc kết hợp MSB và LSB.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất phát từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, theo đúng trình tự các bước trong quy trình giấu tin bằng phương pháp LSB. Các câu liên kết với nhau một cách tự nhiên, giúp người đọc dễ dàng theo dõi và hiểu nội dung."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa phương pháp LSB, các bước thực hiện giấu tin, và các phương pháp nâng cao. Các chi tiết không quan trọng đã được loại bỏ, giúp bản tóm tắt ngắn gọn và tập trung vào trọng tâm."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Bản tóm tắt đã tóm gọn được những ý chính của văn bản gốc một cách hiệu quả. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00094",
        "Article": "Phát hiện khuôn mặt và tăng cường dữ\n liệu ảnh với MTCNN\n 3.3.1. Phát hiện khuôn mặt\n Với một ảnh đầu vào, đầu tiên, hệ thống\n phải thực hiện phát hiện khuôn mặt (Face\n detection) với MTCNN (Ku Hongchang,\n 2020), một mô hình mạng nơ-ron tích hợp\n CNN hoạt động đa nhiệm. MTCNN là gồm\n ba lớp Mạng đề xuất P-net (Proposal\n Network), Mạng tinh chỉnh R-net (Refine\n Network) và Mạng đầu ra O-net (Output\n Network). Hình 4 mô tả thuật toán MTCNN. Ban đầu các hình ảnh đầu vào được đưa\n vào P-Net để điều chỉnh kích thước để phát\n hiện các khuôn mặt có tất cả các kích thước\n khác nhau, đồng thời lấy ra các cửa sổ có thể\n là khuôn mặt và các vectơ hồi quy trong các\n cửa sổ đó. Sau đó, các cửa sổ này được sàng\n lọc thông qua mạng R-Net để loại bỏ phần\n lớn các cửa sổ không chứa khuôn mặt. Cuối\n cùng, Mạng đầu ra (O-Net) được sử dụng để\n chọn lọc kết quả chính xác một lần nữa và\n đánh dấu tọa độ của năm điểm mốc trên\n khuôn mặt.\n 3.3.2. Tăng cường dữ liệu ảnh\n Bộ dữ liệu quy mô lớn là điều kiện cần\n thiết để huấn luyện thành công mạng nơ-ron.\n Công nghệ tăng cường hình ảnh sử dụng một\n loạt các thay đổi ngẫu nhiên đối với hình ảnh\n đào tạo để tạo ra các mẫu đào tạo tương tự\n nhưng khác nhau, do đó mở rộng kích thước\n của tập dữ liệu. Để nâng cao độ chính xác\n của mô hình khi nhận diện, thư viện MTCNN\n được sử dụng để tăng cường hình ảnh, được\n mô tả trong hình 5, cụ thể như sau:\n · Chuẩn hóa theo phân phối chuẩn các\n pixels của ảnh;\n · Tạo các ảnh với các góc nghiêng là\n 20 độ (trái, phải);\n · Dịch chuyển ảnh theo rộng;\n · Dịch chuyển ảnh theo chiều cao;\n · Lật ảnh theo chiều ngang;Như vậy, với từ một hình ảnh khuôn mặt\n được phát hiện, chúng tôi tăng cường thêm 9\n hình ảnh, tạo ra tập dữ liệu ảnh cho đầu vào\n mô hình FaceNet là 7700 ảnh. Mỗi lớp (thư\n mục ảnh) được chia thành 80-20 cho huấn\n luyện (training) và thử nghiệm (testing).",
        "Summary": "\"Để phát hiện khuôn mặt trong ảnh, hệ thống sử dụng MTCNN, một mô hình mạng nơ-ron tích hợp CNN đa nhiệm gồm ba lớp: P-Net, R-Net và O-Net. P-Net điều chỉnh kích thước ảnh, R-Net sàng lọc các cửa sổ không chứa khuôn mặt và O-Net chọn lọc kết quả chính xác, đánh dấu tọa độ năm điểm mốc trên khuôn mặt. Để tăng cường dữ liệu huấn luyện, thư viện MTCNN được sử dụng để tạo ra chín ảnh mới từ mỗi ảnh gốc thông qua chuẩn hóa pixel, tạo ảnh nghiêng 20 độ, dịch chuyển ảnh theo chiều rộng và cao, và lật ảnh theo chiều ngang. Tập dữ liệu ảnh sau tăng cường được chia thành tỷ lệ 80-20 cho huấn luyện và thử nghiệm.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, với sự liên kết chặt chẽ giữa các câu. Cách diễn đạt dễ hiểu, giúp người đọc nắm bắt thông tin một cách nhanh chóng."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết. Tóm tắt tập trung vào quy trình phát hiện khuôn mặt bằng MTCNN và phương pháp tăng cường dữ liệu ảnh, đúng trọng tâm của văn bản gốc."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00095",
        "Article": "Bo mạch chủ (mainboard hay motherboard) là bảng mạch lớn nhất trong máy tính, đóng vai trò trung tâm liên kết và điều khiển các thành phần phần cứng được cắm vào nó. Mainboard là cầu nối trung gian giúp các thiết bị trong hệ thống giao tiếp với nhau một cách hiệu quả.Trên bo mạch chủ, có các khe cắm RAM giúp mở rộng bộ nhớ hệ thống, khe cắm CPU dành cho bộ vi xử lý, và các khe cắm mở rộng như PCI, PCIe để kết nối card đồ họa, card âm thanh hoặc card mạng. Ngoài ra, mainboard còn có các cổng kết nối dành cho thiết bị lưu trữ (HDD, SSD) thông qua cổng SATA hoặc M.2. Các cổng giao tiếp ngoại vi như USB, HDMI, DisplayPort, COM, LPT, PS/2 giúp kết nối với chuột, bàn phím, màn hình và các thiết bị khác.Một thành phần quan trọng trên bo mạch chủ là BIOS (hoặc UEFI), phần mềm nhúng trong chip ROM giúp khởi động hệ thống và quản lý cài đặt phần cứng. Pin CMOS trên mainboard giúp duy trì đồng hồ hệ thống và các thiết lập BIOS khi máy tính bị tắt nguồn. BIOS cho phép người dùng cấu hình các thông số như thứ tự boot, tốc độ quạt, điện áp CPU, RAM, cũng như hỗ trợ ép xung để tối ưu hiệu suất hoạt động của hệ thống.Hệ thống bus trên bo mạch chủ đóng vai trò quan trọng trong việc truyền tải dữ liệu giữa các linh kiện. Bus bao gồm bus dữ liệu, bus địa chỉ và bus điều khiển, giúp CPU giao tiếp với RAM, ổ cứng và các thiết bị ngoại vi. Các loại bus hiện đại như PCIe 4.0, PCIe 5.0, USB 3.2, Thunderbolt giúp tăng tốc độ truyền tải dữ liệu, tối ưu hóa hiệu suất hệ thống.Ngoài ra, mainboard còn có hệ thống tản nhiệt với các cảm biến nhiệt độ để theo dõi và điều chỉnh tốc độ quạt nhằm giữ cho CPU và các linh kiện khác hoạt động ổn định. Một số bo mạch chủ cao cấp hỗ trợ đèn LED RGB, tích hợp Wi-Fi, Bluetooth và cổng âm thanh cao cấp để nâng cao trải nghiệm người dùng. Tùy theo nhu cầu, người dùng có thể lựa chọn mainboard phù hợp với chipset Intel hoặc AMD, hỗ trợ các dòng CPU khác nhau, cũng như cung cấp các tính năng đặc biệt phục vụ chơi game, thiết kế đồ họa hoặc làm việc chuyên sâu.",
        "Summary": "Bo mạch chủ (mainboard) là thành phần quan trọng kết nối và điều khiển các linh kiện trong máy tính, bao gồm khe cắm RAM, CPU, và các khe mở rộng như PCIe cho card đồ họa. Nó còn có cổng kết nối cho thiết bị lưu trữ và ngoại vi, cùng với BIOS/UEFI quản lý khởi động và cấu hình phần cứng. Hệ thống bus trên mainboard giúp truyền tải dữ liệu giữa các linh kiện, trong khi các tính năng như tản nhiệt, LED RGB và hỗ trợ Wi-Fi, Bluetooth mang lại trải nghiệm người dùng tối ưu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, tạo thành một dòng chảy thông tin dễ hiểu. Các câu liên kết với nhau một cách tự nhiên."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc về vai trò, các thành phần, chức năng và tính năng của bo mạch chủ, loại bỏ các chi tiết không cần thiết."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan đầy đủ về bo mạch chủ. Không có điểm nào cần cải thiện đáng kể."
            }
        }
    },
    {
        "Index": "00096",
        "Article": "Phương pháp giải trực tiếp áp dụng khi bài toán có công thức rõ ràng, ví dụ tính diện tích hình tròn (S = πr²) chỉ cần nhập bán kính và áp dụng công thức. Ngược lại, phương pháp tìm kiếm lời giải dùng cho bài toán phức tạp, không có công thức cố định, như tìm đường đi ngắn nhất trong đồ thị, yêu cầu thử nghiệm các khả năng (thường dùng thuật toán vét cạn hoặc heuristic). Giáo trình minh họa qua bài toán tính UCLN của hai số: phương pháp trực tiếp dùng thuật toán Euclid (chia lấy dư liên tiếp), trong khi tìm kiếm có thể thử các ước chung từ nhỏ đến lớn. Độ phức tạp thuật toán được đánh giá qua thời gian (số phép tính) và không gian (bộ nhớ sử dụng), ví dụ thuật toán sắp xếp nổi bọt có độ phức tạp O(n²). Các bài toán được phân loại thành đơn giản (tính toán cơ bản), trung bình (xử lý mảng), và phức tạp (tối ưu hóa). Giáo trình nhấn mạnh rằng lựa chọn phương pháp phụ thuộc vào đặc điểm bài toán: nếu dữ liệu đầu vào ít và yêu cầu nhanh, giải trực tiếp là tối ưu; nếu cần khám phá nhiều khả năng, tìm kiếm là cần thiết. Các bài tập thực hành, như viết chương trình kiểm tra số nguyên tố, giúp sinh viên rèn luyện kỹ năng áp dụng cả hai phương pháp. Nội dung này không chỉ cung cấp lý thuyết mà còn hướng dẫn cách tư duy có hệ thống, từ đó giải quyết hiệu quả các vấn đề thực tế trong lập trình và khoa học máy tính. Bài toán được định nghĩa là một tình huống cần tìm lời giải, với dữ liệu đầu vào và kết quả đầu ra mong muốn.",
        "Summary": "Phương pháp giải trực tiếp được áp dụng khi giải hệ phương trình tuyến tính có số lượng ẩn không quá lớn. Điển hình là phương pháp Gauss hoặc Gauss-Jordan nhằm đưa hệ về dạng tam giác rồi giải ngược. Ưu điểm của phương pháp này là cho kết quả chính xác nếu không xảy ra sai số làm tròn. Tuy nhiên, nó không phù hợp với hệ có kích thước lớn do tiêu tốn nhiều bộ nhớ và thời gian. Việc lựa chọn đúng phương pháp giải phù hợp với bài toán giúp tối ưu hiệu quả tính toán và đảm bảo độ chính xác.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 1,
                "Đánh giá": "Bản tóm tắt hoàn toàn không trung thực. Nội dung của bản tóm tắt không hề liên quan đến nội dung của văn bản gốc. Bản tóm tắt nói về 'giải hệ phương trình tuyến tính' và 'phương pháp Gauss', trong khi văn bản gốc thảo luận về hai phương pháp giải quyết vấn đề chung: giải trực tiếp và tìm kiếm lời giải, cùng với các ví dụ và khái niệm liên quan đến độ phức tạp thuật toán và phân loại bài toán."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt tự thân nó mạch lạc. Các câu liên kết với nhau một cách logic và rõ ràng, tạo thành một đoạn văn dễ hiểu về chủ đề giải hệ phương trình tuyến tính."
            },
            "Tính liên quan": {
                "Điểm": 1,
                "Đánh giá": "Bản tóm tắt hoàn toàn không liên quan đến văn bản gốc. Nó tập trung vào một chủ đề khác (giải hệ phương trình tuyến tính) và bỏ qua hoàn toàn các ý chính của văn bản gốc (phương pháp giải trực tiếp, tìm kiếm lời giải, độ phức tạp thuật toán, phân loại bài toán)."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt này có chất lượng rất kém. Nó không trung thực, không liên quan đến văn bản gốc, mặc dù tự thân nó mạch lạc. Cần phải viết lại hoàn toàn bản tóm tắt, đảm bảo bám sát nội dung và ý chính của văn bản gốc."
            }
        }
    },
    {
        "Index": "00097",
        "Article": "Qui ước đặt tên biến và tên hằng: Prolog là ngôn ngữ cho máy tính, vì vậy nó cần một qui ước rất quan trọng trong việc đặt tên biến và tên hằng, theo đó, tên một biến phải bắt đầu bằng ký tự in hoa (chẳng hạn X, Sinhvien, v.v.), còn tên hằng phải bắt đầu bằng ký tự in thường (ví dụ: an, binh, lasinhvien, v.v.). Vì Prolog là ngôn ngữ các câu Horn trong logic vị từ cấp một nên các biến chỉ xuất hiện trong các hạng thức là tham số của các vị từ. Chương trình Prolog, các câu Horn dương: Chương trình Prolog về cơ bản là dãy (hội) các câu Horn dương (câu tuyển có đúng 1 literal dương). Các câu này có dạng Horn dương trong Prolog có dạng tổng quát như sau: head:- p1, p2, …, pn. {nghĩa là: if (p1 and p2 and … and pn) then head}. Ở đây head, P1, p2, …, pn là các vị từ (có thể có các tham số); vị từ head gọi là phần đầu của luật, còn P1, p2, …, pn gọi phần thân (phần điều kiện) của luật. Nếu n>0 thì câu Horn dương trên là câu dạng luật; còn nếu n=0 thì câu không có phần điều kiện, khi này ta có câu mô tả sự kiện và có thể viết đơn giản là: head. Chú ý: các câu trong chương trình Prolog đều kết thúc bởi dấu chấm (“.”). Tất cả các câu đều là câu đóng, nếu có ký hiệu biến xuất hiện trong câu thì ta ngầm hiểu rằng biến đó là biến buộc, đặt dưới lượng từ ∀ , trừ các biến chỉ xuất hiện trong phần điều kiện của câu thì biến đó được hiểu là đặt dưới lượng từ ∃ (thực chất thì nếu chuyển dạng câu tuyển thì ∃ sẽ chuyển sang ∀ do chuyển vế và lấy phủ định). Vị từ, hạng thức: Như đã giới thiệu ở trên, chương trình Prolog bao gồm hai loại câu: câu sự kiện (câu đơn) và câu luật (câu phức). Các câu này được xây dựng từ các vị từ (head, P1, p2, …, pn), mỗi vị từ có cú pháp như sau: tên_vi_tu(hang_thuc1, hang_thuc2, …, hang_thucn) trong đó tên_vị_từ tuân theo qui tắc đặt tên hằng; các hạng_thứci có thể là: Giá trị: tên hằng ký hiệu, ví dụ như an, x, mauxanh, v.v.; hằng xâu, ví dụ ‘Xin chao’; hằng số nguyên hoặc số thực, ví dụ như 5, 3.1416, v.v. Tên biến, ví dụ như X, Sinhvien, v.v. (chú ý: tên biến bắt đầu bằng ký tự viết hoa; các biến đều không có kiểu biến, nó có thể nhận bất cứ một giá trị nào; tất cả các biến đều là biến địa phương trong câu nó xuất hiện). Cấu trúc (nhóm các hạng thức lại thành cấu trúc), ví dụ như: mau[red, green, blue], [march, 17, 2011], v.v. Hai trường hợp đặc biệt của cấu trúc là list và string sẽ được tìm hiểu sâu hơn ở các phần sau của Chương này. Ví dụ về chương trình Prolog: chương trình lưu trong file giapha.pl của ví dụ trước bao gồm ba câu đầu là các câu sự kiện và 2 câu cuối là câu luật; có 4 ký hiệu vị từ là: cha, me, chame, ongba; có 4 tên hằng: nam, hoan, hoa, duong; có 3 biến: X,Y,Z.",
        "Summary": "Trong Prolog, tên biến bắt đầu bằng ký tự in hoa và tên hằng bắt đầu bằng ký tự in thường. Chương trình Prolog gồm các câu Horn dương, trong đó mỗi câu có một phần đầu và phần thân, với phần thân có thể là các điều kiện. Các câu trong Prolog có thể là câu sự kiện (không có điều kiện) hoặc câu luật (có điều kiện), và đều sử dụng các vị từ với các tham số, với biến được hiểu là biến buộc hoặc biến tồn tại tùy theo ngữ cảnh.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách rõ ràng và logic, có sự liên kết chặt chẽ giữa các câu, giúp người đọc dễ dàng nắm bắt được nội dung chính."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Chỉ giữ lại những ý chính và quan trọng nhất từ văn bản gốc, loại bỏ các chi tiết không cần thiết, đảm bảo tính súc tích và tập trung."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, phản ánh chính xác và đầy đủ các ý chính của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00098",
        "Article": "Xây dựng và tối ưu hàm mất mát Tổng quát, nếu mỗi điểm dữ liệu được mô tả bởi một vector đặc trưng d chiều x ∈ R d , hàm dự đoán đầu ra được viết dưới dạng y = w1x1 + w2x2 + · · · + wdxd = x T w. (7.2) 7.2.1. Sai số dự đoán Sau khi xây dựng được mô hình dự đoán đầu ra như (7.2), ta cần tìm một phép đánh giá phù hợp với bài toán. Với bài toán hồi quy nói chung, ta mong muốn sự sai khác e giữa đầu ra thực sự y và đầu ra dự đoán yˆ là nhỏ nhất: 1 2 e 2 = 1 2 (y − yˆ) 2 = 1 2 (y − x T w) 2 . (7.3) Ở đây, bình phương được lấy vì e = y − yˆ có thể là một số âm. Việc sai số là nhỏ nhất có thể được mô tả bằng cách lấy trị tuyệt đối |e| = |y − yˆ|. Tuy nhiên, cách làm này ít được sử dụng vì hàm trị tuyệt đối không khả vi tại gốc toạ độ, không thuận tiện cho việc tối ưu. Hệ số 1 2 sẽ bị triệt tiêu khi lấy đạo hàm của e theo tham số mô hình w. 7.2.2. Hàm mất mát Điều tương tự xảy ra với tất cả các cặp dữ liệu (xi , yi), i = 1, 2, . . . , N, với N là số lượng dữ liệu trong tập huấn luyện. Việc tìm mô hình tốt nhất tương đương với việc tìm w để hàm số sau đạt giá trị nhỏ nhất: L(w) = 1 2N X N i=1 (yi − x T i w) 2 . (7.4) Hàm số L(w) chính là hàm mất mát của mô hình hồi quy tuyến tính với tham số θ = w. Ta luôn mong muốn sự mất mát là nhỏ nhất, điều này có thể đạt được bằng cách tối thiểu hàm mất mát theo w: w ∗ = argmin w L(w). (7.5) w∗ là nghiệm cần tìm của bài toán. Đôi khi dấu ∗ được bỏ đi và nghiệm có thể được viết gọn lại thành w = argmin w L(w). Machine Learning cơ bản 101 https://thuviensach.vn Chương 7. Hồi quy tuyến tính Trung bình sai số Trong machine learning, hàm mất mát thường là trung bình cộng của sai số tại mỗi điểm. Về mặt toán học, hệ số 1 2N không ảnh hưởng tới nghiệm của bài toán. Tuy nhiên, việc lấy trung bình này quan trọng vì số lượng điểm dữ liệu trong tập huấn luyện có thể thay đổi. Việc tính toán mất mát trên từng điểm dữ liệu sẽ hữu ích hơn trong việc đánh giá chất lượng mô hình. Ngoài ra, việc lấy trung bình cũng giúp tránh hiện tượng tràn số khi số lượng điểm dữ liệu lớn.",
        "Summary": "\"Hàm mất mát trong machine learning, đặc biệt là hồi quy tuyến tính, được xây dựng để đánh giá sai số giữa đầu ra dự đoán và đầu ra thực tế. Sai số thường được tính bằng bình phương sai lệch (y - xTw)^2 để đảm bảo giá trị dương và tính khả vi. Hàm mất mát L(w) là trung bình cộng của các sai số này trên toàn bộ tập huấn luyện, và mục tiêu là tìm vector trọng số w sao cho L(w) đạt giá trị nhỏ nhất, từ đó tìm ra mô hình dự đoán tốt nhất. Việc lấy trung bình sai số giúp ổn định kết quả khi số lượng dữ liệu huấn luyện thay đổi và tránh tràn số.\"",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều có thể được tìm thấy và kiểm chứng trong văn bản gốc. Không có thông tin nào bị thêm vào hoặc diễn giải sai lệch."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các ý được trình bày một cách logic và rõ ràng, từ việc xây dựng hàm mất mát đến mục tiêu tối ưu hóa nó. Các câu liên kết chặt chẽ với nhau, tạo thành một dòng chảy thông tin dễ hiểu."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, bao gồm định nghĩa hàm mất mát, cách tính sai số, và mục tiêu tối ưu hóa. Không có chi tiết nào thừa hoặc không liên quan được đưa vào."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan, cung cấp một cái nhìn tổng quan chính xác và dễ hiểu về nội dung của văn bản gốc. Không có điểm nào cần cải thiện."
            }
        }
    },
    {
        "Index": "00099",
        "Article": "Các gam màu sắc Được chia làm 8 loại Màu nóng: Màu nóng tự mang trong nó sự lôi cuốn và gây chú ý, có tính phản chiếu cao. Tạo nên những ý tưởng tươi vui, cởi mở, kích động, … Nó có tác động mạnh mẽ đến không gian trong bố cục chung. Màu nóng gồm 2 màu chính là đỏ và vàng cùng các màu tương cận của chúng (như cam, hồng, tím đỏ, vàng xanh lục…). Màu lạnh: những màu cho ta cảm giác mát mẻ, ví dụ như: xanh lam, xanh lá cây, đen, tím…… Màu lạnh làm cho bức hình cảm giác tươi tắn, toả sáng, gợi cảm giác mát mẻ, nhẹ nhàng. Màu lạnh đối lập với màu nóng. Màu nóng và màu lạnh Màu tương phản: là sự đối lập của màu nóng và màu lạnh. Tương phản với các hệ thống các màu gốc: Xanh = C, Vàng = Y, Đỏ = M, nhờ có màu tương phản mà bức hình đạt được sự rực rỡ. Màu tương phản thường là những màu gốc hoặc có tính gốc cao. Bản thân các màu này có độ mạnh thị giác cao, nên khi đặt cạnh nhau trong một bố cục, các màu sẽ tạo nên thị cảm mạnh. Với những màu nóng và lạnh đứng cạnh nhau, sự tương phản sẽ dịu hơn nếu được thay đổi độ sáng tối. Màu tương đồng: Với những màu cùng Gam nóng hoặc lạnh có một sự tương quan nhất định, chúng được gọi là màu cùng tone, hoặc màu tương đồng. Trong thực tế, màu tương đồng vẫn có Phát triển Web 2012 64 www.izwebz.com Demon Warlock thể chứa một lượng màu tương phản hoặc ngược lại, vấn đề là phải xem xét lượng màu trên một diện tích và vai trò của nó đến quan hệ hoà sắc. Màu tương đồng Màu vô sắc: Là những màu mà khi ta hoà trộn chúng với nhau không tạo nên được màu mới. Ví dụ đen, trắng và các thang độ xám khi được hoà trộn. Màu vô sắc Màu bổ túc: Những cặp màu bổ túc là những cặp màu có tính tương phản mạnh, gồm có những cặp màu cơ bản sau đây. Đỏ – Xanh lục, Da cam – Xanh lam, Vàng – Tím. Những màu này không thể gây cảm cảm giác đồng thời đối với con người, chẳng hạn không thể có một màu gọi là “đỏ – lục” hoặc “vàng – tím”. Điều này tương tự cảm giác về nhiệt độ, không có cảm giác nào được gọi là cảm giác “nóng – lạnh”, mà là “nóng” hoặc “lạnh”. Phát triển Web 2012 65 www.izwebz.com Demon Warlock Màu sắc độ: Đây là thuật ngữ để chỉ độ đậm nhạt của từng loại màu. Sự thay đổi này phụ thuộc vào việc ta cộng thêm màu đen hay màu trắng cho màu gốc để tạo nên các dải màu. Màu trắng sẽ cho ta màu sáng hơn còn màu đen thì ngược lại. Màu sắc điệu: Là khái niệm chỉ sự biến thiên của màu sắc. Sự kết hợp giữa các màu hữu sắc sẽ cho ta thấy điều này. Bạn có thể dễ dàng hiểu được thế nào là một bức hình “ ngả vàng”, tone xanh hay thiên đỏ… đó chính là hiệu quả của sự kết hợp các màu. Màu đen, trắng và xám không có sắc điệu mà chỉ có sắc độ mà thôi.",
        "Summary": "Các gam màu sắc được chia thành 8 loại chính: màu nóng (lôi cuốn, gây chú ý, tạo cảm giác tươi vui, gồm đỏ, vàng và các màu tương cận), màu lạnh (mát mẻ, tươi tắn, nhẹ nhàng, gồm xanh lam, xanh lá cây, đen, tím), màu tương phản (đối lập giữa nóng và lạnh, tạo sự rực rỡ), màu tương đồng (cùng gam nóng hoặc lạnh, có sự tương quan), màu vô sắc (không tạo ra màu mới khi trộn, ví dụ đen, trắng, xám), màu bổ túc (tương phản mạnh, ví dụ đỏ - xanh lục, da cam - xanh lam, vàng - tím), màu sắc độ (độ đậm nhạt của màu) và màu sắc điệu (sự biến thiên của màu sắc). Màu đen, trắng, xám chỉ có sắc độ, không có sắc điệu.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin đều được lấy từ văn bản gốc và không có sự thêm thắt hoặc diễn giải sai lệch nào."
            },
            "Tính mạch lạc": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt rất mạch lạc. Các loại màu sắc được liệt kê và mô tả ngắn gọn, rõ ràng. Các ý được liên kết với nhau một cách logic, giúp người đọc dễ dàng nắm bắt thông tin."
            },
            "Tính liên quan": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn liên quan. Nó tập trung vào các ý chính của văn bản gốc, đó là các loại màu sắc và đặc điểm của chúng. Không có chi tiết nào thừa hoặc không liên quan."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng rất tốt. Nó trung thực, mạch lạc và liên quan. Tóm tắt đã chọn lọc và trình bày các ý chính một cách hiệu quả, giúp người đọc nhanh chóng nắm bắt được nội dung của văn bản gốc."
            }
        }
    },
    {
        "Index": "00100",
        "Article": "Thủ tục hóa tất cả các câu lệnh và chỉ cấp quyền thực + Cấm hoặc vô hiệu hóa (disable) việc thực hiện các thủ tục hệ thống (các thủ tục cơ sở dữ liệu có sẵn) cho phép can thiệp vào hệ quản trị cơ sở dữ liệu và hệ điều - Sử dụng các công cụ rà quét lỗ hổng chèn mã SQL, nhƣ SQLMap, hoặc Acunetix Vulnerability Scanner để chủ động rà quét, tìm các lỗ hổng chèn mã SQL và có biện pháp khắc phục phù hợp. 2.4. Tấn công vào các cơ chế xác thực Xác thực (authentication) trong một mức độ nào đó nhằm xác minh thông tin nhận dạng của một cá nhân hoặc một thực thể. Trao quyền (authorization) xác định các quyền truy nhập vào các đối tƣợng, tài nguyên mà ngƣời dùng đƣợc cấp, sau khi ngƣời dùng đã đƣợc xác thực. Tấn công vào các cơ chế xác thực (Authentication attacks) là các loại tấn công vào khâu xác thực thông tin định danh ngƣời dùng (User authentication) và trao quyền cho ngƣời dùng (User authorization). Để phá đƣợc cơ chế xác thực ứng dụng web, kẻ tấn công có 2 lựa chọn: (1) Đánh cắp mật khẩu tài khoản ngƣời dùng và (2) Bỏ qua khâu xác thực ngƣời dùng. Cả 2 lựa chọn trên đều đƣợc các tin tặc sử dụng trong từng điều kiện khác nhau trên các hệ thống khác nhau. 2.4.2. Các dạng tấn công vào các cơ chế xác thực Các dạng tấn công vào các cơ chế xác thực bao gồm các dạng sau: phát lại chuỗi định danh phiên, vét cạn, nghe lén, khởi tạo lại mật khẩu và XSS / SQL Injection. 2.4.2.1. Phát lại chuỗi định danh phiên Nhƣ đã đề cập trong Chƣơng 1, giao thức HTTP không hỗ trợ phiên (session) làm việc.",
        "Summary": "Thủ tục hóa tất cả các câu lệnh và chỉ cấp quyền thực + Cấm hoặc vô hiệu hóa disable việc thực hiện các thủ tục hệ thống các thủ tục cơ sở dữ liệu có sẵn cho phép can thiệp vào hệ quản trị cơ sở dữ liệu và hệ điều - Sử dụng các công cụ rà quét lỗ hổng chèn mã SQL, nhƣ SQLMap, hoặc Acunetix Vulnerability Scanner để chủ động rà quét, tìm các lỗ hổng chèn mã SQL và có biện pháp khắc phục phù hợp. Để phá đƣợc cơ chế xác thực ứng dụng web, kẻ tấn công có 2 lựa chọn 1 Đánh cắp mật khẩu tài khoản ngƣời dùng và 2 Bỏ qua khâu xác thực ngƣời dùng.",
        "Result": {
            "Tính trung thực": {
                "Điểm": 5,
                "Đánh giá": "Bản tóm tắt hoàn toàn trung thực. Tất cả thông tin trong bản tóm tắt đều xuất hiện trong văn bản gốc và không bị thay đổi ý nghĩa."
            },
            "Tính mạch lạc": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt tương đối mạch lạc. Tuy nhiên, có một vài chỗ có thể cải thiện để tăng tính trôi chảy. Ví dụ, có thể thêm các từ nối để liên kết các ý tưởng lại với nhau."
            },
            "Tính liên quan": {
                "Điểm": 4,
                "Đánh giá": "Bản tóm tắt liên quan đến văn bản gốc, tập trung vào các ý chính. Tuy nhiên, có thể lược bỏ bớt một vài chi tiết nhỏ để bản tóm tắt ngắn gọn hơn."
            },
            "Nhận xét chung": {
                "Đánh giá": "Bản tóm tắt có chất lượng khá tốt, trung thực và liên quan đến văn bản gốc. Tuy nhiên, có thể cải thiện thêm về tính mạch lạc và độ ngắn gọn."
            }
        }
    }
]